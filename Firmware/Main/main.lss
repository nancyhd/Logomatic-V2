
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00008698  00010000  00010000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000008a4  40000000  00018698  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000a74  400008a4  400008a4  000188a4  2**2
                  ALLOC
  3 .stack        00000c00  40001400  40001400  000188b0  2**4
                  CONTENTS
  4 .comment      000003cc  00000000  00000000  000194b0  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000388  00000000  00000000  00019880  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000b54  00000000  00000000  00019c08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005ef1  00000000  00000000  0001a75c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001ed0  00000000  00000000  0002064d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001cf1  00000000  00000000  0002251d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001120  00000000  00000000  00024210  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001c12  00000000  00000000  00025330  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003a6f  00000000  00000000  00026f42  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000358  00000000  00000000  0002a9b1  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00010000 <__Vectors>:
// Exception Vectors
// Mapped to Address 0.
// Absolute addressing mode must be used.

__Vectors:        LDR     PC,Reset_Addr         
   10000:	e59ff018 	ldr	pc, [pc, #24]	; 10020 <Reset_Addr>
                LDR     PC,Undef_Addr
   10004:	e59ff018 	ldr	pc, [pc, #24]	; 10024 <Undef_Addr>
                LDR     PC,SWI_Addr
   10008:	e59ff018 	ldr	pc, [pc, #24]	; 10028 <SWI_Addr>
                LDR     PC,PAbt_Addr
   1000c:	e59ff018 	ldr	pc, [pc, #24]	; 1002c <PAbt_Addr>
                LDR     PC,DAbt_Addr
   10010:	e59ff018 	ldr	pc, [pc, #24]	; 10030 <DAbt_Addr>
                NOP                            /* Reserved Vector */
   10014:	e1a00000 	nop			(mov r0,r0)
//                LDR     PC,IRQ_Addr
//                LDR     PC,[PC, #-0x0FF0]      /* Vector from VicVectAddr */
                LDR     PC,IRQ_Wrapper_Addr
   10018:	e59ff018 	ldr	pc, [pc, #24]	; 10038 <IRQ_Wrapper_Addr>
                LDR     PC,FIQ_Addr
   1001c:	e59ff018 	ldr	pc, [pc, #24]	; 1003c <FIQ_Addr>

00010020 <Reset_Addr>:
   10020:	00010098 	muleq	r1, r8, r0

00010024 <Undef_Addr>:
   10024:	00010040 	andeq	r0, r1, r0, asr #32

00010028 <SWI_Addr>:
   10028:	00000000 	andeq	r0, r0, r0

0001002c <PAbt_Addr>:
   1002c:	00010044 	andeq	r0, r1, r4, asr #32

00010030 <DAbt_Addr>:
   10030:	00010048 	andeq	r0, r1, r8, asr #32
   10034:	00000000 	andeq	r0, r0, r0

00010038 <IRQ_Wrapper_Addr>:
   10038:	00010050 	andeq	r0, r1, r0, asr r0

0001003c <FIQ_Addr>:
   1003c:	0001004c 	andeq	r0, r1, ip, asr #32

00010040 <Undef_Handler>:

Reset_Addr:       .word     Reset_Handler
Undef_Addr:       .word     Undef_Handler
// SWI_Addr:         .word     SWI_Handler
// SWI_Wrapper_Addr: .word     SWI_Wrapper
SWI_Addr:         .word     0      /* in swi_handler.S */
PAbt_Addr:        .word     PAbt_Handler
DAbt_Addr:        .word     DAbt_Handler
                  .word     0                      /* Reserved Address */
// IRQ_Addr:         .word     __IRQ_Handler
IRQ_Wrapper_Addr: .word    __IRQ_Wrapper
FIQ_Addr:         .word     FIQ_Handler

Undef_Handler:  B       Undef_Handler
   10040:	eafffffe 	b	10040 <Undef_Handler>

00010044 <PAbt_Handler>:
/* SWI_Handler:    B       SWI_Handler */
PAbt_Handler:   B       PAbt_Handler
   10044:	eafffffe 	b	10044 <PAbt_Handler>

00010048 <DAbt_Handler>:
DAbt_Handler:   B       DAbt_Handler
   10048:	eafffffe 	b	10048 <DAbt_Handler>

0001004c <FIQ_Handler>:
/* IRQ_Handler:    B       IRQ_Handler */
FIQ_Handler:    B       FIQ_Handler
   1004c:	eafffffe 	b	1004c <FIQ_Handler>

00010050 <__IRQ_Wrapper>:

.size   __Vectors, . - __Vectors



.arm
.section .init, "ax"

.if (VECTREMAPPED)
/* mthomas: Dummy used during startup - mind the nops since the 
   flash-utility will overwrite the "reserved vector"-address
   with the checksum */
				B Reset_Handler
				NOP
				NOP
				NOP
				NOP
				NOP  /* Reserved Address */
				NOP
				NOP
.endif

.arm
.section .init, "ax"
.global __startup
.func __startup
__startup:

Reset_Handler:  


// Memory Mapping
                .set MEMMAP, 0xE01FC040  /* Memory Mapping Control */

.if (REMAP)
                LDR     R0, =MEMMAP
.if     (EXTMEM_MODE)                
                MOV     R1, #3
.elseif (RAM_MODE) || (VECTREMAPPED)
.print "MEMMAP to 2 on init"
                MOV     R1, #2
.else
                MOV     R1, #1
.endif
                STR     R1, [R0]
.endif

// Setup Stack for each mode
                LDR     R0, =Top_Stack

// Enter Undefined Instruction Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_UND|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #UND_Stack_Size

// Enter Abort Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_ABT|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #ABT_Stack_Size

// Enter FIQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_FIQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #FIQ_Stack_Size

// Enter IRQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_IRQ|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #IRQ_Stack_Size

// Enter Supervisor Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SVC|I_Bit|F_Bit
                MOV     SP, R0
                SUB     R0, R0, #SVC_Stack_Size

// Enter User Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SYS /* Interrupts enabled */
//				MSR     CPSR_c, #Mode_USR|I_Bit|F_Bit /* Interrupts disabled */
                MOV     SP, R0


.if (RAM_MODE==0)
/* Relocate .data section (Copy from ROM to RAM) */
                LDR     R1, =_etext 
                LDR     R2, =_data 
                LDR     R3, =_edata 
                CMP     R2, R3
                BEQ     DataIsEmpty
LoopRel:        CMP     R2, R3 
                LDRLO   R0, [R1], #4 
                STRLO   R0, [R2], #4 
                BLO     LoopRel 
DataIsEmpty:
.endif
 
/* Clear .bss section (Zero init) */
                MOV     R0, #0 
                LDR     R1, =__bss_start__ 
                LDR     R2, =__bss_end__ 
                CMP     R1,R2
                BEQ     BSSIsEmpty
LoopZI:         CMP     R1, R2 
                STRLO   R0, [R1], #4 
                BLO     LoopZI 
BSSIsEmpty:


// call C++ constructors of global objects
		LDR 	r0, =__ctors_start__
		LDR 	r1, =__ctors_end__
ctor_loop:
		CMP 	r0, r1
		BEQ 	ctor_end
		LDR 	r2, [r0], #4
		STMFD 	sp!, {r0-r1}
		MOV 	lr, pc
		MOV 	pc, r2
		LDMFD 	sp!, {r0-r1}
		B 		ctor_loop
ctor_end:

// Enter the C code
                //LDR     R0,=INIT
                LDR     R0,=main
                TST     R0,#1             // Bit-0 set: main is Thumb
                LDREQ   LR,=__exit_ARM    // ARM Mode
                LDRNE   LR,=__exit_THUMB  // Thumb Mode
                BX      R0

.size   __startup, . - __startup
.endfunc

.arm
.global __exit_ARM
.func __exit_ARM
__exit_ARM:
                B       __exit_ARM
.size   __exit_ARM, . - __exit_ARM
.endfunc

.thumb
.global __exit_THUMB
.func __exit_THUMB
__exit_THUMB:
                B       __exit_THUMB
.size   __exit_THUMB, . - __exit_THUMB
.endfunc


/* mthomas: the following code is inspired by various examples and
   documents from ARM, Atmel, Anglia Designs and others */


.text
.arm

.if (VECTREMAPPED)
.print "Handlers in section .vectmapped -> .data"
.section .vectmapped, "ax"
.else
.print "Handlers in section .vectorg -> .code/.text"
.section .vectorg, "ax"
.endif

.set VIC_base_addr, 0xFFFFF000
.set VIC_vect_offs, 0x30

        .arm
        .global __IRQ_Wrapper
        .func   __IRQ_Wrapper
__IRQ_Wrapper:
/*- Manage Exception Entry  */
/*- Adjust and save LR_irq in IRQ stack  */
            sub         lr, lr, #4
   10050:	e24ee004 	sub	lr, lr, #4	; 0x4
            stmfd       sp!, {lr}
   10054:	e92d4000 	stmdb	sp!, {lr}

/*- Save SPSR need to be saved for nested interrupt */
            mrs         r14, SPSR
   10058:	e14fe000 	mrs	lr, SPSR
            stmfd       sp!, {r14}
   1005c:	e92d4000 	stmdb	sp!, {lr}

/*- Save and r0 in IRQ stack  */
            stmfd       sp!, {r0}
   10060:	e92d0001 	stmdb	sp!, {r0}

/*- Write in the IVR to support Protect Mode  */
/*- No effect in Normal Mode  */
/*- De-assert the NIRQ and clear the source in Protect Mode */
/* R14 = LR */
            ldr         r14, =VIC_base_addr
   10064:	e59fe028 	ldr	lr, [pc, #40]	; 10094 <.text+0x94>
            ldr         r0 , [r14, #VIC_vect_offs]
   10068:	e59e0030 	ldr	r0, [lr, #48]
            /*str         r14, [r14, #VIC_vect_offs]*/

/*- Enable Interrupt and Switch in Supervisor Mode */
            msr         CPSR_c, #Mode_SVC
   1006c:	e321f013 	msr	CPSR_c, #19	; 0x13

/*- Save scratch/used registers and LR in User Stack */
            /*stmfd       sp!, { r1-r3, r12, r14}*/
            stmfd       sp!, { r1-r12, r14 }
   10070:	e92d5ffe 	stmdb	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Branch to the routine pointed by the VIC-Vector-Address  */
            mov         r14, pc
   10074:	e1a0e00f 	mov	lr, pc
            bx          r0
   10078:	e12fff10 	bx	r0
/*- Restore scratch/used registers and LR from User Stack*/
            /* ldmia       sp!, { r1-r3, r12, r14} */
            ldmia       sp!, { r1-r12, r14 }
   1007c:	e8bd5ffe 	ldmia	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}

/*- Disable Interrupt and switch back in IRQ mode */
            msr         CPSR_c, #I_Bit | Mode_IRQ
   10080:	e321f092 	msr	CPSR_c, #146	; 0x92

#if 0
/* VICVectAddr=0 is already done in the ISRs of the Philips-Examples 
   so commented out here */
/*- Mark the End of Interrupt on the VIC */
            ldr         r14, =VIC_base_addr
            str         r14, [r14, #VIC_vect_offs]
#endif

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r0}
   10084:	e8bd0001 	ldmia	sp!, {r0}

/*- Restore SPSR_irq and r0 from IRQ stack */
            ldmia       sp!, {r14}
   10088:	e8bd4000 	ldmia	sp!, {lr}
            msr         SPSR_cxsf, r14
   1008c:	e16ff00e 	msr	SPSR_fsxc, lr

/*- Restore adjusted  LR_irq from IRQ stack directly in the PC */
            ldmia       sp!, {pc}^
   10090:	e8fd8000 	ldmia	sp!, {pc}^
   10094:	fffff000 	undefined instruction 0xfffff000

00010098 <__startup>:
   10098:	e59f00c8 	ldr	r0, [pc, #200]	; 10168 <.text+0x168>
   1009c:	e321f0db 	msr	CPSR_c, #219	; 0xdb
   100a0:	e1a0d000 	mov	sp, r0
   100a4:	e2400080 	sub	r0, r0, #128	; 0x80
   100a8:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
   100ac:	e1a0d000 	mov	sp, r0
   100b0:	e2400080 	sub	r0, r0, #128	; 0x80
   100b4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
   100b8:	e1a0d000 	mov	sp, r0
   100bc:	e2400080 	sub	r0, r0, #128	; 0x80
   100c0:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
   100c4:	e1a0d000 	mov	sp, r0
   100c8:	e2400c02 	sub	r0, r0, #512	; 0x200
   100cc:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
   100d0:	e1a0d000 	mov	sp, r0
   100d4:	e2400080 	sub	r0, r0, #128	; 0x80
   100d8:	e321f01f 	msr	CPSR_c, #31	; 0x1f
   100dc:	e1a0d000 	mov	sp, r0
   100e0:	e59f1084 	ldr	r1, [pc, #132]	; 1016c <.text+0x16c>
   100e4:	e59f2084 	ldr	r2, [pc, #132]	; 10170 <.text+0x170>
   100e8:	e59f3084 	ldr	r3, [pc, #132]	; 10174 <.text+0x174>
   100ec:	e1520003 	cmp	r2, r3
   100f0:	0a000003 	beq	10104 <DataIsEmpty>

000100f4 <LoopRel>:
   100f4:	e1520003 	cmp	r2, r3
   100f8:	34910004 	ldrcc	r0, [r1], #4
   100fc:	34820004 	strcc	r0, [r2], #4
   10100:	3afffffb 	bcc	100f4 <LoopRel>

00010104 <DataIsEmpty>:
   10104:	e3a00000 	mov	r0, #0	; 0x0
   10108:	e59f1068 	ldr	r1, [pc, #104]	; 10178 <.text+0x178>
   1010c:	e59f2068 	ldr	r2, [pc, #104]	; 1017c <.text+0x17c>
   10110:	e1510002 	cmp	r1, r2
   10114:	0a000002 	beq	10124 <BSSIsEmpty>

00010118 <LoopZI>:
   10118:	e1510002 	cmp	r1, r2
   1011c:	34810004 	strcc	r0, [r1], #4
   10120:	3afffffc 	bcc	10118 <LoopZI>

00010124 <BSSIsEmpty>:
   10124:	e59f0054 	ldr	r0, [pc, #84]	; 10180 <.text+0x180>
   10128:	e59f1054 	ldr	r1, [pc, #84]	; 10184 <.text+0x184>

0001012c <ctor_loop>:
   1012c:	e1500001 	cmp	r0, r1
   10130:	0a000005 	beq	1014c <ctor_end>
   10134:	e4902004 	ldr	r2, [r0], #4
   10138:	e92d0003 	stmdb	sp!, {r0, r1}
   1013c:	e1a0e00f 	mov	lr, pc
   10140:	e1a0f002 	mov	pc, r2
   10144:	e8bd0003 	ldmia	sp!, {r0, r1}
   10148:	eafffff7 	b	1012c <ctor_loop>

0001014c <ctor_end>:
   1014c:	e59f0034 	ldr	r0, [pc, #52]	; 10188 <.text+0x188>
   10150:	e3100001 	tst	r0, #1	; 0x1
   10154:	059fe030 	ldreq	lr, [pc, #48]	; 1018c <.text+0x18c>
   10158:	159fe030 	ldrne	lr, [pc, #48]	; 10190 <.text+0x190>
   1015c:	e12fff10 	bx	r0

00010160 <__exit_ARM>:
   10160:	eafffffe 	b	10160 <__exit_ARM>

00010164 <__exit_THUMB>:
   10164:	e7fe      	b.n	10164 <__exit_THUMB>
   10166:	0000      	lsls	r0, r0, #0
   10168:	2000      	movs	r0, #0
   1016a:	4000      	ands	r0, r0
   1016c:	8698      	strh	r0, [r3, #52]
   1016e:	0001      	lsls	r1, r0, #0
   10170:	0000      	lsls	r0, r0, #0
   10172:	4000      	ands	r0, r0
   10174:	08a4      	lsrs	r4, r4, #2
   10176:	4000      	ands	r0, r0
   10178:	08a4      	lsrs	r4, r4, #2
   1017a:	4000      	ands	r0, r0
   1017c:	1318      	asrs	r0, r3, #12
   1017e:	4000      	ands	r0, r0
   10180:	8698      	strh	r0, [r3, #52]
   10182:	0001      	lsls	r1, r0, #0
   10184:	8698      	strh	r0, [r3, #52]
   10186:	0001      	lsls	r1, r0, #0
   10188:	1f08      	subs	r0, r1, #4
   1018a:	0001      	lsls	r1, r0, #0
   1018c:	0160      	lsls	r0, r4, #5
   1018e:	0001      	lsls	r1, r0, #0
   10190:	0164      	lsls	r4, r4, #5
   10192:	0001      	lsls	r1, r0, #0

00010194 <init_VIC>:
    DWORD i = 0;
    DWORD *vect_addr, *vect_cntl;

    /* initialize VIC*/
    VICIntEnClr = 0xffffffff;
   10194:	e3e03000 	mvn	r3, #0	; 0x0
    VICVectAddr = 0;
   10198:	e3a02000 	mov	r2, #0	; 0x0
   1019c:	e5033feb 	str	r3, [r3, #-4075]
   101a0:	e5032fcf 	str	r2, [r3, #-4047]
    VICIntSelect = 0;
   101a4:	e5032ff3 	str	r2, [r3, #-4083]
   101a8:	e2422c0f 	sub	r2, r2, #3840	; 0xf00

    /* set all the vector and vector control register to 0 */
    for ( i = 0; i < VIC_SIZE; i++ )
    {
        vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
        vect_cntl = (DWORD *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + i*4);
        *vect_addr = 0;
   101ac:	e3a03000 	mov	r3, #0	; 0x0
        *vect_cntl = 0;
   101b0:	e5823100 	str	r3, [r2, #256]
   101b4:	e5823000 	str	r3, [r2]
   101b8:	e2822004 	add	r2, r2, #4	; 0x4
   101bc:	e3720d3b 	cmn	r2, #3776	; 0xec0
   101c0:	1afffff9 	bne	101ac <init_VIC+0x18>
    }

    /* Install the default VIC handler here */
    VICDefVectAddr = (DWORD)DefaultVICHandler;
   101c4:	e59f2008 	ldr	r2, [pc, #8]	; 101d4 <.text+0x1d4>
   101c8:	e3e03000 	mvn	r3, #0	; 0x0
   101cc:	e5032fcb 	str	r2, [r3, #-4043]
    return;
}
   101d0:	e12fff1e 	bx	lr
   101d4:	0001029c 	muleq	r1, ip, r2

000101d8 <install_irq>:

/******************************************************************************
** Function name:       install_irq
**
** Descriptions:        Install interrupt handler
**              The max VIC size is 16, but, there are 32 interrupt
**              request inputs. Not all of them can be installed into
**              VIC table at the same time.
**              The order of the interrupt request installation is
**              first come first serve.
** parameters:          Interrupt number and interrupt handler address
** Returned value:      true or false, when the table is full, return false
**
******************************************************************************/
DWORD install_irq( DWORD IntNumber, void *HandlerAddr )
{
    DWORD i;
    DWORD *vect_addr;
    DWORD *vect_cntl;

    VICIntEnClr = 1 << IntNumber;   /* Disable Interrupt */
   101d8:	e3a03001 	mov	r3, #1	; 0x1
   101dc:	e52de004 	str	lr, [sp, #-4]!
   101e0:	e1a0e013 	mov	lr, r3, lsl r0
   101e4:	e3e03000 	mvn	r3, #0	; 0x0
   101e8:	e503efeb 	str	lr, [r3, #-4075]
   101ec:	e59fc044 	ldr	ip, [pc, #68]	; 10238 <.text+0x238>
   101f0:	e3a02000 	mov	r2, #0	; 0x0

    for ( i = 0; i < VIC_SIZE; i++ )
    {
        /* find first un-assigned VIC address for the handler */

        vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
        vect_cntl = (DWORD *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + i*4);
        if ( *vect_addr == (DWORD)NULL )
   101f4:	e51c3100 	ldr	r3, [ip, #-256]
   101f8:	e3530000 	cmp	r3, #0	; 0x0
   101fc:	e2822001 	add	r2, r2, #1	; 0x1
   10200:	0a000004 	beq	10218 <install_irq+0x40>
   10204:	e3520010 	cmp	r2, #16	; 0x10
   10208:	e28cc004 	add	ip, ip, #4	; 0x4
   1020c:	1afffff8 	bne	101f4 <install_irq+0x1c>
        {
            *vect_addr = (DWORD)HandlerAddr;    /* set interrupt vector */
            *vect_cntl = (DWORD)(IRQ_SLOT_EN | IntNumber);
            break;
        }
    }
    if ( i == VIC_SIZE )
   10210:	e3a00000 	mov	r0, #0	; 0x0
   10214:	ea000005 	b	10230 <install_irq+0x58>
   10218:	e3803020 	orr	r3, r0, #32	; 0x20
   1021c:	e58c3000 	str	r3, [ip]
    {
        return( FALSE );        /* fatal error, can't find empty vector slot */
    }
    VICIntEnable = 1 << IntNumber;  /* Enable Interrupt */
   10220:	e3e03000 	mvn	r3, #0	; 0x0
   10224:	e50c1100 	str	r1, [ip, #-256]
   10228:	e503efef 	str	lr, [r3, #-4079]
   1022c:	e3a00001 	mov	r0, #1	; 0x1
    return( TRUE );
}
   10230:	e49de004 	ldr	lr, [sp], #4
   10234:	e12fff1e 	bx	lr
   10238:	fffff200 	undefined instruction 0xfffff200

0001023c <uninstall_irq>:

/******************************************************************************
** Function name:       uninstall_irq
**
** Descriptions:        Uninstall interrupt handler
**              Find the interrupt handler installed in the VIC
**              based on the interrupt number, set the location
**              back to NULL to uninstall it.
** parameters:          Interrupt number
** Returned value:      true or false, when the interrupt number is not found,
**              return false
**
******************************************************************************/
DWORD uninstall_irq( DWORD IntNumber )
{
    DWORD i;
    DWORD *vect_addr;
    DWORD *vect_cntl;

    VICIntEnClr = 1 << IntNumber;   /* Disable Interrupt */
   1023c:	e3a03001 	mov	r3, #1	; 0x1
   10240:	e1a0c013 	mov	ip, r3, lsl r0
   10244:	e3e03000 	mvn	r3, #0	; 0x0
   10248:	e503cfeb 	str	ip, [r3, #-4075]
   1024c:	e59f2044 	ldr	r2, [pc, #68]	; 10298 <.text+0x298>
   10250:	e3a01000 	mov	r1, #0	; 0x0

    for ( i = 0; i < VIC_SIZE; i++ )
    {
        /* find first un-assigned VIC address for the handler */
        vect_addr = (DWORD *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + i*4);
        vect_cntl = (DWORD *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + i*4);
        if ( (*vect_cntl & ~IRQ_SLOT_EN ) == IntNumber )
   10254:	e5923000 	ldr	r3, [r2]
   10258:	e3c33020 	bic	r3, r3, #32	; 0x20
   1025c:	e1530000 	cmp	r3, r0
   10260:	e2811001 	add	r1, r1, #1	; 0x1
   10264:	0a000004 	beq	1027c <uninstall_irq+0x40>
   10268:	e3510010 	cmp	r1, #16	; 0x10
   1026c:	e2822004 	add	r2, r2, #4	; 0x4
   10270:	1afffff7 	bne	10254 <uninstall_irq+0x18>
        {
            *vect_addr = (DWORD)NULL;   /* clear the VIC entry in the VIC table */
            *vect_cntl &= ~IRQ_SLOT_EN; /* disable SLOT_EN bit */
            break;
        }
    }
    if ( i == VIC_SIZE )
   10274:	e3a00000 	mov	r0, #0	; 0x0
   10278:	e12fff1e 	bx	lr
   1027c:	e5823000 	str	r3, [r2]
   10280:	e3a03000 	mov	r3, #0	; 0x0
   10284:	e5023100 	str	r3, [r2, #-256]
    {
        return( FALSE );        /* fatal error, can't find interrupt number
                            in vector slot */
    }
    VICIntEnable = 1 << IntNumber;  /* Enable Interrupt */
   10288:	e3a00001 	mov	r0, #1	; 0x1
   1028c:	e3e03000 	mvn	r3, #0	; 0x0
   10290:	e503cfef 	str	ip, [r3, #-4079]
    return( TRUE );
}
   10294:	e12fff1e 	bx	lr
   10298:	fffff200 	undefined instruction 0xfffff200

0001029c <DefaultVICHandler>:
   1029c:	e24ee004 	sub	lr, lr, #4	; 0x4
   102a0:	e92d500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
   102a4:	e3a02000 	mov	r2, #0	; 0x0
   102a8:	e3e03000 	mvn	r3, #0	; 0x0
   102ac:	e59f0008 	ldr	r0, [pc, #8]	; 102bc <.text+0x2bc>
   102b0:	e5032fcf 	str	r2, [r3, #-4047]
   102b4:	eb0007a0 	bl	1213c <rprintf>
   102b8:	eafffffe 	b	102b8 <DefaultVICHandler+0x1c>
   102bc:	00017ee8 	andeq	r7, r1, r8, ror #29

000102c0 <feed>:
}

void feed(void)
{
	PLLFEED=0xAA;
   102c0:	e59f3010 	ldr	r3, [pc, #16]	; 102d8 <.text+0x2d8>
   102c4:	e3e02055 	mvn	r2, #85	; 0x55
   102c8:	e5c3208c 	strb	r2, [r3, #140]
	PLLFEED=0x55;
   102cc:	e28220ab 	add	r2, r2, #171	; 0xab
   102d0:	e5c3208c 	strb	r2, [r3, #140]
}
   102d4:	e12fff1e 	bx	lr
   102d8:	e01fc000 	ands	ip, pc, r0

000102dc <UART0ISR>:

static void UART0ISR(void)
{
	char temp;


	if(RX_in < 512)
   102dc:	e59fc090 	ldr	ip, [pc, #144]	; 10374 <.text+0x374>
   102e0:	e1dc30b0 	ldrh	r3, [ip]
   102e4:	e1dc10f0 	ldrsh	r1, [ip]
	{
		RX_array1[RX_in] = U0RBR;
	
		RX_in++;

		if(RX_in == 512) log_array1 = 1;
	}
	else if(RX_in >= 512)
	{
		RX_array2[RX_in-512] = U0RBR;
   102e8:	e59f2088 	ldr	r2, [pc, #136]	; 10378 <.text+0x378>
   102ec:	e2833001 	add	r3, r3, #1	; 0x1
   102f0:	e52de004 	str	lr, [sp, #-4]!
   102f4:	e3510c02 	cmp	r1, #512	; 0x200
   102f8:	e081e002 	add	lr, r1, r2
   102fc:	e1a02803 	mov	r2, r3, lsl #16
   10300:	e1a00822 	mov	r0, r2, lsr #16
   10304:	aa000009 	bge	10330 <UART0ISR+0x54>
   10308:	e59f306c 	ldr	r3, [pc, #108]	; 1037c <.text+0x37c>
   1030c:	e5d32000 	ldrb	r2, [r3]
   10310:	e59f3068 	ldr	r3, [pc, #104]	; 10380 <.text+0x380>
   10314:	e3500c02 	cmp	r0, #512	; 0x200
   10318:	e7c32001 	strb	r2, [r3, r1]
   1031c:	e1cc00b0 	strh	r0, [ip]
   10320:	059f305c 	ldreq	r3, [pc, #92]	; 10384 <.text+0x384>
   10324:	03a02001 	moveq	r2, #1	; 0x1
   10328:	05c32000 	streqb	r2, [r3]
   1032c:	ea000009 	b	10358 <UART0ISR+0x7c>
   10330:	e59f3044 	ldr	r3, [pc, #68]	; 1037c <.text+0x37c>
   10334:	e5d33000 	ldrb	r3, [r3]
		RX_in++;

		if(RX_in == 1024)
   10338:	e3500b01 	cmp	r0, #1024	; 0x400
   1033c:	e54e3200 	strb	r3, [lr, #-512]
		{
			log_array2 = 1;
   10340:	059f3040 	ldreq	r3, [pc, #64]	; 10388 <.text+0x388>
   10344:	03a02001 	moveq	r2, #1	; 0x1
   10348:	05c32000 	streqb	r2, [r3]
			RX_in = 0;
   1034c:	03a03000 	moveq	r3, #0	; 0x0
   10350:	e1cc00b0 	strh	r0, [ip]
   10354:	01cc30b0 	streqh	r3, [ip]
		}
	}


	temp = U0IIR; // Have to read this to clear the interrupt 
   10358:	e59f301c 	ldr	r3, [pc, #28]	; 1037c <.text+0x37c>

	VICVectAddr = 0;
   1035c:	e3a02000 	mov	r2, #0	; 0x0
   10360:	e5d33008 	ldrb	r3, [r3, #8]
   10364:	e3e03000 	mvn	r3, #0	; 0x0
   10368:	e5032fcf 	str	r2, [r3, #-4047]
	
}
   1036c:	e49de004 	ldr	lr, [sp], #4
   10370:	e12fff1e 	bx	lr
   10374:	400008a6 	andmi	r0, r0, r6, lsr #17
   10378:	40000dd0 	ldrmid	r0, [r0], -r0
   1037c:	e000c000 	and	ip, r0, r0
   10380:	400010d0 	ldrmid	r1, [r0], -r0
   10384:	400008a4 	andmi	r0, r0, r4, lsr #17
   10388:	400008a5 	andmi	r0, r0, r5, lsr #17

0001038c <UART0ISR_2>:

static void UART0ISR_2(void)
{
   1038c:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	char temp;
	temp = U0RBR;
   10390:	e59f3110 	ldr	r3, [pc, #272]	; 104a8 <.text+0x4a8>
   10394:	e5d32000 	ldrb	r2, [r3]

	if(temp == trig){ get_frame = 1; }
   10398:	e59f310c 	ldr	r3, [pc, #268]	; 104ac <.text+0x4ac>
   1039c:	e5d33000 	ldrb	r3, [r3]
   103a0:	e20240ff 	and	r4, r2, #255	; 0xff
   103a4:	e1530004 	cmp	r3, r4
   103a8:	e59f2100 	ldr	r2, [pc, #256]	; 104b0 <.text+0x4b0>
   103ac:	03a03001 	moveq	r3, #1	; 0x1
   103b0:	05c23000 	streqb	r3, [r2]
   103b4:	0a000002 	beq	103c4 <UART0ISR_2+0x38>
	
	if(get_frame)
   103b8:	e5d23000 	ldrb	r3, [r2]
   103bc:	e3530000 	cmp	r3, #0	; 0x0
   103c0:	0a000031 	beq	1048c <UART0ISR_2+0x100>
	{
		if(RX_in < frame)
   103c4:	e59f70e8 	ldr	r7, [pc, #232]	; 104b4 <.text+0x4b4>
   103c8:	e59f30e8 	ldr	r3, [pc, #232]	; 104b8 <.text+0x4b8>
   103cc:	e1d310f0 	ldrsh	r1, [r3]
   103d0:	e1d730b0 	ldrh	r3, [r7]
   103d4:	e2833001 	add	r3, r3, #1	; 0x1
   103d8:	e1d700f0 	ldrsh	r0, [r7]
		{
			RX_array1[RX_in] = temp;
			RX_in++;

			if(RX_in == frame)
			{
				RX_array1[RX_in] = 10; // delimiters
				RX_array1[RX_in + 1] = 13;
				log_array1 = 1;
				get_frame = 0;
			}
		}
		else if(RX_in >= frame)
		{
			RX_array2[RX_in - frame] = temp;
			RX_in++;
   103dc:	e1a02803 	mov	r2, r3, lsl #16
   103e0:	e1a02822 	mov	r2, r2, lsr #16

			if(RX_in == 2*frame)
   103e4:	e1a03802 	mov	r3, r2, lsl #16
   103e8:	e1500001 	cmp	r0, r1
   103ec:	e1a0c003 	mov	ip, r3
   103f0:	e59f50c4 	ldr	r5, [pc, #196]	; 104bc <.text+0x4bc>
   103f4:	e59f60c4 	ldr	r6, [pc, #196]	; 104c0 <.text+0x4c0>
   103f8:	e0618000 	rsb	r8, r1, r0
   103fc:	e1a0e002 	mov	lr, r2
   10400:	e1a03843 	mov	r3, r3, asr #16
   10404:	aa00000f 	bge	10448 <UART0ISR_2+0xbc>
   10408:	e151084c 	cmp	r1, ip, asr #16
   1040c:	e7c54000 	strb	r4, [r5, r0]
   10410:	e081c005 	add	ip, r1, r5
   10414:	e1c720b0 	strh	r2, [r7]
   10418:	1a00001b 	bne	1048c <UART0ISR_2+0x100>
   1041c:	e59f30a0 	ldr	r3, [pc, #160]	; 104c4 <.text+0x4c4>
   10420:	e3a02001 	mov	r2, #1	; 0x1
   10424:	e5c32000 	strb	r2, [r3]
   10428:	e59f3080 	ldr	r3, [pc, #128]	; 104b0 <.text+0x4b0>
   1042c:	e3a02000 	mov	r2, #0	; 0x0
   10430:	e5c32000 	strb	r2, [r3]
   10434:	e3a0300a 	mov	r3, #10	; 0xa
   10438:	e7c53001 	strb	r3, [r5, r1]
   1043c:	e2833003 	add	r3, r3, #3	; 0x3
   10440:	e5cc3001 	strb	r3, [ip, #1]
   10444:	ea000010 	b	1048c <UART0ISR_2+0x100>
			{
				RX_array2[RX_in - frame] = 10; // delimiters
   10448:	e0610003 	rsb	r0, r1, r3
   1044c:	e1530081 	cmp	r3, r1, lsl #1
				RX_array2[RX_in + 1 - frame] = 13;
   10450:	e080c006 	add	ip, r0, r6
				log_array2 = 1;
				get_frame = 0;
   10454:	e3a01000 	mov	r1, #0	; 0x0
   10458:	e7c64008 	strb	r4, [r6, r8]
   1045c:	e1c720b0 	strh	r2, [r7]
   10460:	1a000009 	bne	1048c <UART0ISR_2+0x100>
   10464:	e59f305c 	ldr	r3, [pc, #92]	; 104c8 <.text+0x4c8>
   10468:	e3a02001 	mov	r2, #1	; 0x1
   1046c:	e5c32000 	strb	r2, [r3]
   10470:	e3a0300a 	mov	r3, #10	; 0xa
   10474:	e7c63000 	strb	r3, [r6, r0]
   10478:	e2833003 	add	r3, r3, #3	; 0x3
   1047c:	e5cc3001 	strb	r3, [ip, #1]
   10480:	e59f3028 	ldr	r3, [pc, #40]	; 104b0 <.text+0x4b0>
				RX_in = 0;
   10484:	e1c710b0 	strh	r1, [r7]
   10488:	e5c31000 	strb	r1, [r3]
			}
		}
	}

	temp = U0IIR; // have to read this to clear the interrupt
   1048c:	e59f3014 	ldr	r3, [pc, #20]	; 104a8 <.text+0x4a8>

	VICVectAddr = 0;
   10490:	e3a02000 	mov	r2, #0	; 0x0
   10494:	e5d33008 	ldrb	r3, [r3, #8]
   10498:	e3e03000 	mvn	r3, #0	; 0x0
   1049c:	e5032fcf 	str	r2, [r3, #-4047]
}
   104a0:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   104a4:	e12fff1e 	bx	lr
   104a8:	e000c000 	and	ip, r0, r0
   104ac:	40000016 	andmi	r0, r0, r6, lsl r0
   104b0:	400008a8 	andmi	r0, r0, r8, lsr #17
   104b4:	400008a6 	andmi	r0, r0, r6, lsr #17
   104b8:	40000014 	andmi	r0, r0, r4, lsl r0
   104bc:	400010d0 	ldrmid	r1, [r0], -r0
   104c0:	40000dd0 	ldrmid	r0, [r0], -r0
   104c4:	400008a4 	andmi	r0, r0, r4, lsr #17
   104c8:	400008a5 	andmi	r0, r0, r5, lsr #17

000104cc <SWI_Routine>:
		
static void MODE2ISR(void)
{
	int temp = 0, temp2 = 0, ind = 0;
	int j;
	short a;
	char q[50], temp_buff[4];


	T0IR = 1; // reset TMR0 interrupt
	
	for(j = 0; j < 50; j++)
	{
		q[j] = 0;
	}


	// Get AD1.3
	if(ad1_3 == 'Y')
	{
		AD1CR = 0x00020FF08; // AD1.3
		AD1CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD1DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD1CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	// Get AD0.3
	if(ad0_3 == 'Y')
	{
		AD0CR = 0x00020FF08; // AD0.3
		AD0CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD0DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD0CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	// Get AD0.2
	if(ad0_2 == 'Y')
	{
		AD0CR = 0x00020FF04; // AD1.2
		AD0CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD0DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD0CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	// Get AD0.1
	if(ad0_1 == 'Y')
	{
		AD0CR = 0x00020FF02; // AD0.1
		AD0CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD0DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD0CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	// Get AD1.2
	if(ad1_2 == 'Y')
	{
		AD1CR = 0x00020FF04; // AD1.2
		AD1CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD1DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD1CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	// Get AD0.4
	if(ad0_4 == 'Y')
	{
		AD0CR = 0x00020FF10; // AD0.4
		AD0CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD0DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD0CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	// Get AD1.7
	if(ad1_7 == 'Y')
	{
		AD1CR = 0x00020FF80; // AD1.7
		AD1CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD1DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD1CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	// Get AD1.6
	if(ad1_6 == 'Y')
	{
		AD1CR = 0x00020FF40; // AD1.3
		AD1CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD1DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD1CR = 0x00000000;

		if(asc == 'Y')
		{
			itoa(temp2, 10, temp_buff);
			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
			{
				q[ind] = temp_buff[0];
				ind++;
			}
			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
			{
				q[ind] = temp_buff[1];
				ind++;
			}
			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
			{
				q[ind] = temp_buff[2];
				ind++;
			}
			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
			{
				q[ind] = temp_buff[3];
				ind++;
			}

			q[ind] = 0;
			ind++;
			temp = 0; 
			temp2 = 0;
			temp_buff[0] = 0;
			temp_buff[1] = 0;
			temp_buff[2] = 0;
			temp_buff[3] = 0;

		}

		else if(asc == 'N')
		{
			a = ((short)temp2 & 0xFF00) / 0x00000100;
			q[ind] = (char)a;
			
			q[ind+1]  = (char)temp2 & 0xFF;
			ind += 2;
			temp = 0;
		}
	}
	
	for(j = 0; j < ind; j++)
	{
		if(RX_in < 512)
		{
			RX_array1[RX_in] = q[j];
			RX_in++;

			if(RX_in == 512) log_array1 = 1;
		}
		else if(RX_in >= 512)
		{
			RX_array2[RX_in - 512] = q[j];
			RX_in++;

			if(RX_in == 1024)
			{
				log_array2 = 1;
				RX_in = 0;
			}
		}
	}
	if(RX_in < 512)
	{
		if(asc == 'N') { RX_array1[RX_in] = '$'; }
		else if(asc == 'Y'){ RX_array1[RX_in] = 13; }
		RX_in++;

		if(RX_in == 512) log_array1 = 1;
	}
	else if(RX_in >= 512)
	{
		
		if(asc == 'N') RX_array2[RX_in - 512] = '$';
		else if(asc == 'Y'){ RX_array2[RX_in - 512] = 13; }
		RX_in++;
		
		if(RX_in == 1024)
		{
			log_array2 = 1;
			RX_in = 0;
		}
	}
	if(RX_in < 512)
	{
		if(asc == 'N') RX_array1[RX_in] = '$';
		else if(asc == 'Y'){ RX_array1[RX_in] = 10; }
		RX_in++;

		if(RX_in == 512) log_array1 = 1;
	}
	else if(RX_in >= 512)
	{
		
		if(asc == 'N') RX_array2[RX_in - 512] = '$';
		else if(asc == 'Y'){ RX_array2[RX_in - 512] = 10; }
		RX_in++;
		
		if(RX_in == 1024)
		{
			log_array2 = 1;
			RX_in = 0;
		}
	}

	VICVectAddr= 0;
}

void FIQ_Routine(void)
{
	char a;
	int j;

	stat(0,ON);
	for(j = 0; j < 5000000; j++);
	stat(0,OFF);
	a = U0RBR;

	a = U0IIR;  // have to read this to clear the interrupt
}

void SWI_Routine(void)
{
   104cc:	eafffffe 	b	104cc <SWI_Routine>

000104d0 <stat>:
	while(1);
}

void UNDEF_Routine(void)
{
	stat(0,ON);
}

void setup_uart0(int newbaud, char want_ints)
{
	baud = newbaud;
	U0LCR = 0x83;   // 8 bits, no parity, 1 stop bit, DLAB = 1
	
	if(baud == 1200)
	{
		U0DLM = 0x0C;
		U0DLL = 0x00;
	}
	else if(baud == 2400)
	{
		U0DLM = 0x06;
		U0DLL = 0x00;
	}
	else if(baud == 4800)
	{
		U0DLM = 0x03;
		U0DLL = 0x00;
	}
	else if(baud == 9600)
	{
		U0DLM = 0x01;
		U0DLL = 0x80;
	}
	else if(baud == 19200)
	{
		U0DLM = 0x00;
		U0DLL = 0xC0;
	}
	else if(baud == 38400)
	{
		U0DLM = 0x00;
		U0DLL = 0x60;
	}
	else if(baud == 57600)
	{
		U0DLM = 0x00;
		U0DLL = 0x40;
	}
	else if(baud == 115200)
	{
		U0DLM = 0x00;
		U0DLL = 0x20;
	}

	U0FCR = 0x01;
	U0LCR = 0x03;   

	if(want_ints == 1)
	{
		enableIRQ();
		VICIntSelect &= ~0x00000040;
		VICIntEnable |= 0x00000040;
		VICVectCntl1 = 0x26;
		VICVectAddr1 = (unsigned int)UART0ISR;
		U0IER = 0x01;
	}
	else if(want_ints == 2)
	{
		enableIRQ();
		VICIntSelect &= ~0x00000040;
		VICIntEnable |= 0x00000040;
		VICVectCntl2 = 0x26;
		VICVectAddr2 = (unsigned int)UART0ISR_2;
		U0IER = 0X01;
	}
	else if(want_ints == 0)
	{
		VICIntEnClr = 0x00000040;
		U0IER = 0x00;
	}
}
void stat(int statnum, int onoff)
{
	if(statnum) // Stat 1
   104d0:	e3500000 	cmp	r0, #0	; 0x0
   104d4:	0a000004 	beq	104ec <stat+0x1c>
	{
		if(onoff){ IOCLR0 = 0x00000800; } // On
   104d8:	e3510000 	cmp	r1, #0	; 0x0
   104dc:	13a02b02 	movne	r2, #2048	; 0x800
		else { IOSET0 = 0x00000800; } // Off
   104e0:	03a02b02 	moveq	r2, #2048	; 0x800
   104e4:	0a000007 	beq	10508 <stat+0x38>
   104e8:	ea000003 	b	104fc <stat+0x2c>
	}
	else // Stat 0 
	{
		if(onoff){ IOCLR0 = 0x00000004; } // On
   104ec:	e3510000 	cmp	r1, #0	; 0x0
		else { IOSET0 = 0x00000004; } // Off
   104f0:	03a02004 	moveq	r2, #4	; 0x4
   104f4:	0a000003 	beq	10508 <stat+0x38>
   104f8:	e3a02004 	mov	r2, #4	; 0x4
   104fc:	e59f3010 	ldr	r3, [pc, #16]	; 10514 <.text+0x514>
   10500:	e583200c 	str	r2, [r3, #12]
   10504:	e12fff1e 	bx	lr
   10508:	e59f3004 	ldr	r3, [pc, #4]	; 10514 <.text+0x514>
   1050c:	e5832004 	str	r2, [r3, #4]
   10510:	e12fff1e 	bx	lr
   10514:	e0028000 	and	r8, r2, r0

00010518 <UNDEF_Routine>:
   10518:	e92d500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
   1051c:	e3a00000 	mov	r0, #0	; 0x0
   10520:	e3a01001 	mov	r1, #1	; 0x1
   10524:	ebffffe9 	bl	104d0 <stat>
   10528:	e8bd500f 	ldmia	sp!, {r0, r1, r2, r3, ip, lr}
   1052c:	e1b0f00e 	movs	pc, lr

00010530 <FIQ_Routine>:
   10530:	e24ee004 	sub	lr, lr, #4	; 0x4
   10534:	e92d400f 	stmdb	sp!, {r0, r1, r2, r3, lr}
   10538:	e3a00000 	mov	r0, #0	; 0x0
   1053c:	e3a01001 	mov	r1, #1	; 0x1
   10540:	ebffffe2 	bl	104d0 <stat>
   10544:	e3a00000 	mov	r0, #0	; 0x0
   10548:	e1a01000 	mov	r1, r0
   1054c:	ebffffdf 	bl	104d0 <stat>
   10550:	e59f300c 	ldr	r3, [pc, #12]	; 10564 <.text+0x564>
   10554:	e5d32000 	ldrb	r2, [r3]
   10558:	e5d33008 	ldrb	r3, [r3, #8]
   1055c:	e8bd400f 	ldmia	sp!, {r0, r1, r2, r3, lr}
   10560:	e25ef004 	subs	pc, lr, #4	; 0x4
   10564:	e000c000 	and	ip, r0, r0

00010568 <delay_ms>:
	}
}

void Log_init(void)
{
	int x, mark = 0, ind = 0;
	char temp, temp2 = 0, safety = 0;
//	signed char handle;

	if(root_file_exists("LOGCON.txt"))
	{
		//rprintf("\n\rFound LOGcon.txt\n");
		fd = root_open("LOGCON.txt");
		stringSize = fat16_read_file(fd, (unsigned char *)stringBuf, 512);
		stringBuf[stringSize] = '\0';
		fat16_close_file(fd);
	}
	else
	{
		//rprintf("Couldn't find LOGcon.txt, creating...\n");
		fd = root_open_new("LOGCON.txt");
		if(fd == NULL)
		{
		 	rprintf("Error creating LOGCON.txt, locking up...\n\r");
		 	while(1)
			{
				stat(0,ON);
				delay_ms(50);
				stat(0,OFF);
				stat(1,ON);
				delay_ms(50);
				stat(1,OFF);
			}
		}

		strcpy(stringBuf, "MODE = 0\r\nASCII = N\r\nBaud = 4\r\nFrequency = 100\r\nTrigger Character = $\r\nText Frame = 100\r\nAD1.3 = N\r\nAD0.3 = N\r\nAD0.2 = N\r\nAD0.1 = N\r\nAD1.2 = N\r\nAD0.4 = N\r\nAD1.7 = N\r\nAD1.6 = N\r\nSaftey On = Y\r\n");
		stringSize = strlen(stringBuf);
		fat16_write_file(fd, (unsigned char*)stringBuf, stringSize);
		sd_raw_sync();
	}

	for(x = 0; x < stringSize; x++)
	{
		temp = stringBuf[x];
		if(temp == 10)
		{
			mark = x;
			ind++;
			if(ind == 1)
			{
				mode = stringBuf[mark-2]-48; // 0 = auto uart, 1 = trigger uart, 2 = adc
				rprintf("mode = %d\n\r",mode);
			}
			else if(ind == 2)
			{
				asc = stringBuf[mark-2]; // default is 'N'
				rprintf("asc = %c\n\r",asc);
			}
			else if(ind == 3)
			{
				if(stringBuf[mark-2] == '1'){ baud = 1200; }
				else if(stringBuf[mark-2] == '2'){ baud = 2400; }
				else if(stringBuf[mark-2] == '3'){ baud = 4800; }
				else if(stringBuf[mark-2] == '4'){ baud = 9600; }
				else if(stringBuf[mark-2] == '5'){ baud = 19200; }
				else if(stringBuf[mark-2] == '6'){ baud = 38400; }
				else if(stringBuf[mark-2] == '7'){ baud = 57600; }
				else if(stringBuf[mark-2] == '8'){ baud = 115200; }

				rprintf("baud = %d\n\r",baud);
			}
			else if(ind == 4)
			{
				freq = (stringBuf[mark-2]-48) + (stringBuf[mark-3]-48) * 10;
				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
				{
					freq+= (stringBuf[mark-4]-48) * 100;
					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000; }
				}
				rprintf("freq = %d\n\r",freq);
			}
			else if(ind == 5)
			{
				trig = stringBuf[mark-2]; // default is $
				
				rprintf("trig = %c\n\r",trig);
			}
			else if(ind == 6)
			{
				frame = (stringBuf[mark-2]-48) + (stringBuf[mark-3]-48) * 10 + (stringBuf[mark-4]-48)*100;
				if(frame > 510){ frame = 510; } // up to 510 characters
				rprintf("frame = %d\n\r",frame);
			}
			else if(ind == 7)
			{
				ad1_3 = stringBuf[mark-2]; // default is 'N'
				if(ad1_3 == 'Y'){ temp2++; }
				rprintf("ad1_3 = %c\n\r",ad1_3);
			}
			else if(ind == 8)
			{
				ad0_3 = stringBuf[mark-2]; // default is 'N'
				if(ad0_3 == 'Y'){ temp2++; }
				rprintf("ad0_3 = %c\n\r",ad0_3);
			}
			else if(ind == 9)
			{
				ad0_2 = stringBuf[mark-2]; // default is 'N'
				if(ad0_2 == 'Y'){ temp2++; }
				rprintf("ad0_2 = %c\n\r",ad0_2);
			}
			else if(ind == 10)
			{
				ad0_1 = stringBuf[mark-2]; // default is 'N'
				if(ad0_1 == 'Y'){ temp2++; }
				rprintf("ad0_1 = %c\n\r",ad0_1);
			}
			else if(ind == 11)
			{
				ad1_2 = stringBuf[mark-2]; // default is 'N'
				if(ad1_2 == 'Y'){ temp2++; }
				rprintf("ad1_2 = %c\n\r",ad1_2);
			}
			else if(ind == 12)
			{
				ad0_4 = stringBuf[mark-2]; // default is 'N'
				if(ad0_4 == 'Y'){ temp2++; }
				rprintf("ad0_4 = %c\n\r",ad0_4);
			}
			else if(ind == 13)
			{
				ad1_7 = stringBuf[mark-2]; // default is 'N'
				if(ad1_7 == 'Y'){ temp2++; }
				rprintf("ad1_7 = %c\n\r",ad1_7);
			}
			else if(ind == 14)
			{
				ad1_6 = stringBuf[mark-2]; // default is 'N'
				if(ad1_6 == 'Y'){ temp2++; }
				rprintf("ad1_6 = %c\n\r",ad1_6);
			}
			else if(ind == 15)
			{
				safety = stringBuf[mark-2]; // default is 'Y'
				rprintf("safety = %c\n\r",safety);
			}
		}
	}

	if(safety == 'Y')
	{
		if((temp2 ==10) && (freq > 150)){ freq = 150; }
		else if((temp2 == 9) && (freq > 166)){ freq = 166; }
		else if((temp2 == 8) && (freq > 187)){ freq = 187; }
		else if((temp2 == 7) && (freq > 214)){ freq = 214; }
		else if((temp2 == 6) && (freq > 250)){ freq = 250; }
		else if((temp2 == 5) && (freq > 300)){ freq = 300; }
		else if((temp2 == 4) && (freq > 375)){ freq = 375; }
		else if((temp2 == 3) && (freq > 500)){ freq = 500; }
		else if((temp2 == 2) && (freq > 750)){ freq = 750; }
		else if((temp2 == 1) && (freq > 1500)){ freq = 1500; }
		else if((temp2 == 0)){ freq = 100; }
	}
	
	if(safety == 'T'){ test(); }

}


void mode_0(void) // Auto UART mode
{
	rprintf("MODE 0\n\r");
	setup_uart0(baud,1);
	stringSize = 512;
	mode_action();
	//rprintf("Exit mode 0\n\r");

}

void mode_1(void)
{
	rprintf("MODE 1\n\r");	

	setup_uart0(baud,2);
	stringSize = frame + 2;

	mode_action();
}

void mode_2(void)
{
	rprintf("MODE 2\n\r");	
	enableIRQ();
	// Timer0  interrupt is an IRQ interrupt
	VICIntSelect &= ~0x00000010;
	// Enable Timer0 interrupt
	VICIntEnable |= 0x00000010;
	// Use slot 2 for UART0 interrupt
	VICVectCntl2 = 0x24;
	// Set the address of ISR for slot 1
	VICVectAddr2 = (unsigned int)MODE2ISR;

	T0TCR = 0x00000002;	// Reset counter and prescaler
	T0MCR = 0x00000003;	// On match reset the counter and generate interrupt
	T0MR0 = 58982400 / freq;

	T0PR = 0x00000000;

	T0TCR = 0x00000001; // enable timer

	stringSize = 512;
	mode_action();
}

void mode_action(void)
{
	int j;
	while(1)
	{
		
		if(log_array1 == 1)
		{
			stat(0,ON);
				
			if(fat16_write_file(handle,(unsigned char *)RX_array1, stringSize) < 0)
			{
				while(1)
				{
					stat(0,ON);
					for(j = 0; j < 500000; j++)
					stat(0,OFF);
					stat(1,ON);
					for(j = 0; j < 500000; j++)
					stat(1,OFF);
				}
			}
			
			sd_raw_sync();
			stat(0,OFF);
			log_array1 = 0;
		}

		if(log_array2 == 1)
		{
			stat(1,ON);
			
			if(fat16_write_file(handle,(unsigned char *)RX_array2, stringSize) < 0)
			{
				while(1)
				{
					stat(0,ON);
					for(j = 0; j < 500000; j++)
					stat(0,OFF);
					stat(1,ON);
					for(j = 0; j < 500000; j++)
					stat(1,OFF);
				}
			}
			
			sd_raw_sync();
			stat(1,OFF);
			log_array2 = 0;
		}

		if((IOPIN0 & 0x00000008) == 0) // if button pushed, log file & quit
		{
			VICIntEnClr = 0xFFFFFFFF;

			if(RX_in < 512)
			{
				fat16_write_file(handle, (unsigned char *)RX_array1, RX_in);
				sd_raw_sync();
			}
			else if(RX_in >= 512)
			{
				fat16_write_file(handle, (unsigned char *)RX_array2, RX_in - 512);
				sd_raw_sync();
			}
			while(1)
			{
				stat(0,ON);
				for(j = 0; j < 500000; j++);
				stat(0,OFF);
				stat(1,ON);
				for(j = 0; j < 500000; j++);
				stat(1,OFF);
			}
		}
	}

}

void test(void)
{

	rprintf("\n\rLogomatic V2 Test Code:\n\r");
	rprintf("ADC Test will begin in 5 seconds, hit stop button to terminate the test.\r\n\n");

	delay_ms(5000);

	while((IOPIN0 & 0x00000008) == 0x00000008)
	{
		// Get AD1.3
		AD1CR = 0x0020FF08;
		AD_conversion(1);

		// Get AD0.3
		AD0CR = 0x0020FF08;
		AD_conversion(0);
		
		// Get AD0.2
		AD0CR = 0x0020FF04;
		AD_conversion(0);

		// Get AD0.1
		AD0CR = 0x0020FF02;
		AD_conversion(0);

		// Get AD1.2
		AD1CR = 0x0020FF04;
		AD_conversion(1);
		
		// Get AD0.4
		AD0CR = 0x0020FF10;
		AD_conversion(0);

		// Get AD1.7
		AD1CR = 0x0020FF80;
		AD_conversion(1);

		// Get AD1.6
		AD1CR = 0x0020FF40;
		AD_conversion(1);

		delay_ms(1000);
		rprintf("\n\r");
	}

	rprintf("\n\rTest complete, locking up...\n\r");
	while(1);
		
}

void AD_conversion(int regbank)
{
	int temp = 0, temp2;

	if(!regbank) // bank 0
	{
		AD0CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD0DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD0CR = 0x00000000;
	}
	else	    // bank 1
	{
		AD1CR |= 0x01000000; // start conversion
		while((temp & 0x80000000) == 0)
		{
			temp = AD1DR;
		}
		temp &= 0x0000FFC0;
		temp2 = temp / 0x00000040;

		AD1CR = 0x00000000;
	}

	rprintf("%d", temp2);
	rprintf("   ");
	
}

void fat_initialize(void)
{
	if(!sd_raw_init())
	{
		rprintf("SD Init Error\n\r");
		while(1);
	}

	if(openroot())
	{ 
		rprintf("SD OpenRoot Error\n\r");
	}
}

void delay_ms(int count)
{
	int i;
	count *= 10000;
   10568:	e59f301c 	ldr	r3, [pc, #28]	; 1058c <.text+0x58c>
   1056c:	e0000093 	mul	r0, r3, r0
   10570:	e3a03000 	mov	r3, #0	; 0x0
   10574:	ea000001 	b	10580 <delay_ms+0x18>
	for(i = 0; i < count; i++)
		asm volatile ("nop");
   10578:	e1a00000 	nop			(mov r0,r0)
   1057c:	e2833001 	add	r3, r3, #1	; 0x1
   10580:	e1530000 	cmp	r3, r0
   10584:	bafffffb 	blt	10578 <delay_ms+0x10>
}
   10588:	e12fff1e 	bx	lr
   1058c:	00002710 	andeq	r2, r0, r0, lsl r7

00010590 <AD_conversion>:
   10590:	e3500000 	cmp	r0, #0	; 0x0
   10594:	e52de004 	str	lr, [sp, #-4]!
   10598:	1a00000d 	bne	105d4 <AD_conversion+0x44>
   1059c:	e59f207c 	ldr	r2, [pc, #124]	; 10620 <.text+0x620>
   105a0:	e5923000 	ldr	r3, [r2]
   105a4:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   105a8:	e5823000 	str	r3, [r2]
   105ac:	e59f006c 	ldr	r0, [pc, #108]	; 10620 <.text+0x620>
   105b0:	e5902004 	ldr	r2, [r0, #4]
   105b4:	e3520000 	cmp	r2, #0	; 0x0
   105b8:	aafffffb 	bge	105ac <AD_conversion+0x1c>
   105bc:	e59f3060 	ldr	r3, [pc, #96]	; 10624 <.text+0x624>
   105c0:	e0023003 	and	r3, r2, r3
   105c4:	e1a01343 	mov	r1, r3, asr #6
   105c8:	e3a03000 	mov	r3, #0	; 0x0
   105cc:	e5803000 	str	r3, [r0]
   105d0:	ea00000c 	b	10608 <AD_conversion+0x78>
   105d4:	e59f204c 	ldr	r2, [pc, #76]	; 10628 <.text+0x628>
   105d8:	e5923000 	ldr	r3, [r2]
   105dc:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   105e0:	e5823000 	str	r3, [r2]
   105e4:	e59f003c 	ldr	r0, [pc, #60]	; 10628 <.text+0x628>
   105e8:	e5901004 	ldr	r1, [r0, #4]
   105ec:	e3510000 	cmp	r1, #0	; 0x0
   105f0:	aafffffb 	bge	105e4 <AD_conversion+0x54>
   105f4:	e59f3028 	ldr	r3, [pc, #40]	; 10624 <.text+0x624>
   105f8:	e3a02000 	mov	r2, #0	; 0x0
   105fc:	e0013003 	and	r3, r1, r3
   10600:	e5802000 	str	r2, [r0]
   10604:	e1a01343 	mov	r1, r3, asr #6
   10608:	e59f001c 	ldr	r0, [pc, #28]	; 1062c <.text+0x62c>
   1060c:	eb0006ca 	bl	1213c <rprintf>
   10610:	e59f0018 	ldr	r0, [pc, #24]	; 10630 <.text+0x630>
   10614:	eb0006c8 	bl	1213c <rprintf>
   10618:	e49de004 	ldr	lr, [sp], #4
   1061c:	e12fff1e 	bx	lr
   10620:	e0034000 	and	r4, r3, r0
   10624:	0000ffc0 	andeq	pc, r0, r0, asr #31
   10628:	e0060000 	and	r0, r6, r0
   1062c:	00017efc 	streqd	r7, [r1], -ip
   10630:	00017f00 	andeq	r7, r1, r0, lsl #30

00010634 <test>:
   10634:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   10638:	e59f00c0 	ldr	r0, [pc, #192]	; 10700 <.text+0x700>
   1063c:	eb0006be 	bl	1213c <rprintf>
   10640:	e59f00bc 	ldr	r0, [pc, #188]	; 10704 <.text+0x704>
   10644:	eb0006bc 	bl	1213c <rprintf>
   10648:	e59f00b8 	ldr	r0, [pc, #184]	; 10708 <.text+0x708>
   1064c:	ebffffc5 	bl	10568 <delay_ms>
   10650:	ea00001e 	b	106d0 <test+0x9c>
   10654:	e5856000 	str	r6, [r5]
   10658:	ebffffcc 	bl	10590 <AD_conversion>
   1065c:	e3a00000 	mov	r0, #0	; 0x0
   10660:	e5846000 	str	r6, [r4]
   10664:	ebffffc9 	bl	10590 <AD_conversion>
   10668:	e3a00000 	mov	r0, #0	; 0x0
   1066c:	e5847000 	str	r7, [r4]
   10670:	ebffffc6 	bl	10590 <AD_conversion>
   10674:	e59f3090 	ldr	r3, [pc, #144]	; 1070c <.text+0x70c>
   10678:	e3a00000 	mov	r0, #0	; 0x0
   1067c:	e5843000 	str	r3, [r4]
   10680:	ebffffc2 	bl	10590 <AD_conversion>
   10684:	e3a00001 	mov	r0, #1	; 0x1
   10688:	e5857000 	str	r7, [r5]
   1068c:	ebffffbf 	bl	10590 <AD_conversion>
   10690:	e59f3078 	ldr	r3, [pc, #120]	; 10710 <.text+0x710>
   10694:	e3a00000 	mov	r0, #0	; 0x0
   10698:	e5843000 	str	r3, [r4]
   1069c:	ebffffbb 	bl	10590 <AD_conversion>
   106a0:	e59f306c 	ldr	r3, [pc, #108]	; 10714 <.text+0x714>
   106a4:	e3a00001 	mov	r0, #1	; 0x1
   106a8:	e5853000 	str	r3, [r5]
   106ac:	ebffffb7 	bl	10590 <AD_conversion>
   106b0:	e59f3060 	ldr	r3, [pc, #96]	; 10718 <.text+0x718>
   106b4:	e3a00001 	mov	r0, #1	; 0x1
   106b8:	e5853000 	str	r3, [r5]
   106bc:	ebffffb3 	bl	10590 <AD_conversion>
   106c0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
   106c4:	ebffffa7 	bl	10568 <delay_ms>
   106c8:	e59f004c 	ldr	r0, [pc, #76]	; 1071c <.text+0x71c>
   106cc:	eb00069a 	bl	1213c <rprintf>
   106d0:	e59f3048 	ldr	r3, [pc, #72]	; 10720 <.text+0x720>
   106d4:	e5933000 	ldr	r3, [r3]
   106d8:	e3130008 	tst	r3, #8	; 0x8
   106dc:	e59f5040 	ldr	r5, [pc, #64]	; 10724 <.text+0x724>
   106e0:	e59f6040 	ldr	r6, [pc, #64]	; 10728 <.text+0x728>
   106e4:	e59f4040 	ldr	r4, [pc, #64]	; 1072c <.text+0x72c>
   106e8:	e3a00001 	mov	r0, #1	; 0x1
   106ec:	e59f703c 	ldr	r7, [pc, #60]	; 10730 <.text+0x730>
   106f0:	1affffd7 	bne	10654 <test+0x20>
   106f4:	e59f0038 	ldr	r0, [pc, #56]	; 10734 <.text+0x734>
   106f8:	eb00068f 	bl	1213c <rprintf>
   106fc:	eafffffe 	b	106fc <test+0xc8>
   10700:	00017f04 	andeq	r7, r1, r4, lsl #30
   10704:	00017f20 	andeq	r7, r1, r0, lsr #30
   10708:	00001388 	andeq	r1, r0, r8, lsl #7
   1070c:	0020ff02 	eoreq	pc, r0, r2, lsl #30
   10710:	0020ff10 	eoreq	pc, r0, r0, lsl pc
   10714:	0020ff80 	eoreq	pc, r0, r0, lsl #31
   10718:	0020ff40 	eoreq	pc, r0, r0, asr #30
   1071c:	0001800c 	andeq	r8, r1, ip
   10720:	e0028000 	and	r8, r2, r0
   10724:	e0060000 	and	r0, r6, r0
   10728:	0020ff08 	eoreq	pc, r0, r8, lsl #30
   1072c:	e0034000 	and	r4, r3, r0
   10730:	0020ff04 	eoreq	pc, r0, r4, lsl #30
   10734:	00017f6c 	andeq	r7, r1, ip, ror #30

00010738 <fat_initialize>:
   10738:	e52de004 	str	lr, [sp, #-4]!
   1073c:	eb000b95 	bl	13598 <sd_raw_init>
   10740:	e3500000 	cmp	r0, #0	; 0x0
   10744:	1a000002 	bne	10754 <fat_initialize+0x1c>
   10748:	e59f001c 	ldr	r0, [pc, #28]	; 1076c <.text+0x76c>
   1074c:	eb00067a 	bl	1213c <rprintf>
   10750:	eafffffe 	b	10750 <fat_initialize+0x18>
   10754:	eb000939 	bl	12c40 <openroot>
   10758:	e3500000 	cmp	r0, #0	; 0x0
   1075c:	159f000c 	ldrne	r0, [pc, #12]	; 10770 <.text+0x770>
   10760:	1b000675 	blne	1213c <rprintf>
   10764:	e49de004 	ldr	lr, [sp], #4
   10768:	e12fff1e 	bx	lr
   1076c:	00017f90 	muleq	r1, r0, pc
   10770:	00017fa0 	andeq	r7, r1, r0, lsr #31

00010774 <mode_action>:
   10774:	e92d4010 	stmdb	sp!, {r4, lr}
   10778:	e59f31ec 	ldr	r3, [pc, #492]	; 1096c <.text+0x96c>
   1077c:	e5d33000 	ldrb	r3, [r3]
   10780:	e3530001 	cmp	r3, #1	; 0x1
   10784:	e3a00000 	mov	r0, #0	; 0x0
   10788:	e1a01003 	mov	r1, r3
   1078c:	1a000026 	bne	1082c <mode_action+0xb8>
   10790:	ebffff4e 	bl	104d0 <stat>
   10794:	e59f31d4 	ldr	r3, [pc, #468]	; 10970 <.text+0x970>
   10798:	e5930000 	ldr	r0, [r3]
   1079c:	e59f31d0 	ldr	r3, [pc, #464]	; 10974 <.text+0x974>
   107a0:	e59f11d0 	ldr	r1, [pc, #464]	; 10978 <.text+0x978>
   107a4:	e1d320b0 	ldrh	r2, [r3]
   107a8:	eb00107a 	bl	14998 <fat16_write_file>
   107ac:	e3100902 	tst	r0, #32768	; 0x8000
   107b0:	0a000016 	beq	10810 <mode_action+0x9c>
   107b4:	e3a00000 	mov	r0, #0	; 0x0
   107b8:	e3a01001 	mov	r1, #1	; 0x1
   107bc:	ebffff43 	bl	104d0 <stat>
   107c0:	e3a04000 	mov	r4, #0	; 0x0
   107c4:	e3a00000 	mov	r0, #0	; 0x0
   107c8:	e1a01000 	mov	r1, r0
   107cc:	ebffff3f 	bl	104d0 <stat>
   107d0:	e59f31a4 	ldr	r3, [pc, #420]	; 1097c <.text+0x97c>
   107d4:	e2844001 	add	r4, r4, #1	; 0x1
   107d8:	e1540003 	cmp	r4, r3
   107dc:	1afffff8 	bne	107c4 <mode_action+0x50>
   107e0:	e3a00001 	mov	r0, #1	; 0x1
   107e4:	e1a01000 	mov	r1, r0
   107e8:	ebffff38 	bl	104d0 <stat>
   107ec:	e3a04000 	mov	r4, #0	; 0x0
   107f0:	e3a00001 	mov	r0, #1	; 0x1
   107f4:	e3a01000 	mov	r1, #0	; 0x0
   107f8:	ebffff34 	bl	104d0 <stat>
   107fc:	e59f3178 	ldr	r3, [pc, #376]	; 1097c <.text+0x97c>
   10800:	e2844001 	add	r4, r4, #1	; 0x1
   10804:	e1540003 	cmp	r4, r3
   10808:	1afffff8 	bne	107f0 <mode_action+0x7c>
   1080c:	eaffffe8 	b	107b4 <mode_action+0x40>
   10810:	eb000b22 	bl	134a0 <sd_raw_sync>
   10814:	e3a00000 	mov	r0, #0	; 0x0
   10818:	e1a01000 	mov	r1, r0
   1081c:	ebffff2b 	bl	104d0 <stat>
   10820:	e59f3144 	ldr	r3, [pc, #324]	; 1096c <.text+0x96c>
   10824:	e3a02000 	mov	r2, #0	; 0x0
   10828:	e5c32000 	strb	r2, [r3]
   1082c:	e59f314c 	ldr	r3, [pc, #332]	; 10980 <.text+0x980>
   10830:	e5d33000 	ldrb	r3, [r3]
   10834:	e3530001 	cmp	r3, #1	; 0x1
   10838:	e1a00003 	mov	r0, r3
   1083c:	e1a01003 	mov	r1, r3
   10840:	1a000026 	bne	108e0 <mode_action+0x16c>
   10844:	ebffff21 	bl	104d0 <stat>
   10848:	e59f3120 	ldr	r3, [pc, #288]	; 10970 <.text+0x970>
   1084c:	e5930000 	ldr	r0, [r3]
   10850:	e59f311c 	ldr	r3, [pc, #284]	; 10974 <.text+0x974>
   10854:	e59f1128 	ldr	r1, [pc, #296]	; 10984 <.text+0x984>
   10858:	e1d320b0 	ldrh	r2, [r3]
   1085c:	eb00104d 	bl	14998 <fat16_write_file>
   10860:	e3100902 	tst	r0, #32768	; 0x8000
   10864:	0a000016 	beq	108c4 <mode_action+0x150>
   10868:	e3a00000 	mov	r0, #0	; 0x0
   1086c:	e3a01001 	mov	r1, #1	; 0x1
   10870:	ebffff16 	bl	104d0 <stat>
   10874:	e3a04000 	mov	r4, #0	; 0x0
   10878:	e3a00000 	mov	r0, #0	; 0x0
   1087c:	e1a01000 	mov	r1, r0
   10880:	ebffff12 	bl	104d0 <stat>
   10884:	e59f30f0 	ldr	r3, [pc, #240]	; 1097c <.text+0x97c>
   10888:	e2844001 	add	r4, r4, #1	; 0x1
   1088c:	e1540003 	cmp	r4, r3
   10890:	1afffff8 	bne	10878 <mode_action+0x104>
   10894:	e3a00001 	mov	r0, #1	; 0x1
   10898:	e1a01000 	mov	r1, r0
   1089c:	ebffff0b 	bl	104d0 <stat>
   108a0:	e3a04000 	mov	r4, #0	; 0x0
   108a4:	e3a00001 	mov	r0, #1	; 0x1
   108a8:	e3a01000 	mov	r1, #0	; 0x0
   108ac:	ebffff07 	bl	104d0 <stat>
   108b0:	e59f30c4 	ldr	r3, [pc, #196]	; 1097c <.text+0x97c>
   108b4:	e2844001 	add	r4, r4, #1	; 0x1
   108b8:	e1540003 	cmp	r4, r3
   108bc:	1afffff8 	bne	108a4 <mode_action+0x130>
   108c0:	eaffffe8 	b	10868 <mode_action+0xf4>
   108c4:	eb000af5 	bl	134a0 <sd_raw_sync>
   108c8:	e3a00001 	mov	r0, #1	; 0x1
   108cc:	e3a01000 	mov	r1, #0	; 0x0
   108d0:	ebfffefe 	bl	104d0 <stat>
   108d4:	e59f30a4 	ldr	r3, [pc, #164]	; 10980 <.text+0x980>
   108d8:	e3a02000 	mov	r2, #0	; 0x0
   108dc:	e5c32000 	strb	r2, [r3]
   108e0:	e59f30a0 	ldr	r3, [pc, #160]	; 10988 <.text+0x988>
   108e4:	e5933000 	ldr	r3, [r3]
   108e8:	e3130008 	tst	r3, #8	; 0x8
   108ec:	1affffa1 	bne	10778 <mode_action+0x4>
   108f0:	e59f3094 	ldr	r3, [pc, #148]	; 1098c <.text+0x98c>
   108f4:	e1d310b0 	ldrh	r1, [r3]
   108f8:	e59f3090 	ldr	r3, [pc, #144]	; 10990 <.text+0x990>
   108fc:	e1a02801 	mov	r2, r1, lsl #16
   10900:	e1530842 	cmp	r3, r2, asr #16
   10904:	b2412c02 	sublt	r2, r1, #512	; 0x200
   10908:	e59f0060 	ldr	r0, [pc, #96]	; 10970 <.text+0x970>
   1090c:	e2433c02 	sub	r3, r3, #512	; 0x200
   10910:	b1a02802 	movlt	r2, r2, lsl #16
   10914:	e5033feb 	str	r3, [r3, #-4075]
   10918:	a1a02822 	movge	r2, r2, lsr #16
   1091c:	a5900000 	ldrge	r0, [r0]
   10920:	a59f1050 	ldrge	r1, [pc, #80]	; 10978 <.text+0x978>
   10924:	b1a02822 	movlt	r2, r2, lsr #16
   10928:	b5900000 	ldrlt	r0, [r0]
   1092c:	b59f1050 	ldrlt	r1, [pc, #80]	; 10984 <.text+0x984>
   10930:	eb001018 	bl	14998 <fat16_write_file>
   10934:	eb000ad9 	bl	134a0 <sd_raw_sync>
   10938:	e3a00000 	mov	r0, #0	; 0x0
   1093c:	e3a01001 	mov	r1, #1	; 0x1
   10940:	ebfffee2 	bl	104d0 <stat>
   10944:	e3a00000 	mov	r0, #0	; 0x0
   10948:	e1a01000 	mov	r1, r0
   1094c:	ebfffedf 	bl	104d0 <stat>
   10950:	e3a00001 	mov	r0, #1	; 0x1
   10954:	e1a01000 	mov	r1, r0
   10958:	ebfffedc 	bl	104d0 <stat>
   1095c:	e3a00001 	mov	r0, #1	; 0x1
   10960:	e3a01000 	mov	r1, #0	; 0x0
   10964:	ebfffed9 	bl	104d0 <stat>
   10968:	eafffff2 	b	10938 <mode_action+0x1c4>
   1096c:	400008a4 	andmi	r0, r0, r4, lsr #17
   10970:	400012d4 	ldrmid	r1, [r0], -r4
   10974:	400012d8 	ldrmid	r1, [r0], -r8
   10978:	400010d0 	ldrmid	r1, [r0], -r0
   1097c:	0007a120 	andeq	sl, r7, r0, lsr #2
   10980:	400008a5 	andmi	r0, r0, r5, lsr #17
   10984:	40000dd0 	ldrmid	r0, [r0], -r0
   10988:	e0028000 	and	r8, r2, r0
   1098c:	400008a6 	andmi	r0, r0, r6, lsr #17
   10990:	000001ff 	streqd	r0, [r0], -pc

00010994 <mode_2>:
   10994:	e92d4010 	stmdb	sp!, {r4, lr}
   10998:	e59f007c 	ldr	r0, [pc, #124]	; 10a1c <.text+0xa1c>
   1099c:	eb0005e6 	bl	1213c <rprintf>
   109a0:	eb00193e 	bl	16ea0 <enableIRQ>
   109a4:	e3e0c000 	mvn	ip, #0	; 0x0
   109a8:	e51c3ff3 	ldr	r3, [ip, #-4083]
   109ac:	e3c33010 	bic	r3, r3, #16	; 0x10
   109b0:	e50c3ff3 	str	r3, [ip, #-4083]
   109b4:	e59f3064 	ldr	r3, [pc, #100]	; 10a20 <.text+0xa20>
   109b8:	e51c2fef 	ldr	r2, [ip, #-4079]
   109bc:	e5931000 	ldr	r1, [r3]
   109c0:	e3822010 	orr	r2, r2, #16	; 0x10
   109c4:	e3a03024 	mov	r3, #36	; 0x24
   109c8:	e50c2fef 	str	r2, [ip, #-4079]
   109cc:	e50c3df7 	str	r3, [ip, #-3575]
   109d0:	e59f304c 	ldr	r3, [pc, #76]	; 10a24 <.text+0xa24>
   109d4:	e59f404c 	ldr	r4, [pc, #76]	; 10a28 <.text+0xa28>
   109d8:	e50c3ef7 	str	r3, [ip, #-3831]
   109dc:	e3a03002 	mov	r3, #2	; 0x2
   109e0:	e5843004 	str	r3, [r4, #4]
   109e4:	e2833001 	add	r3, r3, #1	; 0x1
   109e8:	e5843014 	str	r3, [r4, #20]
   109ec:	e3a007e1 	mov	r0, #58982400	; 0x3840000
   109f0:	eb001c6d 	bl	17bac <__aeabi_idiv>
   109f4:	e59f3030 	ldr	r3, [pc, #48]	; 10a2c <.text+0xa2c>
   109f8:	e3a02c02 	mov	r2, #512	; 0x200
   109fc:	e5832000 	str	r2, [r3]
   10a00:	e3a03000 	mov	r3, #0	; 0x0
   10a04:	e5840018 	str	r0, [r4, #24]
   10a08:	e584300c 	str	r3, [r4, #12]
   10a0c:	e2833001 	add	r3, r3, #1	; 0x1
   10a10:	e5843004 	str	r3, [r4, #4]
   10a14:	e8bd4010 	ldmia	sp!, {r4, lr}
   10a18:	eaffff55 	b	10774 <mode_action>
   10a1c:	00017fb4 	streqh	r7, [r1], -r4
   10a20:	40000000 	andmi	r0, r0, r0
   10a24:	00010c30 	andeq	r0, r1, r0, lsr ip
   10a28:	e0004000 	and	r4, r0, r0
   10a2c:	400012d8 	ldrmid	r1, [r0], -r8

00010a30 <setup_uart0>:
   10a30:	e59f3160 	ldr	r3, [pc, #352]	; 10b98 <.text+0xb98>
   10a34:	e59f2160 	ldr	r2, [pc, #352]	; 10b9c <.text+0xb9c>
   10a38:	e5830000 	str	r0, [r3]
   10a3c:	e3500e4b 	cmp	r0, #1200	; 0x4b0
   10a40:	e3e0307c 	mvn	r3, #124	; 0x7c
   10a44:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   10a48:	e5c2300c 	strb	r3, [r2, #12]
   10a4c:	e20150ff 	and	r5, r1, #255	; 0xff
   10a50:	02833089 	addeq	r3, r3, #137	; 0x89
   10a54:	0a000002 	beq	10a64 <setup_uart0+0x34>
   10a58:	e3500e96 	cmp	r0, #2400	; 0x960
   10a5c:	1a000003 	bne	10a70 <setup_uart0+0x40>
   10a60:	e3a03006 	mov	r3, #6	; 0x6
   10a64:	e5c23004 	strb	r3, [r2, #4]
   10a68:	e3a03000 	mov	r3, #0	; 0x0
   10a6c:	ea00001c 	b	10ae4 <setup_uart0+0xb4>
   10a70:	e3500d4b 	cmp	r0, #4800	; 0x12c0
   10a74:	03a03003 	moveq	r3, #3	; 0x3
   10a78:	0afffff9 	beq	10a64 <setup_uart0+0x34>
   10a7c:	e3500d96 	cmp	r0, #9600	; 0x2580
   10a80:	03a03001 	moveq	r3, #1	; 0x1
   10a84:	05c23004 	streqb	r3, [r2, #4]
   10a88:	03e0307f 	mvneq	r3, #127	; 0x7f
   10a8c:	0a000014 	beq	10ae4 <setup_uart0+0xb4>
   10a90:	e3500c4b 	cmp	r0, #19200	; 0x4b00
   10a94:	03a03000 	moveq	r3, #0	; 0x0
   10a98:	05c23004 	streqb	r3, [r2, #4]
   10a9c:	03e0303f 	mvneq	r3, #63	; 0x3f
   10aa0:	0a00000f 	beq	10ae4 <setup_uart0+0xb4>
   10aa4:	e3500c96 	cmp	r0, #38400	; 0x9600
   10aa8:	03a03000 	moveq	r3, #0	; 0x0
   10aac:	05c23004 	streqb	r3, [r2, #4]
   10ab0:	02833060 	addeq	r3, r3, #96	; 0x60
   10ab4:	0a00000a 	beq	10ae4 <setup_uart0+0xb4>
   10ab8:	e3500ce1 	cmp	r0, #57600	; 0xe100
   10abc:	03a03000 	moveq	r3, #0	; 0x0
   10ac0:	05c23004 	streqb	r3, [r2, #4]
   10ac4:	02833040 	addeq	r3, r3, #64	; 0x40
   10ac8:	0a000005 	beq	10ae4 <setup_uart0+0xb4>
   10acc:	e59f30cc 	ldr	r3, [pc, #204]	; 10ba0 <.text+0xba0>
   10ad0:	e1500003 	cmp	r0, r3
   10ad4:	1a000003 	bne	10ae8 <setup_uart0+0xb8>
   10ad8:	e3a03000 	mov	r3, #0	; 0x0
   10adc:	e5c23004 	strb	r3, [r2, #4]
   10ae0:	e2833020 	add	r3, r3, #32	; 0x20
   10ae4:	e5c23000 	strb	r3, [r2]
   10ae8:	e59f40ac 	ldr	r4, [pc, #172]	; 10b9c <.text+0xb9c>
   10aec:	e3a06001 	mov	r6, #1	; 0x1
   10af0:	e3a03003 	mov	r3, #3	; 0x3
   10af4:	e3550001 	cmp	r5, #1	; 0x1
   10af8:	e5c46008 	strb	r6, [r4, #8]
   10afc:	e5c4300c 	strb	r3, [r4, #12]
   10b00:	1a00000c 	bne	10b38 <setup_uart0+0x108>
   10b04:	eb0018e5 	bl	16ea0 <enableIRQ>
   10b08:	e3e02000 	mvn	r2, #0	; 0x0
   10b0c:	e5123ff3 	ldr	r3, [r2, #-4083]
   10b10:	e3c33040 	bic	r3, r3, #64	; 0x40
   10b14:	e5023ff3 	str	r3, [r2, #-4083]
   10b18:	e5123fef 	ldr	r3, [r2, #-4079]
   10b1c:	e3833040 	orr	r3, r3, #64	; 0x40
   10b20:	e5023fef 	str	r3, [r2, #-4079]
   10b24:	e3a03026 	mov	r3, #38	; 0x26
   10b28:	e5023dfb 	str	r3, [r2, #-3579]
   10b2c:	e59f3070 	ldr	r3, [pc, #112]	; 10ba4 <.text+0xba4>
   10b30:	e5023efb 	str	r3, [r2, #-3835]
   10b34:	ea000014 	b	10b8c <setup_uart0+0x15c>
   10b38:	e3550002 	cmp	r5, #2	; 0x2
   10b3c:	1a00000d 	bne	10b78 <setup_uart0+0x148>
   10b40:	eb0018d6 	bl	16ea0 <enableIRQ>
   10b44:	e3e02000 	mvn	r2, #0	; 0x0
   10b48:	e5123ff3 	ldr	r3, [r2, #-4083]
   10b4c:	e3c33040 	bic	r3, r3, #64	; 0x40
   10b50:	e5023ff3 	str	r3, [r2, #-4083]
   10b54:	e5123fef 	ldr	r3, [r2, #-4079]
   10b58:	e3833040 	orr	r3, r3, #64	; 0x40
   10b5c:	e5023fef 	str	r3, [r2, #-4079]
   10b60:	e3a03026 	mov	r3, #38	; 0x26
   10b64:	e5023df7 	str	r3, [r2, #-3575]
   10b68:	e59f3038 	ldr	r3, [pc, #56]	; 10ba8 <.text+0xba8>
   10b6c:	e5023ef7 	str	r3, [r2, #-3831]
   10b70:	e5c46004 	strb	r6, [r4, #4]
   10b74:	ea000005 	b	10b90 <setup_uart0+0x160>
   10b78:	e3550000 	cmp	r5, #0	; 0x0
   10b7c:	1a000003 	bne	10b90 <setup_uart0+0x160>
   10b80:	e3a02040 	mov	r2, #64	; 0x40
   10b84:	e3e03000 	mvn	r3, #0	; 0x0
   10b88:	e5032feb 	str	r2, [r3, #-4075]
   10b8c:	e5c45004 	strb	r5, [r4, #4]
   10b90:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   10b94:	e12fff1e 	bx	lr
   10b98:	40000010 	andmi	r0, r0, r0, lsl r0
   10b9c:	e000c000 	and	ip, r0, r0
   10ba0:	0001c200 	andeq	ip, r1, r0, lsl #4
   10ba4:	000102dc 	ldreqd	r0, [r1], -ip
   10ba8:	0001038c 	andeq	r0, r1, ip, lsl #7

00010bac <mode_1>:
   10bac:	e52de004 	str	lr, [sp, #-4]!
   10bb0:	e59f002c 	ldr	r0, [pc, #44]	; 10be4 <.text+0xbe4>
   10bb4:	eb000560 	bl	1213c <rprintf>
   10bb8:	e59f3028 	ldr	r3, [pc, #40]	; 10be8 <.text+0xbe8>
   10bbc:	e3a01002 	mov	r1, #2	; 0x2
   10bc0:	e5930000 	ldr	r0, [r3]
   10bc4:	ebffff99 	bl	10a30 <setup_uart0>
   10bc8:	e59f301c 	ldr	r3, [pc, #28]	; 10bec <.text+0xbec>
   10bcc:	e1d330f0 	ldrsh	r3, [r3]
   10bd0:	e59f2018 	ldr	r2, [pc, #24]	; 10bf0 <.text+0xbf0>
   10bd4:	e2833002 	add	r3, r3, #2	; 0x2
   10bd8:	e5823000 	str	r3, [r2]
   10bdc:	e49de004 	ldr	lr, [sp], #4
   10be0:	eafffee3 	b	10774 <mode_action>
   10be4:	00017fc0 	andeq	r7, r1, r0, asr #31
   10be8:	40000010 	andmi	r0, r0, r0, lsl r0
   10bec:	40000014 	andmi	r0, r0, r4, lsl r0
   10bf0:	400012d8 	ldrmid	r1, [r0], -r8

00010bf4 <mode_0>:
   10bf4:	e52de004 	str	lr, [sp, #-4]!
   10bf8:	e59f0024 	ldr	r0, [pc, #36]	; 10c24 <.text+0xc24>
   10bfc:	eb00054e 	bl	1213c <rprintf>
   10c00:	e59f3020 	ldr	r3, [pc, #32]	; 10c28 <.text+0xc28>
   10c04:	e3a01001 	mov	r1, #1	; 0x1
   10c08:	e5930000 	ldr	r0, [r3]
   10c0c:	ebffff87 	bl	10a30 <setup_uart0>
   10c10:	e59f3014 	ldr	r3, [pc, #20]	; 10c2c <.text+0xc2c>
   10c14:	e3a02c02 	mov	r2, #512	; 0x200
   10c18:	e5832000 	str	r2, [r3]
   10c1c:	e49de004 	ldr	lr, [sp], #4
   10c20:	eafffed3 	b	10774 <mode_action>
   10c24:	00017fcc 	andeq	r7, r1, ip, asr #31
   10c28:	40000010 	andmi	r0, r0, r0, lsl r0
   10c2c:	400012d8 	ldrmid	r1, [r0], -r8

00010c30 <MODE2ISR>:
   10c30:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10c34:	e59f3bd4 	ldr	r3, [pc, #3028]	; 11810 <.text+0x1810>
   10c38:	e3a02001 	mov	r2, #1	; 0x1
   10c3c:	e5832000 	str	r2, [r3]
   10c40:	e24dd038 	sub	sp, sp, #56	; 0x38
   10c44:	e3a02000 	mov	r2, #0	; 0x0
   10c48:	e3a01000 	mov	r1, #0	; 0x0
   10c4c:	e28d3002 	add	r3, sp, #2	; 0x2
   10c50:	e7c21003 	strb	r1, [r2, r3]
   10c54:	e2822001 	add	r2, r2, #1	; 0x1
   10c58:	e3520032 	cmp	r2, #50	; 0x32
   10c5c:	1afffff9 	bne	10c48 <MODE2ISR+0x18>
   10c60:	e59f3bac 	ldr	r3, [pc, #2988]	; 11814 <.text+0x1814>
   10c64:	e5d33000 	ldrb	r3, [r3]
   10c68:	e3530059 	cmp	r3, #89	; 0x59
   10c6c:	11a04001 	movne	r4, r1
   10c70:	1a000041 	bne	10d7c <MODE2ISR+0x14c>
   10c74:	e59f2b9c 	ldr	r2, [pc, #2972]	; 11818 <.text+0x1818>
   10c78:	e59f3b9c 	ldr	r3, [pc, #2972]	; 1181c <.text+0x181c>
   10c7c:	e5823000 	str	r3, [r2]
   10c80:	e5923000 	ldr	r3, [r2]
   10c84:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   10c88:	e5823000 	str	r3, [r2]
   10c8c:	e59f0b84 	ldr	r0, [pc, #2948]	; 11818 <.text+0x1818>
   10c90:	e5902004 	ldr	r2, [r0, #4]
   10c94:	e3520000 	cmp	r2, #0	; 0x0
   10c98:	aafffffb 	bge	10c8c <MODE2ISR+0x5c>
   10c9c:	e59f3b7c 	ldr	r3, [pc, #2940]	; 11820 <.text+0x1820>
   10ca0:	e59f1b7c 	ldr	r1, [pc, #2940]	; 11824 <.text+0x1824>
   10ca4:	e5d33000 	ldrb	r3, [r3]
   10ca8:	e0021001 	and	r1, r2, r1
   10cac:	e3a04000 	mov	r4, #0	; 0x0
   10cb0:	e3530059 	cmp	r3, #89	; 0x59
   10cb4:	e5804000 	str	r4, [r0]
   10cb8:	e1a00321 	mov	r0, r1, lsr #6
   10cbc:	1a000028 	bne	10d64 <MODE2ISR+0x134>
   10cc0:	e3a0100a 	mov	r1, #10	; 0xa
   10cc4:	e28d2034 	add	r2, sp, #52	; 0x34
   10cc8:	eb0011b5 	bl	153a4 <itoa>
   10ccc:	e5dd2034 	ldrb	r2, [sp, #52]
   10cd0:	e2423030 	sub	r3, r2, #48	; 0x30
   10cd4:	e3530009 	cmp	r3, #9	; 0x9
   10cd8:	95cd2002 	strlsb	r2, [sp, #2]
   10cdc:	e5dd2035 	ldrb	r2, [sp, #53]
   10ce0:	e2423030 	sub	r3, r2, #48	; 0x30
   10ce4:	81a00004 	movhi	r0, r4
   10ce8:	93a00001 	movls	r0, #1	; 0x1
   10cec:	e3530009 	cmp	r3, #9	; 0x9
   10cf0:	928d1038 	addls	r1, sp, #56	; 0x38
   10cf4:	90813000 	addls	r3, r1, r0
   10cf8:	95432036 	strlsb	r2, [r3, #-54]
   10cfc:	e5dd2036 	ldrb	r2, [sp, #54]
   10d00:	e2423030 	sub	r3, r2, #48	; 0x30
   10d04:	92800001 	addls	r0, r0, #1	; 0x1
   10d08:	e3530009 	cmp	r3, #9	; 0x9
   10d0c:	928dc038 	addls	ip, sp, #56	; 0x38
   10d10:	908c3000 	addls	r3, ip, r0
   10d14:	95432036 	strlsb	r2, [r3, #-54]
   10d18:	e5dd2037 	ldrb	r2, [sp, #55]
   10d1c:	e2423030 	sub	r3, r2, #48	; 0x30
   10d20:	92800001 	addls	r0, r0, #1	; 0x1
   10d24:	e3530009 	cmp	r3, #9	; 0x9
   10d28:	928d1038 	addls	r1, sp, #56	; 0x38
   10d2c:	90813000 	addls	r3, r1, r0
   10d30:	95432036 	strlsb	r2, [r3, #-54]
   10d34:	92800001 	addls	r0, r0, #1	; 0x1
   10d38:	e3a02000 	mov	r2, #0	; 0x0
   10d3c:	e28dc038 	add	ip, sp, #56	; 0x38
   10d40:	e08c3000 	add	r3, ip, r0
   10d44:	e2804001 	add	r4, r0, #1	; 0x1
   10d48:	e1a01002 	mov	r1, r2
   10d4c:	e5432036 	strb	r2, [r3, #-54]
   10d50:	e5cd2034 	strb	r2, [sp, #52]
   10d54:	e5cd2035 	strb	r2, [sp, #53]
   10d58:	e5cd2036 	strb	r2, [sp, #54]
   10d5c:	e5cd2037 	strb	r2, [sp, #55]
   10d60:	ea000005 	b	10d7c <MODE2ISR+0x14c>
   10d64:	e353004e 	cmp	r3, #78	; 0x4e
   10d68:	01a03420 	moveq	r3, r0, lsr #8
   10d6c:	05cd3002 	streqb	r3, [sp, #2]
   10d70:	05cd0003 	streqb	r0, [sp, #3]
   10d74:	01a01004 	moveq	r1, r4
   10d78:	03a04002 	moveq	r4, #2	; 0x2
   10d7c:	e59f3aa4 	ldr	r3, [pc, #2724]	; 11828 <.text+0x1828>
   10d80:	e5d33000 	ldrb	r3, [r3]
   10d84:	e3530059 	cmp	r3, #89	; 0x59
   10d88:	1a000047 	bne	10eac <MODE2ISR+0x27c>
   10d8c:	e59f2a98 	ldr	r2, [pc, #2712]	; 1182c <.text+0x182c>
   10d90:	e59f3a84 	ldr	r3, [pc, #2692]	; 1181c <.text+0x181c>
   10d94:	e5823000 	str	r3, [r2]
   10d98:	e5923000 	ldr	r3, [r2]
   10d9c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   10da0:	e5823000 	str	r3, [r2]
   10da4:	ea000001 	b	10db0 <MODE2ISR+0x180>
   10da8:	e59f3a7c 	ldr	r3, [pc, #2684]	; 1182c <.text+0x182c>
   10dac:	e5931004 	ldr	r1, [r3, #4]
   10db0:	e3510000 	cmp	r1, #0	; 0x0
   10db4:	aafffffb 	bge	10da8 <MODE2ISR+0x178>
   10db8:	e59f3a60 	ldr	r3, [pc, #2656]	; 11820 <.text+0x1820>
   10dbc:	e3c1103f 	bic	r1, r1, #63	; 0x3f
   10dc0:	e5d32000 	ldrb	r2, [r3]
   10dc4:	e1a01801 	mov	r1, r1, lsl #16
   10dc8:	e59f3a5c 	ldr	r3, [pc, #2652]	; 1182c <.text+0x182c>
   10dcc:	e1a01821 	mov	r1, r1, lsr #16
   10dd0:	e3a05000 	mov	r5, #0	; 0x0
   10dd4:	e3520059 	cmp	r2, #89	; 0x59
   10dd8:	e5835000 	str	r5, [r3]
   10ddc:	e1a00321 	mov	r0, r1, lsr #6
   10de0:	1a000028 	bne	10e88 <MODE2ISR+0x258>
   10de4:	e3a0100a 	mov	r1, #10	; 0xa
   10de8:	e28d2034 	add	r2, sp, #52	; 0x34
   10dec:	eb00116c 	bl	153a4 <itoa>
   10df0:	e5dd2034 	ldrb	r2, [sp, #52]
   10df4:	e2423030 	sub	r3, r2, #48	; 0x30
   10df8:	e3530009 	cmp	r3, #9	; 0x9
   10dfc:	928d1038 	addls	r1, sp, #56	; 0x38
   10e00:	90813004 	addls	r3, r1, r4
   10e04:	95432036 	strlsb	r2, [r3, #-54]
   10e08:	e5dd2035 	ldrb	r2, [sp, #53]
   10e0c:	e2423030 	sub	r3, r2, #48	; 0x30
   10e10:	92844001 	addls	r4, r4, #1	; 0x1
   10e14:	e3530009 	cmp	r3, #9	; 0x9
   10e18:	928dc038 	addls	ip, sp, #56	; 0x38
   10e1c:	908c3004 	addls	r3, ip, r4
   10e20:	95432036 	strlsb	r2, [r3, #-54]
   10e24:	e5dd2036 	ldrb	r2, [sp, #54]
   10e28:	e2423030 	sub	r3, r2, #48	; 0x30
   10e2c:	92844001 	addls	r4, r4, #1	; 0x1
   10e30:	e3530009 	cmp	r3, #9	; 0x9
   10e34:	928d1038 	addls	r1, sp, #56	; 0x38
   10e38:	90813004 	addls	r3, r1, r4
   10e3c:	95432036 	strlsb	r2, [r3, #-54]
   10e40:	e5dd2037 	ldrb	r2, [sp, #55]
   10e44:	e2423030 	sub	r3, r2, #48	; 0x30
   10e48:	92844001 	addls	r4, r4, #1	; 0x1
   10e4c:	e3530009 	cmp	r3, #9	; 0x9
   10e50:	928dc038 	addls	ip, sp, #56	; 0x38
   10e54:	908c3004 	addls	r3, ip, r4
   10e58:	95432036 	strlsb	r2, [r3, #-54]
   10e5c:	92844001 	addls	r4, r4, #1	; 0x1
   10e60:	e28d2038 	add	r2, sp, #56	; 0x38
   10e64:	e0823004 	add	r3, r2, r4
   10e68:	e1a01005 	mov	r1, r5
   10e6c:	e2844001 	add	r4, r4, #1	; 0x1
   10e70:	e5435036 	strb	r5, [r3, #-54]
   10e74:	e5cd5034 	strb	r5, [sp, #52]
   10e78:	e5cd5035 	strb	r5, [sp, #53]
   10e7c:	e5cd5036 	strb	r5, [sp, #54]
   10e80:	e5cd5037 	strb	r5, [sp, #55]
   10e84:	ea000008 	b	10eac <MODE2ISR+0x27c>
   10e88:	e352004e 	cmp	r2, #78	; 0x4e
   10e8c:	1a000006 	bne	10eac <MODE2ISR+0x27c>
   10e90:	e28dc038 	add	ip, sp, #56	; 0x38
   10e94:	e08c3004 	add	r3, ip, r4
   10e98:	e1a02420 	mov	r2, r0, lsr #8
   10e9c:	e5430035 	strb	r0, [r3, #-53]
   10ea0:	e5432036 	strb	r2, [r3, #-54]
   10ea4:	e2844002 	add	r4, r4, #2	; 0x2
   10ea8:	e1a01005 	mov	r1, r5
   10eac:	e59f397c 	ldr	r3, [pc, #2428]	; 11830 <.text+0x1830>
   10eb0:	e5d33000 	ldrb	r3, [r3]
   10eb4:	e3530059 	cmp	r3, #89	; 0x59
   10eb8:	1a000047 	bne	10fdc <MODE2ISR+0x3ac>
   10ebc:	e59f2968 	ldr	r2, [pc, #2408]	; 1182c <.text+0x182c>
   10ec0:	e59f396c 	ldr	r3, [pc, #2412]	; 11834 <.text+0x1834>
   10ec4:	e5823000 	str	r3, [r2]
   10ec8:	e5923000 	ldr	r3, [r2]
   10ecc:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   10ed0:	e5823000 	str	r3, [r2]
   10ed4:	ea000001 	b	10ee0 <MODE2ISR+0x2b0>
   10ed8:	e59f394c 	ldr	r3, [pc, #2380]	; 1182c <.text+0x182c>
   10edc:	e5931004 	ldr	r1, [r3, #4]
   10ee0:	e3510000 	cmp	r1, #0	; 0x0
   10ee4:	aafffffb 	bge	10ed8 <MODE2ISR+0x2a8>
   10ee8:	e59f3930 	ldr	r3, [pc, #2352]	; 11820 <.text+0x1820>
   10eec:	e3c1103f 	bic	r1, r1, #63	; 0x3f
   10ef0:	e5d32000 	ldrb	r2, [r3]
   10ef4:	e1a01801 	mov	r1, r1, lsl #16
   10ef8:	e59f392c 	ldr	r3, [pc, #2348]	; 1182c <.text+0x182c>
   10efc:	e1a01821 	mov	r1, r1, lsr #16
   10f00:	e3a05000 	mov	r5, #0	; 0x0
   10f04:	e3520059 	cmp	r2, #89	; 0x59
   10f08:	e5835000 	str	r5, [r3]
   10f0c:	e1a00321 	mov	r0, r1, lsr #6
   10f10:	1a000028 	bne	10fb8 <MODE2ISR+0x388>
   10f14:	e3a0100a 	mov	r1, #10	; 0xa
   10f18:	e28d2034 	add	r2, sp, #52	; 0x34
   10f1c:	eb001120 	bl	153a4 <itoa>
   10f20:	e5dd2034 	ldrb	r2, [sp, #52]
   10f24:	e2423030 	sub	r3, r2, #48	; 0x30
   10f28:	e3530009 	cmp	r3, #9	; 0x9
   10f2c:	928d1038 	addls	r1, sp, #56	; 0x38
   10f30:	90813004 	addls	r3, r1, r4
   10f34:	95432036 	strlsb	r2, [r3, #-54]
   10f38:	e5dd2035 	ldrb	r2, [sp, #53]
   10f3c:	e2423030 	sub	r3, r2, #48	; 0x30
   10f40:	92844001 	addls	r4, r4, #1	; 0x1
   10f44:	e3530009 	cmp	r3, #9	; 0x9
   10f48:	928dc038 	addls	ip, sp, #56	; 0x38
   10f4c:	908c3004 	addls	r3, ip, r4
   10f50:	95432036 	strlsb	r2, [r3, #-54]
   10f54:	e5dd2036 	ldrb	r2, [sp, #54]
   10f58:	e2423030 	sub	r3, r2, #48	; 0x30
   10f5c:	92844001 	addls	r4, r4, #1	; 0x1
   10f60:	e3530009 	cmp	r3, #9	; 0x9
   10f64:	928d1038 	addls	r1, sp, #56	; 0x38
   10f68:	90813004 	addls	r3, r1, r4
   10f6c:	95432036 	strlsb	r2, [r3, #-54]
   10f70:	e5dd2037 	ldrb	r2, [sp, #55]
   10f74:	e2423030 	sub	r3, r2, #48	; 0x30
   10f78:	92844001 	addls	r4, r4, #1	; 0x1
   10f7c:	e3530009 	cmp	r3, #9	; 0x9
   10f80:	928dc038 	addls	ip, sp, #56	; 0x38
   10f84:	908c3004 	addls	r3, ip, r4
   10f88:	95432036 	strlsb	r2, [r3, #-54]
   10f8c:	92844001 	addls	r4, r4, #1	; 0x1
   10f90:	e28d2038 	add	r2, sp, #56	; 0x38
   10f94:	e0823004 	add	r3, r2, r4
   10f98:	e1a01005 	mov	r1, r5
   10f9c:	e2844001 	add	r4, r4, #1	; 0x1
   10fa0:	e5435036 	strb	r5, [r3, #-54]
   10fa4:	e5cd5034 	strb	r5, [sp, #52]
   10fa8:	e5cd5035 	strb	r5, [sp, #53]
   10fac:	e5cd5036 	strb	r5, [sp, #54]
   10fb0:	e5cd5037 	strb	r5, [sp, #55]
   10fb4:	ea000008 	b	10fdc <MODE2ISR+0x3ac>
   10fb8:	e352004e 	cmp	r2, #78	; 0x4e
   10fbc:	1a000006 	bne	10fdc <MODE2ISR+0x3ac>
   10fc0:	e28dc038 	add	ip, sp, #56	; 0x38
   10fc4:	e08c3004 	add	r3, ip, r4
   10fc8:	e1a02420 	mov	r2, r0, lsr #8
   10fcc:	e5430035 	strb	r0, [r3, #-53]
   10fd0:	e5432036 	strb	r2, [r3, #-54]
   10fd4:	e2844002 	add	r4, r4, #2	; 0x2
   10fd8:	e1a01005 	mov	r1, r5
   10fdc:	e59f3854 	ldr	r3, [pc, #2132]	; 11838 <.text+0x1838>
   10fe0:	e5d33000 	ldrb	r3, [r3]
   10fe4:	e3530059 	cmp	r3, #89	; 0x59
   10fe8:	1a000047 	bne	1110c <MODE2ISR+0x4dc>
   10fec:	e59f2838 	ldr	r2, [pc, #2104]	; 1182c <.text+0x182c>
   10ff0:	e59f3844 	ldr	r3, [pc, #2116]	; 1183c <.text+0x183c>
   10ff4:	e5823000 	str	r3, [r2]
   10ff8:	e5923000 	ldr	r3, [r2]
   10ffc:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   11000:	e5823000 	str	r3, [r2]
   11004:	ea000001 	b	11010 <MODE2ISR+0x3e0>
   11008:	e59f381c 	ldr	r3, [pc, #2076]	; 1182c <.text+0x182c>
   1100c:	e5931004 	ldr	r1, [r3, #4]
   11010:	e3510000 	cmp	r1, #0	; 0x0
   11014:	aafffffb 	bge	11008 <MODE2ISR+0x3d8>
   11018:	e59f3800 	ldr	r3, [pc, #2048]	; 11820 <.text+0x1820>
   1101c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
   11020:	e5d32000 	ldrb	r2, [r3]
   11024:	e1a01801 	mov	r1, r1, lsl #16
   11028:	e59f37fc 	ldr	r3, [pc, #2044]	; 1182c <.text+0x182c>
   1102c:	e1a01821 	mov	r1, r1, lsr #16
   11030:	e3a05000 	mov	r5, #0	; 0x0
   11034:	e3520059 	cmp	r2, #89	; 0x59
   11038:	e5835000 	str	r5, [r3]
   1103c:	e1a00321 	mov	r0, r1, lsr #6
   11040:	1a000028 	bne	110e8 <MODE2ISR+0x4b8>
   11044:	e3a0100a 	mov	r1, #10	; 0xa
   11048:	e28d2034 	add	r2, sp, #52	; 0x34
   1104c:	eb0010d4 	bl	153a4 <itoa>
   11050:	e5dd2034 	ldrb	r2, [sp, #52]
   11054:	e2423030 	sub	r3, r2, #48	; 0x30
   11058:	e3530009 	cmp	r3, #9	; 0x9
   1105c:	928d1038 	addls	r1, sp, #56	; 0x38
   11060:	90813004 	addls	r3, r1, r4
   11064:	95432036 	strlsb	r2, [r3, #-54]
   11068:	e5dd2035 	ldrb	r2, [sp, #53]
   1106c:	e2423030 	sub	r3, r2, #48	; 0x30
   11070:	92844001 	addls	r4, r4, #1	; 0x1
   11074:	e3530009 	cmp	r3, #9	; 0x9
   11078:	928dc038 	addls	ip, sp, #56	; 0x38
   1107c:	908c3004 	addls	r3, ip, r4
   11080:	95432036 	strlsb	r2, [r3, #-54]
   11084:	e5dd2036 	ldrb	r2, [sp, #54]
   11088:	e2423030 	sub	r3, r2, #48	; 0x30
   1108c:	92844001 	addls	r4, r4, #1	; 0x1
   11090:	e3530009 	cmp	r3, #9	; 0x9
   11094:	928d1038 	addls	r1, sp, #56	; 0x38
   11098:	90813004 	addls	r3, r1, r4
   1109c:	95432036 	strlsb	r2, [r3, #-54]
   110a0:	e5dd2037 	ldrb	r2, [sp, #55]
   110a4:	e2423030 	sub	r3, r2, #48	; 0x30
   110a8:	92844001 	addls	r4, r4, #1	; 0x1
   110ac:	e3530009 	cmp	r3, #9	; 0x9
   110b0:	928dc038 	addls	ip, sp, #56	; 0x38
   110b4:	908c3004 	addls	r3, ip, r4
   110b8:	95432036 	strlsb	r2, [r3, #-54]
   110bc:	92844001 	addls	r4, r4, #1	; 0x1
   110c0:	e28d2038 	add	r2, sp, #56	; 0x38
   110c4:	e0823004 	add	r3, r2, r4
   110c8:	e1a01005 	mov	r1, r5
   110cc:	e2844001 	add	r4, r4, #1	; 0x1
   110d0:	e5435036 	strb	r5, [r3, #-54]
   110d4:	e5cd5034 	strb	r5, [sp, #52]
   110d8:	e5cd5035 	strb	r5, [sp, #53]
   110dc:	e5cd5036 	strb	r5, [sp, #54]
   110e0:	e5cd5037 	strb	r5, [sp, #55]
   110e4:	ea000008 	b	1110c <MODE2ISR+0x4dc>
   110e8:	e352004e 	cmp	r2, #78	; 0x4e
   110ec:	1a000006 	bne	1110c <MODE2ISR+0x4dc>
   110f0:	e28dc038 	add	ip, sp, #56	; 0x38
   110f4:	e08c3004 	add	r3, ip, r4
   110f8:	e1a02420 	mov	r2, r0, lsr #8
   110fc:	e5430035 	strb	r0, [r3, #-53]
   11100:	e5432036 	strb	r2, [r3, #-54]
   11104:	e2844002 	add	r4, r4, #2	; 0x2
   11108:	e1a01005 	mov	r1, r5
   1110c:	e59f372c 	ldr	r3, [pc, #1836]	; 11840 <.text+0x1840>
   11110:	e5d33000 	ldrb	r3, [r3]
   11114:	e3530059 	cmp	r3, #89	; 0x59
   11118:	1a000047 	bne	1123c <MODE2ISR+0x60c>
   1111c:	e59f26f4 	ldr	r2, [pc, #1780]	; 11818 <.text+0x1818>
   11120:	e59f370c 	ldr	r3, [pc, #1804]	; 11834 <.text+0x1834>
   11124:	e5823000 	str	r3, [r2]
   11128:	e5923000 	ldr	r3, [r2]
   1112c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   11130:	e5823000 	str	r3, [r2]
   11134:	ea000001 	b	11140 <MODE2ISR+0x510>
   11138:	e59f36d8 	ldr	r3, [pc, #1752]	; 11818 <.text+0x1818>
   1113c:	e5931004 	ldr	r1, [r3, #4]
   11140:	e3510000 	cmp	r1, #0	; 0x0
   11144:	aafffffb 	bge	11138 <MODE2ISR+0x508>
   11148:	e59f36d0 	ldr	r3, [pc, #1744]	; 11820 <.text+0x1820>
   1114c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
   11150:	e5d32000 	ldrb	r2, [r3]
   11154:	e1a01801 	mov	r1, r1, lsl #16
   11158:	e59f36b8 	ldr	r3, [pc, #1720]	; 11818 <.text+0x1818>
   1115c:	e1a01821 	mov	r1, r1, lsr #16
   11160:	e3a05000 	mov	r5, #0	; 0x0
   11164:	e3520059 	cmp	r2, #89	; 0x59
   11168:	e5835000 	str	r5, [r3]
   1116c:	e1a00321 	mov	r0, r1, lsr #6
   11170:	1a000028 	bne	11218 <MODE2ISR+0x5e8>
   11174:	e3a0100a 	mov	r1, #10	; 0xa
   11178:	e28d2034 	add	r2, sp, #52	; 0x34
   1117c:	eb001088 	bl	153a4 <itoa>
   11180:	e5dd2034 	ldrb	r2, [sp, #52]
   11184:	e2423030 	sub	r3, r2, #48	; 0x30
   11188:	e3530009 	cmp	r3, #9	; 0x9
   1118c:	928d1038 	addls	r1, sp, #56	; 0x38
   11190:	90813004 	addls	r3, r1, r4
   11194:	95432036 	strlsb	r2, [r3, #-54]
   11198:	e5dd2035 	ldrb	r2, [sp, #53]
   1119c:	e2423030 	sub	r3, r2, #48	; 0x30
   111a0:	92844001 	addls	r4, r4, #1	; 0x1
   111a4:	e3530009 	cmp	r3, #9	; 0x9
   111a8:	928dc038 	addls	ip, sp, #56	; 0x38
   111ac:	908c3004 	addls	r3, ip, r4
   111b0:	95432036 	strlsb	r2, [r3, #-54]
   111b4:	e5dd2036 	ldrb	r2, [sp, #54]
   111b8:	e2423030 	sub	r3, r2, #48	; 0x30
   111bc:	92844001 	addls	r4, r4, #1	; 0x1
   111c0:	e3530009 	cmp	r3, #9	; 0x9
   111c4:	928d1038 	addls	r1, sp, #56	; 0x38
   111c8:	90813004 	addls	r3, r1, r4
   111cc:	95432036 	strlsb	r2, [r3, #-54]
   111d0:	e5dd2037 	ldrb	r2, [sp, #55]
   111d4:	e2423030 	sub	r3, r2, #48	; 0x30
   111d8:	92844001 	addls	r4, r4, #1	; 0x1
   111dc:	e3530009 	cmp	r3, #9	; 0x9
   111e0:	928dc038 	addls	ip, sp, #56	; 0x38
   111e4:	908c3004 	addls	r3, ip, r4
   111e8:	95432036 	strlsb	r2, [r3, #-54]
   111ec:	92844001 	addls	r4, r4, #1	; 0x1
   111f0:	e28d2038 	add	r2, sp, #56	; 0x38
   111f4:	e0823004 	add	r3, r2, r4
   111f8:	e1a01005 	mov	r1, r5
   111fc:	e2844001 	add	r4, r4, #1	; 0x1
   11200:	e5435036 	strb	r5, [r3, #-54]
   11204:	e5cd5034 	strb	r5, [sp, #52]
   11208:	e5cd5035 	strb	r5, [sp, #53]
   1120c:	e5cd5036 	strb	r5, [sp, #54]
   11210:	e5cd5037 	strb	r5, [sp, #55]
   11214:	ea000008 	b	1123c <MODE2ISR+0x60c>
   11218:	e352004e 	cmp	r2, #78	; 0x4e
   1121c:	1a000006 	bne	1123c <MODE2ISR+0x60c>
   11220:	e28dc038 	add	ip, sp, #56	; 0x38
   11224:	e08c3004 	add	r3, ip, r4
   11228:	e1a02420 	mov	r2, r0, lsr #8
   1122c:	e5430035 	strb	r0, [r3, #-53]
   11230:	e5432036 	strb	r2, [r3, #-54]
   11234:	e2844002 	add	r4, r4, #2	; 0x2
   11238:	e1a01005 	mov	r1, r5
   1123c:	e59f3600 	ldr	r3, [pc, #1536]	; 11844 <.text+0x1844>
   11240:	e5d33000 	ldrb	r3, [r3]
   11244:	e3530059 	cmp	r3, #89	; 0x59
   11248:	1a000047 	bne	1136c <MODE2ISR+0x73c>
   1124c:	e59f25d8 	ldr	r2, [pc, #1496]	; 1182c <.text+0x182c>
   11250:	e59f35f0 	ldr	r3, [pc, #1520]	; 11848 <.text+0x1848>
   11254:	e5823000 	str	r3, [r2]
   11258:	e5923000 	ldr	r3, [r2]
   1125c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   11260:	e5823000 	str	r3, [r2]
   11264:	ea000001 	b	11270 <MODE2ISR+0x640>
   11268:	e59f35bc 	ldr	r3, [pc, #1468]	; 1182c <.text+0x182c>
   1126c:	e5931004 	ldr	r1, [r3, #4]
   11270:	e3510000 	cmp	r1, #0	; 0x0
   11274:	aafffffb 	bge	11268 <MODE2ISR+0x638>
   11278:	e59f35a0 	ldr	r3, [pc, #1440]	; 11820 <.text+0x1820>
   1127c:	e3c1103f 	bic	r1, r1, #63	; 0x3f
   11280:	e5d32000 	ldrb	r2, [r3]
   11284:	e1a01801 	mov	r1, r1, lsl #16
   11288:	e59f359c 	ldr	r3, [pc, #1436]	; 1182c <.text+0x182c>
   1128c:	e1a01821 	mov	r1, r1, lsr #16
   11290:	e3a05000 	mov	r5, #0	; 0x0
   11294:	e3520059 	cmp	r2, #89	; 0x59
   11298:	e5835000 	str	r5, [r3]
   1129c:	e1a00321 	mov	r0, r1, lsr #6
   112a0:	1a000028 	bne	11348 <MODE2ISR+0x718>
   112a4:	e3a0100a 	mov	r1, #10	; 0xa
   112a8:	e28d2034 	add	r2, sp, #52	; 0x34
   112ac:	eb00103c 	bl	153a4 <itoa>
   112b0:	e5dd2034 	ldrb	r2, [sp, #52]
   112b4:	e2423030 	sub	r3, r2, #48	; 0x30
   112b8:	e3530009 	cmp	r3, #9	; 0x9
   112bc:	928d1038 	addls	r1, sp, #56	; 0x38
   112c0:	90813004 	addls	r3, r1, r4
   112c4:	95432036 	strlsb	r2, [r3, #-54]
   112c8:	e5dd2035 	ldrb	r2, [sp, #53]
   112cc:	e2423030 	sub	r3, r2, #48	; 0x30
   112d0:	92844001 	addls	r4, r4, #1	; 0x1
   112d4:	e3530009 	cmp	r3, #9	; 0x9
   112d8:	928dc038 	addls	ip, sp, #56	; 0x38
   112dc:	908c3004 	addls	r3, ip, r4
   112e0:	95432036 	strlsb	r2, [r3, #-54]
   112e4:	e5dd2036 	ldrb	r2, [sp, #54]
   112e8:	e2423030 	sub	r3, r2, #48	; 0x30
   112ec:	92844001 	addls	r4, r4, #1	; 0x1
   112f0:	e3530009 	cmp	r3, #9	; 0x9
   112f4:	928d1038 	addls	r1, sp, #56	; 0x38
   112f8:	90813004 	addls	r3, r1, r4
   112fc:	95432036 	strlsb	r2, [r3, #-54]
   11300:	e5dd2037 	ldrb	r2, [sp, #55]
   11304:	e2423030 	sub	r3, r2, #48	; 0x30
   11308:	92844001 	addls	r4, r4, #1	; 0x1
   1130c:	e3530009 	cmp	r3, #9	; 0x9
   11310:	928dc038 	addls	ip, sp, #56	; 0x38
   11314:	908c3004 	addls	r3, ip, r4
   11318:	95432036 	strlsb	r2, [r3, #-54]
   1131c:	92844001 	addls	r4, r4, #1	; 0x1
   11320:	e28d2038 	add	r2, sp, #56	; 0x38
   11324:	e0823004 	add	r3, r2, r4
   11328:	e1a01005 	mov	r1, r5
   1132c:	e2844001 	add	r4, r4, #1	; 0x1
   11330:	e5435036 	strb	r5, [r3, #-54]
   11334:	e5cd5034 	strb	r5, [sp, #52]
   11338:	e5cd5035 	strb	r5, [sp, #53]
   1133c:	e5cd5036 	strb	r5, [sp, #54]
   11340:	e5cd5037 	strb	r5, [sp, #55]
   11344:	ea000008 	b	1136c <MODE2ISR+0x73c>
   11348:	e352004e 	cmp	r2, #78	; 0x4e
   1134c:	1a000006 	bne	1136c <MODE2ISR+0x73c>
   11350:	e28dc038 	add	ip, sp, #56	; 0x38
   11354:	e08c3004 	add	r3, ip, r4
   11358:	e1a02420 	mov	r2, r0, lsr #8
   1135c:	e5430035 	strb	r0, [r3, #-53]
   11360:	e5432036 	strb	r2, [r3, #-54]
   11364:	e2844002 	add	r4, r4, #2	; 0x2
   11368:	e1a01005 	mov	r1, r5
   1136c:	e59f34d8 	ldr	r3, [pc, #1240]	; 1184c <.text+0x184c>
   11370:	e5d33000 	ldrb	r3, [r3]
   11374:	e3530059 	cmp	r3, #89	; 0x59
   11378:	1a000047 	bne	1149c <MODE2ISR+0x86c>
   1137c:	e59f2494 	ldr	r2, [pc, #1172]	; 11818 <.text+0x1818>
   11380:	e59f34c8 	ldr	r3, [pc, #1224]	; 11850 <.text+0x1850>
   11384:	e5823000 	str	r3, [r2]
   11388:	e5923000 	ldr	r3, [r2]
   1138c:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   11390:	e5823000 	str	r3, [r2]
   11394:	ea000001 	b	113a0 <MODE2ISR+0x770>
   11398:	e59f3478 	ldr	r3, [pc, #1144]	; 11818 <.text+0x1818>
   1139c:	e5931004 	ldr	r1, [r3, #4]
   113a0:	e3510000 	cmp	r1, #0	; 0x0
   113a4:	aafffffb 	bge	11398 <MODE2ISR+0x768>
   113a8:	e59f3470 	ldr	r3, [pc, #1136]	; 11820 <.text+0x1820>
   113ac:	e3c1103f 	bic	r1, r1, #63	; 0x3f
   113b0:	e5d32000 	ldrb	r2, [r3]
   113b4:	e1a01801 	mov	r1, r1, lsl #16
   113b8:	e59f3458 	ldr	r3, [pc, #1112]	; 11818 <.text+0x1818>
   113bc:	e1a01821 	mov	r1, r1, lsr #16
   113c0:	e3a05000 	mov	r5, #0	; 0x0
   113c4:	e3520059 	cmp	r2, #89	; 0x59
   113c8:	e5835000 	str	r5, [r3]
   113cc:	e1a00321 	mov	r0, r1, lsr #6
   113d0:	1a000028 	bne	11478 <MODE2ISR+0x848>
   113d4:	e3a0100a 	mov	r1, #10	; 0xa
   113d8:	e28d2034 	add	r2, sp, #52	; 0x34
   113dc:	eb000ff0 	bl	153a4 <itoa>
   113e0:	e5dd2034 	ldrb	r2, [sp, #52]
   113e4:	e2423030 	sub	r3, r2, #48	; 0x30
   113e8:	e3530009 	cmp	r3, #9	; 0x9
   113ec:	928d1038 	addls	r1, sp, #56	; 0x38
   113f0:	90813004 	addls	r3, r1, r4
   113f4:	95432036 	strlsb	r2, [r3, #-54]
   113f8:	e5dd2035 	ldrb	r2, [sp, #53]
   113fc:	e2423030 	sub	r3, r2, #48	; 0x30
   11400:	92844001 	addls	r4, r4, #1	; 0x1
   11404:	e3530009 	cmp	r3, #9	; 0x9
   11408:	928dc038 	addls	ip, sp, #56	; 0x38
   1140c:	908c3004 	addls	r3, ip, r4
   11410:	95432036 	strlsb	r2, [r3, #-54]
   11414:	e5dd2036 	ldrb	r2, [sp, #54]
   11418:	e2423030 	sub	r3, r2, #48	; 0x30
   1141c:	92844001 	addls	r4, r4, #1	; 0x1
   11420:	e3530009 	cmp	r3, #9	; 0x9
   11424:	928d1038 	addls	r1, sp, #56	; 0x38
   11428:	90813004 	addls	r3, r1, r4
   1142c:	95432036 	strlsb	r2, [r3, #-54]
   11430:	e5dd2037 	ldrb	r2, [sp, #55]
   11434:	e2423030 	sub	r3, r2, #48	; 0x30
   11438:	92844001 	addls	r4, r4, #1	; 0x1
   1143c:	e3530009 	cmp	r3, #9	; 0x9
   11440:	928dc038 	addls	ip, sp, #56	; 0x38
   11444:	908c3004 	addls	r3, ip, r4
   11448:	95432036 	strlsb	r2, [r3, #-54]
   1144c:	92844001 	addls	r4, r4, #1	; 0x1
   11450:	e28d2038 	add	r2, sp, #56	; 0x38
   11454:	e0823004 	add	r3, r2, r4
   11458:	e1a01005 	mov	r1, r5
   1145c:	e2844001 	add	r4, r4, #1	; 0x1
   11460:	e5435036 	strb	r5, [r3, #-54]
   11464:	e5cd5034 	strb	r5, [sp, #52]
   11468:	e5cd5035 	strb	r5, [sp, #53]
   1146c:	e5cd5036 	strb	r5, [sp, #54]
   11470:	e5cd5037 	strb	r5, [sp, #55]
   11474:	ea000008 	b	1149c <MODE2ISR+0x86c>
   11478:	e352004e 	cmp	r2, #78	; 0x4e
   1147c:	1a000006 	bne	1149c <MODE2ISR+0x86c>
   11480:	e28dc038 	add	ip, sp, #56	; 0x38
   11484:	e08c3004 	add	r3, ip, r4
   11488:	e1a02420 	mov	r2, r0, lsr #8
   1148c:	e5430035 	strb	r0, [r3, #-53]
   11490:	e5432036 	strb	r2, [r3, #-54]
   11494:	e2844002 	add	r4, r4, #2	; 0x2
   11498:	e1a01005 	mov	r1, r5
   1149c:	e59f33b0 	ldr	r3, [pc, #944]	; 11854 <.text+0x1854>
   114a0:	e5d33000 	ldrb	r3, [r3]
   114a4:	e3530059 	cmp	r3, #89	; 0x59
   114a8:	1a000040 	bne	115b0 <MODE2ISR+0x980>
   114ac:	e59f2364 	ldr	r2, [pc, #868]	; 11818 <.text+0x1818>
   114b0:	e59f33a0 	ldr	r3, [pc, #928]	; 11858 <.text+0x1858>
   114b4:	e5823000 	str	r3, [r2]
   114b8:	e5923000 	ldr	r3, [r2]
   114bc:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
   114c0:	e5823000 	str	r3, [r2]
   114c4:	ea000001 	b	114d0 <MODE2ISR+0x8a0>
   114c8:	e59f3348 	ldr	r3, [pc, #840]	; 11818 <.text+0x1818>
   114cc:	e5931004 	ldr	r1, [r3, #4]
   114d0:	e3510000 	cmp	r1, #0	; 0x0
   114d4:	aafffffb 	bge	114c8 <MODE2ISR+0x898>
   114d8:	e59f3340 	ldr	r3, [pc, #832]	; 11820 <.text+0x1820>
   114dc:	e59f2340 	ldr	r2, [pc, #832]	; 11824 <.text+0x1824>
   114e0:	e5d3c000 	ldrb	ip, [r3]
   114e4:	e59f332c 	ldr	r3, [pc, #812]	; 11818 <.text+0x1818>
   114e8:	e0012002 	and	r2, r1, r2
   114ec:	e3a05000 	mov	r5, #0	; 0x0
   114f0:	e35c0059 	cmp	ip, #89	; 0x59
   114f4:	e5835000 	str	r5, [r3]
   114f8:	e1a00342 	mov	r0, r2, asr #6
   114fc:	1a000023 	bne	11590 <MODE2ISR+0x960>
   11500:	e3a0100a 	mov	r1, #10	; 0xa
   11504:	e28d2034 	add	r2, sp, #52	; 0x34
   11508:	eb000fa5 	bl	153a4 <itoa>
   1150c:	e5dd2034 	ldrb	r2, [sp, #52]
   11510:	e2423030 	sub	r3, r2, #48	; 0x30
   11514:	e3530009 	cmp	r3, #9	; 0x9
   11518:	928d1038 	addls	r1, sp, #56	; 0x38
   1151c:	90813004 	addls	r3, r1, r4
   11520:	95432036 	strlsb	r2, [r3, #-54]
   11524:	e5dd2035 	ldrb	r2, [sp, #53]
   11528:	e2423030 	sub	r3, r2, #48	; 0x30
   1152c:	92844001 	addls	r4, r4, #1	; 0x1
   11530:	e3530009 	cmp	r3, #9	; 0x9
   11534:	928dc038 	addls	ip, sp, #56	; 0x38
   11538:	908c3004 	addls	r3, ip, r4
   1153c:	95432036 	strlsb	r2, [r3, #-54]
   11540:	e5dd2036 	ldrb	r2, [sp, #54]
   11544:	e2423030 	sub	r3, r2, #48	; 0x30
   11548:	92844001 	addls	r4, r4, #1	; 0x1
   1154c:	e3530009 	cmp	r3, #9	; 0x9
   11550:	928d1038 	addls	r1, sp, #56	; 0x38
   11554:	90813004 	addls	r3, r1, r4
   11558:	95432036 	strlsb	r2, [r3, #-54]
   1155c:	e5dd2037 	ldrb	r2, [sp, #55]
   11560:	e2423030 	sub	r3, r2, #48	; 0x30
   11564:	92844001 	addls	r4, r4, #1	; 0x1
   11568:	e3530009 	cmp	r3, #9	; 0x9
   1156c:	928dc038 	addls	ip, sp, #56	; 0x38
   11570:	908c3004 	addls	r3, ip, r4
   11574:	e28d1038 	add	r1, sp, #56	; 0x38
   11578:	92844001 	addls	r4, r4, #1	; 0x1
   1157c:	95432036 	strlsb	r2, [r3, #-54]
   11580:	e0813004 	add	r3, r1, r4
   11584:	e2844001 	add	r4, r4, #1	; 0x1
   11588:	e5435036 	strb	r5, [r3, #-54]
   1158c:	ea000007 	b	115b0 <MODE2ISR+0x980>
   11590:	e35c004e 	cmp	ip, #78	; 0x4e
   11594:	1a000005 	bne	115b0 <MODE2ISR+0x980>
   11598:	e28d2038 	add	r2, sp, #56	; 0x38
   1159c:	e0823004 	add	r3, r2, r4
   115a0:	e1a02420 	mov	r2, r0, lsr #8
   115a4:	e5430035 	strb	r0, [r3, #-53]
   115a8:	e5432036 	strb	r2, [r3, #-54]
   115ac:	e2844002 	add	r4, r4, #2	; 0x2
   115b0:	e59f32a4 	ldr	r3, [pc, #676]	; 1185c <.text+0x185c>
   115b4:	e5d38000 	ldrb	r8, [r3]
   115b8:	e59f32a0 	ldr	r3, [pc, #672]	; 11860 <.text+0x1860>
   115bc:	e1d300b0 	ldrh	r0, [r3]
   115c0:	e59f329c 	ldr	r3, [pc, #668]	; 11864 <.text+0x1864>
   115c4:	e5d37000 	ldrb	r7, [r3]
   115c8:	e3a06000 	mov	r6, #0	; 0x0
   115cc:	ea000010 	b	11614 <MODE2ISR+0x9e4>
   115d0:	e3510c02 	cmp	r1, #512	; 0x200
   115d4:	e1a0082e 	mov	r0, lr, lsr #16
   115d8:	e28d3002 	add	r3, sp, #2	; 0x2
   115dc:	aa000006 	bge	115fc <MODE2ISR+0x9cc>
   115e0:	e7d62003 	ldrb	r2, [r6, r3]
   115e4:	e35c0402 	cmp	ip, #33554432	; 0x2000000
   115e8:	e59f3278 	ldr	r3, [pc, #632]	; 11868 <.text+0x1868>
   115ec:	e1a0082c 	mov	r0, ip, lsr #16
   115f0:	03a07001 	moveq	r7, #1	; 0x1
   115f4:	e7c32001 	strb	r2, [r3, r1]
   115f8:	ea000004 	b	11610 <MODE2ISR+0x9e0>
   115fc:	e7d63003 	ldrb	r3, [r6, r3]
   11600:	e35e0301 	cmp	lr, #67108864	; 0x4000000
   11604:	e5453200 	strb	r3, [r5, #-512]
   11608:	03a08001 	moveq	r8, #1	; 0x1
   1160c:	03a00000 	moveq	r0, #0	; 0x0
   11610:	e2866001 	add	r6, r6, #1	; 0x1
   11614:	e2803001 	add	r3, r0, #1	; 0x1
   11618:	e1a0e803 	mov	lr, r3, lsl #16
   1161c:	e1a02800 	mov	r2, r0, lsl #16
   11620:	e59f3244 	ldr	r3, [pc, #580]	; 1186c <.text+0x186c>
   11624:	e1a01842 	mov	r1, r2, asr #16
   11628:	e1560004 	cmp	r6, r4
   1162c:	e1a0c00e 	mov	ip, lr
   11630:	e0815003 	add	r5, r1, r3
   11634:	baffffe5 	blt	115d0 <MODE2ISR+0x9a0>
   11638:	e59f321c 	ldr	r3, [pc, #540]	; 1185c <.text+0x185c>
   1163c:	e5c38000 	strb	r8, [r3]
   11640:	e59f3218 	ldr	r3, [pc, #536]	; 11860 <.text+0x1860>
   11644:	e1a02822 	mov	r2, r2, lsr #16
   11648:	e1c320b0 	strh	r2, [r3]
   1164c:	e59f3210 	ldr	r3, [pc, #528]	; 11864 <.text+0x1864>
   11650:	e3510c02 	cmp	r1, #512	; 0x200
   11654:	e5c37000 	strb	r7, [r3]
   11658:	e59f31c0 	ldr	r3, [pc, #448]	; 11820 <.text+0x1820>
   1165c:	aa000016 	bge	116bc <MODE2ISR+0xa8c>
   11660:	e5d33000 	ldrb	r3, [r3]
   11664:	e353004e 	cmp	r3, #78	; 0x4e
   11668:	03a02024 	moveq	r2, #36	; 0x24
   1166c:	0a000002 	beq	1167c <MODE2ISR+0xa4c>
   11670:	e3530059 	cmp	r3, #89	; 0x59
   11674:	1a000002 	bne	11684 <MODE2ISR+0xa54>
   11678:	e3a0200d 	mov	r2, #13	; 0xd
   1167c:	e59f31e4 	ldr	r3, [pc, #484]	; 11868 <.text+0x1868>
   11680:	e7c32001 	strb	r2, [r3, r1]
   11684:	e2803001 	add	r3, r0, #1	; 0x1
   11688:	e1a03803 	mov	r3, r3, lsl #16
   1168c:	e1a03823 	mov	r3, r3, lsr #16
   11690:	e1a02803 	mov	r2, r3, lsl #16
   11694:	e1a01842 	mov	r1, r2, asr #16
   11698:	e59f21c0 	ldr	r2, [pc, #448]	; 11860 <.text+0x1860>
   1169c:	e3510c02 	cmp	r1, #512	; 0x200
   116a0:	e1c230b0 	strh	r3, [r2]
   116a4:	1a00001e 	bne	11724 <MODE2ISR+0xaf4>
   116a8:	e59f31b4 	ldr	r3, [pc, #436]	; 11864 <.text+0x1864>
   116ac:	e3a02001 	mov	r2, #1	; 0x1
   116b0:	e1a00001 	mov	r0, r1
   116b4:	e5c32000 	strb	r2, [r3]
   116b8:	ea000034 	b	11790 <MODE2ISR+0xb60>
   116bc:	e5d33000 	ldrb	r3, [r3]
   116c0:	e353004e 	cmp	r3, #78	; 0x4e
   116c4:	059f31a0 	ldreq	r3, [pc, #416]	; 1186c <.text+0x186c>
   116c8:	03a02024 	moveq	r2, #36	; 0x24
   116cc:	00813003 	addeq	r3, r1, r3
   116d0:	0a000004 	beq	116e8 <MODE2ISR+0xab8>
   116d4:	e3530059 	cmp	r3, #89	; 0x59
   116d8:	1a000003 	bne	116ec <MODE2ISR+0xabc>
   116dc:	e59f3188 	ldr	r3, [pc, #392]	; 1186c <.text+0x186c>
   116e0:	e3a0200d 	mov	r2, #13	; 0xd
   116e4:	e0813003 	add	r3, r1, r3
   116e8:	e5432200 	strb	r2, [r3, #-512]
   116ec:	e2803001 	add	r3, r0, #1	; 0x1
   116f0:	e1a03803 	mov	r3, r3, lsl #16
   116f4:	e1a03823 	mov	r3, r3, lsr #16
   116f8:	e59f1160 	ldr	r1, [pc, #352]	; 11860 <.text+0x1860>
   116fc:	e3530b01 	cmp	r3, #1024	; 0x400
   11700:	e1c130b0 	strh	r3, [r1]
   11704:	1a000006 	bne	11724 <MODE2ISR+0xaf4>
   11708:	e59f314c 	ldr	r3, [pc, #332]	; 1185c <.text+0x185c>
   1170c:	e3a02001 	mov	r2, #1	; 0x1
   11710:	e5c32000 	strb	r2, [r3]
   11714:	e3a00000 	mov	r0, #0	; 0x0
   11718:	e3a03000 	mov	r3, #0	; 0x0
   1171c:	e1c130b0 	strh	r3, [r1]
   11720:	ea000004 	b	11738 <MODE2ISR+0xb08>
   11724:	e59f2134 	ldr	r2, [pc, #308]	; 11860 <.text+0x1860>
   11728:	e1d230f0 	ldrsh	r3, [r2]
   1172c:	e3530c02 	cmp	r3, #512	; 0x200
   11730:	e1d200b0 	ldrh	r0, [r2]
   11734:	aa000015 	bge	11790 <MODE2ISR+0xb60>
   11738:	e59f30e0 	ldr	r3, [pc, #224]	; 11820 <.text+0x1820>
   1173c:	e5d33000 	ldrb	r3, [r3]
   11740:	e353004e 	cmp	r3, #78	; 0x4e
   11744:	01a01800 	moveq	r1, r0, lsl #16
   11748:	03a02024 	moveq	r2, #36	; 0x24
   1174c:	0a000003 	beq	11760 <MODE2ISR+0xb30>
   11750:	e3530059 	cmp	r3, #89	; 0x59
   11754:	1a000003 	bne	11768 <MODE2ISR+0xb38>
   11758:	e1a01800 	mov	r1, r0, lsl #16
   1175c:	e3a0200a 	mov	r2, #10	; 0xa
   11760:	e59f3100 	ldr	r3, [pc, #256]	; 11868 <.text+0x1868>
   11764:	e7c32841 	strb	r2, [r3, r1, asr #16]
   11768:	e2803001 	add	r3, r0, #1	; 0x1
   1176c:	e1a03803 	mov	r3, r3, lsl #16
   11770:	e1a03823 	mov	r3, r3, lsr #16
   11774:	e59f20e4 	ldr	r2, [pc, #228]	; 11860 <.text+0x1860>
   11778:	e3530c02 	cmp	r3, #512	; 0x200
   1177c:	e1c230b0 	strh	r3, [r2]
   11780:	059f30dc 	ldreq	r3, [pc, #220]	; 11864 <.text+0x1864>
   11784:	03a02001 	moveq	r2, #1	; 0x1
   11788:	05c32000 	streqb	r2, [r3]
   1178c:	ea000019 	b	117f8 <MODE2ISR+0xbc8>
   11790:	e59f3088 	ldr	r3, [pc, #136]	; 11820 <.text+0x1820>
   11794:	e5d33000 	ldrb	r3, [r3]
   11798:	e353004e 	cmp	r3, #78	; 0x4e
   1179c:	059f20c8 	ldreq	r2, [pc, #200]	; 1186c <.text+0x186c>
   117a0:	01a03800 	moveq	r3, r0, lsl #16
   117a4:	00822843 	addeq	r2, r2, r3, asr #16
   117a8:	03a03024 	moveq	r3, #36	; 0x24
   117ac:	0a000005 	beq	117c8 <MODE2ISR+0xb98>
   117b0:	e3530059 	cmp	r3, #89	; 0x59
   117b4:	1a000004 	bne	117cc <MODE2ISR+0xb9c>
   117b8:	e59f20ac 	ldr	r2, [pc, #172]	; 1186c <.text+0x186c>
   117bc:	e1a03800 	mov	r3, r0, lsl #16
   117c0:	e0822843 	add	r2, r2, r3, asr #16
   117c4:	e3a0300a 	mov	r3, #10	; 0xa
   117c8:	e5423200 	strb	r3, [r2, #-512]
   117cc:	e2803001 	add	r3, r0, #1	; 0x1
   117d0:	e1a03803 	mov	r3, r3, lsl #16
   117d4:	e1a03823 	mov	r3, r3, lsr #16
   117d8:	e59f1080 	ldr	r1, [pc, #128]	; 11860 <.text+0x1860>
   117dc:	e3530b01 	cmp	r3, #1024	; 0x400
   117e0:	e1c130b0 	strh	r3, [r1]
   117e4:	059f3070 	ldreq	r3, [pc, #112]	; 1185c <.text+0x185c>
   117e8:	03a02001 	moveq	r2, #1	; 0x1
   117ec:	03a0c000 	moveq	ip, #0	; 0x0
   117f0:	05c32000 	streqb	r2, [r3]
   117f4:	01c1c0b0 	streqh	ip, [r1]
   117f8:	e3a02000 	mov	r2, #0	; 0x0
   117fc:	e3e03000 	mvn	r3, #0	; 0x0
   11800:	e5032fcf 	str	r2, [r3, #-4047]
   11804:	e28dd038 	add	sp, sp, #56	; 0x38
   11808:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   1180c:	e12fff1e 	bx	lr
   11810:	e0004000 	and	r4, r0, r0
   11814:	40000004 	andmi	r0, r0, r4
   11818:	e0060000 	and	r0, r6, r0
   1181c:	0020ff08 	eoreq	pc, r0, r8, lsl #30
   11820:	40000005 	andmi	r0, r0, r5
   11824:	0000ffc0 	andeq	pc, r0, r0, asr #31
   11828:	40000006 	andmi	r0, r0, r6
   1182c:	e0034000 	and	r4, r3, r0
   11830:	40000007 	andmi	r0, r0, r7
   11834:	0020ff04 	eoreq	pc, r0, r4, lsl #30
   11838:	40000008 	andmi	r0, r0, r8
   1183c:	0020ff02 	eoreq	pc, r0, r2, lsl #30
   11840:	40000009 	andmi	r0, r0, r9
   11844:	4000000a 	andmi	r0, r0, sl
   11848:	0020ff10 	eoreq	pc, r0, r0, lsl pc
   1184c:	4000000b 	andmi	r0, r0, fp
   11850:	0020ff80 	eoreq	pc, r0, r0, lsl #31
   11854:	4000000c 	andmi	r0, r0, ip
   11858:	0020ff40 	eoreq	pc, r0, r0, asr #30
   1185c:	400008a5 	andmi	r0, r0, r5, lsr #17
   11860:	400008a6 	andmi	r0, r0, r6, lsr #17
   11864:	400008a4 	andmi	r0, r0, r4, lsr #17
   11868:	400010d0 	ldrmid	r1, [r0], -r0
   1186c:	40000dd0 	ldrmid	r0, [r0], -r0

00011870 <Log_init>:
   11870:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11874:	e59f0580 	ldr	r0, [pc, #1408]	; 11dfc <.text+0x1dfc>
   11878:	eb000409 	bl	128a4 <root_file_exists>
   1187c:	e3500000 	cmp	r0, #0	; 0x0
   11880:	e59f5578 	ldr	r5, [pc, #1400]	; 11e00 <.text+0x1e00>
   11884:	0a00000f 	beq	118c8 <Log_init+0x58>
   11888:	e59f056c 	ldr	r0, [pc, #1388]	; 11dfc <.text+0x1dfc>
   1188c:	eb0004ce 	bl	12bcc <root_open>
   11890:	e59f456c 	ldr	r4, [pc, #1388]	; 11e04 <.text+0x1e04>
   11894:	e3a02c02 	mov	r2, #512	; 0x200
   11898:	e1a01004 	mov	r1, r4
   1189c:	e5850000 	str	r0, [r5]
   118a0:	eb000980 	bl	13ea8 <fat16_read_file>
   118a4:	e1a02800 	mov	r2, r0, lsl #16
   118a8:	e1a02842 	mov	r2, r2, asr #16
   118ac:	e3a03000 	mov	r3, #0	; 0x0
   118b0:	e7c43002 	strb	r3, [r4, r2]
   118b4:	e59f354c 	ldr	r3, [pc, #1356]	; 11e08 <.text+0x1e08>
   118b8:	e5950000 	ldr	r0, [r5]
   118bc:	e5832000 	str	r2, [r3]
   118c0:	eb000cbf 	bl	14bc4 <fat16_close_file>
   118c4:	ea000025 	b	11960 <Log_init+0xf0>
   118c8:	e59f052c 	ldr	r0, [pc, #1324]	; 11dfc <.text+0x1dfc>
   118cc:	eb0004c9 	bl	12bf8 <root_open_new>
   118d0:	e3500000 	cmp	r0, #0	; 0x0
   118d4:	e5850000 	str	r0, [r5]
   118d8:	1a000012 	bne	11928 <Log_init+0xb8>
   118dc:	e59f0528 	ldr	r0, [pc, #1320]	; 11e0c <.text+0x1e0c>
   118e0:	eb000215 	bl	1213c <rprintf>
   118e4:	e3a01001 	mov	r1, #1	; 0x1
   118e8:	e3a00000 	mov	r0, #0	; 0x0
   118ec:	ebfffaf7 	bl	104d0 <stat>
   118f0:	e3a00032 	mov	r0, #50	; 0x32
   118f4:	ebfffb1b 	bl	10568 <delay_ms>
   118f8:	e3a00000 	mov	r0, #0	; 0x0
   118fc:	e1a01000 	mov	r1, r0
   11900:	ebfffaf2 	bl	104d0 <stat>
   11904:	e3a00001 	mov	r0, #1	; 0x1
   11908:	e1a01000 	mov	r1, r0
   1190c:	ebfffaef 	bl	104d0 <stat>
   11910:	e3a00032 	mov	r0, #50	; 0x32
   11914:	ebfffb13 	bl	10568 <delay_ms>
   11918:	e3a00001 	mov	r0, #1	; 0x1
   1191c:	e3a01000 	mov	r1, #0	; 0x0
   11920:	ebfffaea 	bl	104d0 <stat>
   11924:	eaffffee 	b	118e4 <Log_init+0x74>
   11928:	e59f14e0 	ldr	r1, [pc, #1248]	; 11e10 <.text+0x1e10>
   1192c:	e59f04d0 	ldr	r0, [pc, #1232]	; 11e04 <.text+0x1e04>
   11930:	eb001739 	bl	1761c <strcpy>
   11934:	e59f04c8 	ldr	r0, [pc, #1224]	; 11e04 <.text+0x1e04>
   11938:	eb00173d 	bl	17634 <strlen>
   1193c:	e59fc4c4 	ldr	ip, [pc, #1220]	; 11e08 <.text+0x1e08>
   11940:	e1a03000 	mov	r3, r0
   11944:	e1a02800 	mov	r2, r0, lsl #16
   11948:	e1a02822 	mov	r2, r2, lsr #16
   1194c:	e59f14b0 	ldr	r1, [pc, #1200]	; 11e04 <.text+0x1e04>
   11950:	e58c3000 	str	r3, [ip]
   11954:	e5950000 	ldr	r0, [r5]
   11958:	eb000c0e 	bl	14998 <fat16_write_file>
   1195c:	eb0006cf 	bl	134a0 <sd_raw_sync>
   11960:	e3a07000 	mov	r7, #0	; 0x0
   11964:	e59f5498 	ldr	r5, [pc, #1176]	; 11e04 <.text+0x1e04>
   11968:	e1a08007 	mov	r8, r7
   1196c:	e1a06007 	mov	r6, r7
   11970:	e1a04007 	mov	r4, r7
   11974:	ea0000c6 	b	11c94 <Log_init+0x424>
   11978:	e5d51000 	ldrb	r1, [r5]
   1197c:	e351000a 	cmp	r1, #10	; 0xa
   11980:	1a0000c1 	bne	11c8c <Log_init+0x41c>
   11984:	e2866001 	add	r6, r6, #1	; 0x1
   11988:	e3560001 	cmp	r6, #1	; 0x1
   1198c:	1a000007 	bne	119b0 <Log_init+0x140>
   11990:	e5553002 	ldrb	r3, [r5, #-2]
   11994:	e2433030 	sub	r3, r3, #48	; 0x30
   11998:	e20330ff 	and	r3, r3, #255	; 0xff
   1199c:	e59f2470 	ldr	r2, [pc, #1136]	; 11e14 <.text+0x1e14>
   119a0:	e59f0470 	ldr	r0, [pc, #1136]	; 11e18 <.text+0x1e18>
   119a4:	e1a01003 	mov	r1, r3
   119a8:	e5c23000 	strb	r3, [r2]
   119ac:	ea0000b5 	b	11c88 <Log_init+0x418>
   119b0:	e3560002 	cmp	r6, #2	; 0x2
   119b4:	05552002 	ldreqb	r2, [r5, #-2]
   119b8:	059f045c 	ldreq	r0, [pc, #1116]	; 11e1c <.text+0x1e1c>
   119bc:	059f345c 	ldreq	r3, [pc, #1116]	; 11e20 <.text+0x1e20>
   119c0:	01a01002 	moveq	r1, r2
   119c4:	0a000043 	beq	11ad8 <Log_init+0x268>
   119c8:	e3560003 	cmp	r6, #3	; 0x3
   119cc:	1a00001e 	bne	11a4c <Log_init+0x1dc>
   119d0:	e5553002 	ldrb	r3, [r5, #-2]
   119d4:	e3530031 	cmp	r3, #49	; 0x31
   119d8:	03a02e4b 	moveq	r2, #1200	; 0x4b0
   119dc:	0a000014 	beq	11a34 <Log_init+0x1c4>
   119e0:	e3530032 	cmp	r3, #50	; 0x32
   119e4:	03a02e96 	moveq	r2, #2400	; 0x960
   119e8:	0a000011 	beq	11a34 <Log_init+0x1c4>
   119ec:	e3530033 	cmp	r3, #51	; 0x33
   119f0:	03a02d4b 	moveq	r2, #4800	; 0x12c0
   119f4:	0a00000e 	beq	11a34 <Log_init+0x1c4>
   119f8:	e3530034 	cmp	r3, #52	; 0x34
   119fc:	03a02d96 	moveq	r2, #9600	; 0x2580
   11a00:	0a00000b 	beq	11a34 <Log_init+0x1c4>
   11a04:	e3530035 	cmp	r3, #53	; 0x35
   11a08:	03a02c4b 	moveq	r2, #19200	; 0x4b00
   11a0c:	0a000008 	beq	11a34 <Log_init+0x1c4>
   11a10:	e3530036 	cmp	r3, #54	; 0x36
   11a14:	03a02c96 	moveq	r2, #38400	; 0x9600
   11a18:	0a000005 	beq	11a34 <Log_init+0x1c4>
   11a1c:	e3530037 	cmp	r3, #55	; 0x37
   11a20:	03a02ce1 	moveq	r2, #57600	; 0xe100
   11a24:	0a000002 	beq	11a34 <Log_init+0x1c4>
   11a28:	e3530038 	cmp	r3, #56	; 0x38
   11a2c:	1a000002 	bne	11a3c <Log_init+0x1cc>
   11a30:	e59f23ec 	ldr	r2, [pc, #1004]	; 11e24 <.text+0x1e24>
   11a34:	e59f33ec 	ldr	r3, [pc, #1004]	; 11e28 <.text+0x1e28>
   11a38:	e5832000 	str	r2, [r3]
   11a3c:	e59f33e4 	ldr	r3, [pc, #996]	; 11e28 <.text+0x1e28>
   11a40:	e59f03e4 	ldr	r0, [pc, #996]	; 11e2c <.text+0x1e2c>
   11a44:	e5931000 	ldr	r1, [r3]
   11a48:	ea00008e 	b	11c88 <Log_init+0x418>
   11a4c:	e3560004 	cmp	r6, #4	; 0x4
   11a50:	1a00001a 	bne	11ac0 <Log_init+0x250>
   11a54:	e5553003 	ldrb	r3, [r5, #-3]
   11a58:	e5552002 	ldrb	r2, [r5, #-2]
   11a5c:	e0222193 	mla	r2, r3, r1, r2
   11a60:	e5551004 	ldrb	r1, [r5, #-4]
   11a64:	e59fc3c4 	ldr	ip, [pc, #964]	; 11e30 <.text+0x1e30>
   11a68:	e2413030 	sub	r3, r1, #48	; 0x30
   11a6c:	e2420e21 	sub	r0, r2, #528	; 0x210
   11a70:	e3530009 	cmp	r3, #9	; 0x9
   11a74:	e58c0000 	str	r0, [ip]
   11a78:	8a00000c 	bhi	11ab0 <Log_init+0x240>
   11a7c:	e3a03064 	mov	r3, #100	; 0x64
   11a80:	e0030391 	mul	r3, r1, r3
   11a84:	e5551005 	ldrb	r1, [r5, #-5]
   11a88:	e2433d4b 	sub	r3, r3, #4800	; 0x12c0
   11a8c:	e2412030 	sub	r2, r1, #48	; 0x30
   11a90:	e0803003 	add	r3, r0, r3
   11a94:	e3520009 	cmp	r2, #9	; 0x9
   11a98:	e58c3000 	str	r3, [ip]
   11a9c:	92433cbb 	subls	r3, r3, #47872	; 0xbb00
   11aa0:	92433080 	subls	r3, r3, #128	; 0x80
   11aa4:	93a02ffa 	movls	r2, #1000	; 0x3e8
   11aa8:	90233291 	mlals	r3, r1, r2, r3
   11aac:	958c3000 	strls	r3, [ip]
   11ab0:	e59f3378 	ldr	r3, [pc, #888]	; 11e30 <.text+0x1e30>
   11ab4:	e59f0378 	ldr	r0, [pc, #888]	; 11e34 <.text+0x1e34>
   11ab8:	e5931000 	ldr	r1, [r3]
   11abc:	ea000071 	b	11c88 <Log_init+0x418>
   11ac0:	e3560005 	cmp	r6, #5	; 0x5
   11ac4:	1a000005 	bne	11ae0 <Log_init+0x270>
   11ac8:	e5552002 	ldrb	r2, [r5, #-2]
   11acc:	e59f0364 	ldr	r0, [pc, #868]	; 11e38 <.text+0x1e38>
   11ad0:	e59f3364 	ldr	r3, [pc, #868]	; 11e3c <.text+0x1e3c>
   11ad4:	e1a01002 	mov	r1, r2
   11ad8:	e5c32000 	strb	r2, [r3]
   11adc:	ea000069 	b	11c88 <Log_init+0x418>
   11ae0:	e3560006 	cmp	r6, #6	; 0x6
   11ae4:	1a000012 	bne	11b34 <Log_init+0x2c4>
   11ae8:	e5552002 	ldrb	r2, [r5, #-2]
   11aec:	e5553003 	ldrb	r3, [r5, #-3]
   11af0:	e0212193 	mla	r1, r3, r1, r2
   11af4:	e5552004 	ldrb	r2, [r5, #-4]
   11af8:	e3a03064 	mov	r3, #100	; 0x64
   11afc:	e0231392 	mla	r3, r2, r3, r1
   11b00:	e2433d53 	sub	r3, r3, #5312	; 0x14c0
   11b04:	e2433010 	sub	r3, r3, #16	; 0x10
   11b08:	e1a03803 	mov	r3, r3, lsl #16
   11b0c:	e59f032c 	ldr	r0, [pc, #812]	; 11e40 <.text+0x1e40>
   11b10:	e1a03823 	mov	r3, r3, lsr #16
   11b14:	e59f1328 	ldr	r1, [pc, #808]	; 11e44 <.text+0x1e44>
   11b18:	e1a02803 	mov	r2, r3, lsl #16
   11b1c:	e1500842 	cmp	r0, r2, asr #16
   11b20:	e1c130b0 	strh	r3, [r1]
   11b24:	b1c100b0 	strlth	r0, [r1]
   11b28:	e59f0318 	ldr	r0, [pc, #792]	; 11e48 <.text+0x1e48>
   11b2c:	e1d110f0 	ldrsh	r1, [r1]
   11b30:	ea000054 	b	11c88 <Log_init+0x418>
   11b34:	e3560007 	cmp	r6, #7	; 0x7
   11b38:	1a000007 	bne	11b5c <Log_init+0x2ec>
   11b3c:	e5551002 	ldrb	r1, [r5, #-2]
   11b40:	e59f3304 	ldr	r3, [pc, #772]	; 11e4c <.text+0x1e4c>
   11b44:	e3510059 	cmp	r1, #89	; 0x59
   11b48:	e5c31000 	strb	r1, [r3]
   11b4c:	e59f02fc 	ldr	r0, [pc, #764]	; 11e50 <.text+0x1e50>
   11b50:	02843001 	addeq	r3, r4, #1	; 0x1
   11b54:	020340ff 	andeq	r4, r3, #255	; 0xff
   11b58:	ea00004a 	b	11c88 <Log_init+0x418>
   11b5c:	e3560008 	cmp	r6, #8	; 0x8
   11b60:	1a000007 	bne	11b84 <Log_init+0x314>
   11b64:	e5551002 	ldrb	r1, [r5, #-2]
   11b68:	e59f32e4 	ldr	r3, [pc, #740]	; 11e54 <.text+0x1e54>
   11b6c:	e3510059 	cmp	r1, #89	; 0x59
   11b70:	e5c31000 	strb	r1, [r3]
   11b74:	e59f02dc 	ldr	r0, [pc, #732]	; 11e58 <.text+0x1e58>
   11b78:	02843001 	addeq	r3, r4, #1	; 0x1
   11b7c:	020340ff 	andeq	r4, r3, #255	; 0xff
   11b80:	ea000040 	b	11c88 <Log_init+0x418>
   11b84:	e3560009 	cmp	r6, #9	; 0x9
   11b88:	1a000007 	bne	11bac <Log_init+0x33c>
   11b8c:	e5551002 	ldrb	r1, [r5, #-2]
   11b90:	e59f32c4 	ldr	r3, [pc, #708]	; 11e5c <.text+0x1e5c>
   11b94:	e3510059 	cmp	r1, #89	; 0x59
   11b98:	e5c31000 	strb	r1, [r3]
   11b9c:	e59f02bc 	ldr	r0, [pc, #700]	; 11e60 <.text+0x1e60>
   11ba0:	02843001 	addeq	r3, r4, #1	; 0x1
   11ba4:	020340ff 	andeq	r4, r3, #255	; 0xff
   11ba8:	ea000036 	b	11c88 <Log_init+0x418>
   11bac:	e356000a 	cmp	r6, #10	; 0xa
   11bb0:	1a000007 	bne	11bd4 <Log_init+0x364>
   11bb4:	e5551002 	ldrb	r1, [r5, #-2]
   11bb8:	e59f32a4 	ldr	r3, [pc, #676]	; 11e64 <.text+0x1e64>
   11bbc:	e3510059 	cmp	r1, #89	; 0x59
   11bc0:	e5c31000 	strb	r1, [r3]
   11bc4:	e59f029c 	ldr	r0, [pc, #668]	; 11e68 <.text+0x1e68>
   11bc8:	02843001 	addeq	r3, r4, #1	; 0x1
   11bcc:	020340ff 	andeq	r4, r3, #255	; 0xff
   11bd0:	ea00002c 	b	11c88 <Log_init+0x418>
   11bd4:	e356000b 	cmp	r6, #11	; 0xb
   11bd8:	1a000007 	bne	11bfc <Log_init+0x38c>
   11bdc:	e5551002 	ldrb	r1, [r5, #-2]
   11be0:	e59f3284 	ldr	r3, [pc, #644]	; 11e6c <.text+0x1e6c>
   11be4:	e3510059 	cmp	r1, #89	; 0x59
   11be8:	e5c31000 	strb	r1, [r3]
   11bec:	e59f027c 	ldr	r0, [pc, #636]	; 11e70 <.text+0x1e70>
   11bf0:	02843001 	addeq	r3, r4, #1	; 0x1
   11bf4:	020340ff 	andeq	r4, r3, #255	; 0xff
   11bf8:	ea000022 	b	11c88 <Log_init+0x418>
   11bfc:	e356000c 	cmp	r6, #12	; 0xc
   11c00:	1a000007 	bne	11c24 <Log_init+0x3b4>
   11c04:	e5551002 	ldrb	r1, [r5, #-2]
   11c08:	e59f3264 	ldr	r3, [pc, #612]	; 11e74 <.text+0x1e74>
   11c0c:	e3510059 	cmp	r1, #89	; 0x59
   11c10:	e5c31000 	strb	r1, [r3]
   11c14:	e59f025c 	ldr	r0, [pc, #604]	; 11e78 <.text+0x1e78>
   11c18:	02843001 	addeq	r3, r4, #1	; 0x1
   11c1c:	020340ff 	andeq	r4, r3, #255	; 0xff
   11c20:	ea000018 	b	11c88 <Log_init+0x418>
   11c24:	e356000d 	cmp	r6, #13	; 0xd
   11c28:	1a000007 	bne	11c4c <Log_init+0x3dc>
   11c2c:	e5551002 	ldrb	r1, [r5, #-2]
   11c30:	e59f3244 	ldr	r3, [pc, #580]	; 11e7c <.text+0x1e7c>
   11c34:	e3510059 	cmp	r1, #89	; 0x59
   11c38:	e5c31000 	strb	r1, [r3]
   11c3c:	e59f023c 	ldr	r0, [pc, #572]	; 11e80 <.text+0x1e80>
   11c40:	02843001 	addeq	r3, r4, #1	; 0x1
   11c44:	020340ff 	andeq	r4, r3, #255	; 0xff
   11c48:	ea00000e 	b	11c88 <Log_init+0x418>
   11c4c:	e356000e 	cmp	r6, #14	; 0xe
   11c50:	1a000007 	bne	11c74 <Log_init+0x404>
   11c54:	e5551002 	ldrb	r1, [r5, #-2]
   11c58:	e59f3224 	ldr	r3, [pc, #548]	; 11e84 <.text+0x1e84>
   11c5c:	e3510059 	cmp	r1, #89	; 0x59
   11c60:	e5c31000 	strb	r1, [r3]
   11c64:	e59f021c 	ldr	r0, [pc, #540]	; 11e88 <.text+0x1e88>
   11c68:	02843001 	addeq	r3, r4, #1	; 0x1
   11c6c:	020340ff 	andeq	r4, r3, #255	; 0xff
   11c70:	ea000004 	b	11c88 <Log_init+0x418>
   11c74:	e356000f 	cmp	r6, #15	; 0xf
   11c78:	1a000003 	bne	11c8c <Log_init+0x41c>
   11c7c:	e5558002 	ldrb	r8, [r5, #-2]
   11c80:	e59f0204 	ldr	r0, [pc, #516]	; 11e8c <.text+0x1e8c>
   11c84:	e1a01008 	mov	r1, r8
   11c88:	eb00012b 	bl	1213c <rprintf>
   11c8c:	e2877001 	add	r7, r7, #1	; 0x1
   11c90:	e2855001 	add	r5, r5, #1	; 0x1
   11c94:	e59f316c 	ldr	r3, [pc, #364]	; 11e08 <.text+0x1e08>
   11c98:	e5933000 	ldr	r3, [r3]
   11c9c:	e1570003 	cmp	r7, r3
   11ca0:	baffff34 	blt	11978 <Log_init+0x108>
   11ca4:	e3580059 	cmp	r8, #89	; 0x59
   11ca8:	1a00004d 	bne	11de4 <Log_init+0x574>
   11cac:	e354000a 	cmp	r4, #10	; 0xa
   11cb0:	1a000005 	bne	11ccc <Log_init+0x45c>
   11cb4:	e59f2174 	ldr	r2, [pc, #372]	; 11e30 <.text+0x1e30>
   11cb8:	e5923000 	ldr	r3, [r2]
   11cbc:	e3530096 	cmp	r3, #150	; 0x96
   11cc0:	c3a03096 	movgt	r3, #150	; 0x96
   11cc4:	ca000007 	bgt	11ce8 <Log_init+0x478>
   11cc8:	ea000049 	b	11df4 <Log_init+0x584>
   11ccc:	e3540009 	cmp	r4, #9	; 0x9
   11cd0:	1a000006 	bne	11cf0 <Log_init+0x480>
   11cd4:	e59f2154 	ldr	r2, [pc, #340]	; 11e30 <.text+0x1e30>
   11cd8:	e5923000 	ldr	r3, [r2]
   11cdc:	e35300a6 	cmp	r3, #166	; 0xa6
   11ce0:	da000043 	ble	11df4 <Log_init+0x584>
   11ce4:	e3a030a6 	mov	r3, #166	; 0xa6
   11ce8:	e5823000 	str	r3, [r2]
   11cec:	ea000040 	b	11df4 <Log_init+0x584>
   11cf0:	e3540008 	cmp	r4, #8	; 0x8
   11cf4:	1a000005 	bne	11d10 <Log_init+0x4a0>
   11cf8:	e59f2130 	ldr	r2, [pc, #304]	; 11e30 <.text+0x1e30>
   11cfc:	e5923000 	ldr	r3, [r2]
   11d00:	e35300bb 	cmp	r3, #187	; 0xbb
   11d04:	c3a030bb 	movgt	r3, #187	; 0xbb
   11d08:	cafffff6 	bgt	11ce8 <Log_init+0x478>
   11d0c:	ea000038 	b	11df4 <Log_init+0x584>
   11d10:	e3540007 	cmp	r4, #7	; 0x7
   11d14:	1a000005 	bne	11d30 <Log_init+0x4c0>
   11d18:	e59f2110 	ldr	r2, [pc, #272]	; 11e30 <.text+0x1e30>
   11d1c:	e5923000 	ldr	r3, [r2]
   11d20:	e35300d6 	cmp	r3, #214	; 0xd6
   11d24:	c3a030d6 	movgt	r3, #214	; 0xd6
   11d28:	caffffee 	bgt	11ce8 <Log_init+0x478>
   11d2c:	ea000030 	b	11df4 <Log_init+0x584>
   11d30:	e3540006 	cmp	r4, #6	; 0x6
   11d34:	1a000005 	bne	11d50 <Log_init+0x4e0>
   11d38:	e59f20f0 	ldr	r2, [pc, #240]	; 11e30 <.text+0x1e30>
   11d3c:	e5923000 	ldr	r3, [r2]
   11d40:	e35300fa 	cmp	r3, #250	; 0xfa
   11d44:	c3a030fa 	movgt	r3, #250	; 0xfa
   11d48:	caffffe6 	bgt	11ce8 <Log_init+0x478>
   11d4c:	ea000028 	b	11df4 <Log_init+0x584>
   11d50:	e3540005 	cmp	r4, #5	; 0x5
   11d54:	1a000005 	bne	11d70 <Log_init+0x500>
   11d58:	e59f20d0 	ldr	r2, [pc, #208]	; 11e30 <.text+0x1e30>
   11d5c:	e5923000 	ldr	r3, [r2]
   11d60:	e3530f4b 	cmp	r3, #300	; 0x12c
   11d64:	c3a03f4b 	movgt	r3, #300	; 0x12c
   11d68:	caffffde 	bgt	11ce8 <Log_init+0x478>
   11d6c:	ea000020 	b	11df4 <Log_init+0x584>
   11d70:	e3540004 	cmp	r4, #4	; 0x4
   11d74:	059f10b4 	ldreq	r1, [pc, #180]	; 11e30 <.text+0x1e30>
   11d78:	059f2110 	ldreq	r2, [pc, #272]	; 11e90 <.text+0x1e90>
   11d7c:	0a00000f 	beq	11dc0 <Log_init+0x550>
   11d80:	e3540003 	cmp	r4, #3	; 0x3
   11d84:	1a000005 	bne	11da0 <Log_init+0x530>
   11d88:	e59f20a0 	ldr	r2, [pc, #160]	; 11e30 <.text+0x1e30>
   11d8c:	e5923000 	ldr	r3, [r2]
   11d90:	e3530f7d 	cmp	r3, #500	; 0x1f4
   11d94:	c3a03f7d 	movgt	r3, #500	; 0x1f4
   11d98:	caffffd2 	bgt	11ce8 <Log_init+0x478>
   11d9c:	ea000014 	b	11df4 <Log_init+0x584>
   11da0:	e3540002 	cmp	r4, #2	; 0x2
   11da4:	059f1084 	ldreq	r1, [pc, #132]	; 11e30 <.text+0x1e30>
   11da8:	059f20e4 	ldreq	r2, [pc, #228]	; 11e94 <.text+0x1e94>
   11dac:	0a000003 	beq	11dc0 <Log_init+0x550>
   11db0:	e3540001 	cmp	r4, #1	; 0x1
   11db4:	1a000005 	bne	11dd0 <Log_init+0x560>
   11db8:	e59f1070 	ldr	r1, [pc, #112]	; 11e30 <.text+0x1e30>
   11dbc:	e59f20d4 	ldr	r2, [pc, #212]	; 11e98 <.text+0x1e98>
   11dc0:	e5913000 	ldr	r3, [r1]
   11dc4:	e1530002 	cmp	r3, r2
   11dc8:	c5812000 	strgt	r2, [r1]
   11dcc:	ea000008 	b	11df4 <Log_init+0x584>
   11dd0:	e3540000 	cmp	r4, #0	; 0x0
   11dd4:	059f3054 	ldreq	r3, [pc, #84]	; 11e30 <.text+0x1e30>
   11dd8:	03a02064 	moveq	r2, #100	; 0x64
   11ddc:	05832000 	streq	r2, [r3]
   11de0:	ea000003 	b	11df4 <Log_init+0x584>
   11de4:	e3580054 	cmp	r8, #84	; 0x54
   11de8:	1a000001 	bne	11df4 <Log_init+0x584>
   11dec:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   11df0:	eafffa0f 	b	10634 <test>
   11df4:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   11df8:	e12fff1e 	bx	lr
   11dfc:	00017fd8 	ldreqd	r7, [r1], -r8
   11e00:	400012d0 	ldrmid	r1, [r0], -r0
   11e04:	40000fd0 	ldrmid	r0, [r0], -r0
   11e08:	400012d8 	ldrmid	r1, [r0], -r8
   11e0c:	00017fe4 	andeq	r7, r1, r4, ror #31
   11e10:	00018010 	andeq	r8, r1, r0, lsl r0
   11e14:	400008a9 	andmi	r0, r0, r9, lsr #17
   11e18:	000180d4 	ldreqd	r8, [r1], -r4
   11e1c:	000180e0 	andeq	r8, r1, r0, ror #1
   11e20:	40000005 	andmi	r0, r0, r5
   11e24:	0001c200 	andeq	ip, r1, r0, lsl #4
   11e28:	40000010 	andmi	r0, r0, r0, lsl r0
   11e2c:	000180ec 	andeq	r8, r1, ip, ror #1
   11e30:	40000000 	andmi	r0, r0, r0
   11e34:	000180f8 	streqd	r8, [r1], -r8
   11e38:	00018104 	andeq	r8, r1, r4, lsl #2
   11e3c:	40000016 	andmi	r0, r0, r6, lsl r0
   11e40:	000001fe 	streqd	r0, [r0], -lr
   11e44:	40000014 	andmi	r0, r0, r4, lsl r0
   11e48:	00018110 	andeq	r8, r1, r0, lsl r1
   11e4c:	40000004 	andmi	r0, r0, r4
   11e50:	00018120 	andeq	r8, r1, r0, lsr #2
   11e54:	40000006 	andmi	r0, r0, r6
   11e58:	00018130 	andeq	r8, r1, r0, lsr r1
   11e5c:	40000007 	andmi	r0, r0, r7
   11e60:	00018140 	andeq	r8, r1, r0, asr #2
   11e64:	40000008 	andmi	r0, r0, r8
   11e68:	00018150 	andeq	r8, r1, r0, asr r1
   11e6c:	40000009 	andmi	r0, r0, r9
   11e70:	00018160 	andeq	r8, r1, r0, ror #2
   11e74:	4000000a 	andmi	r0, r0, sl
   11e78:	00018170 	andeq	r8, r1, r0, ror r1
   11e7c:	4000000b 	andmi	r0, r0, fp
   11e80:	00018180 	andeq	r8, r1, r0, lsl #3
   11e84:	4000000c 	andmi	r0, r0, ip
   11e88:	00018190 	muleq	r1, r0, r1
   11e8c:	000181a0 	andeq	r8, r1, r0, lsr #3
   11e90:	00000177 	andeq	r0, r0, r7, ror r1
   11e94:	000002ee 	andeq	r0, r0, lr, ror #5
   11e98:	000005dc 	ldreqd	r0, [r0], -ip

00011e9c <Initialize>:
   11e9c:	e52de004 	str	lr, [sp, #-4]!
   11ea0:	e59f004c 	ldr	r0, [pc, #76]	; 11ef4 <.text+0x1ef4>
   11ea4:	eb000090 	bl	120ec <rprintf_devopen>
   11ea8:	e59f2048 	ldr	r2, [pc, #72]	; 11ef8 <.text+0x1ef8>
   11eac:	e59f3048 	ldr	r3, [pc, #72]	; 11efc <.text+0x1efc>
   11eb0:	e5823000 	str	r3, [r2]
   11eb4:	e59f3044 	ldr	r3, [pc, #68]	; 11f00 <.text+0x1f00>
   11eb8:	e5823004 	str	r3, [r2, #4]
   11ebc:	e2422901 	sub	r2, r2, #16384	; 0x4000
   11ec0:	e5923008 	ldr	r3, [r2, #8]
   11ec4:	e3833d22 	orr	r3, r3, #2176	; 0x880
   11ec8:	e3833004 	orr	r3, r3, #4	; 0x4
   11ecc:	e5823008 	str	r3, [r2, #8]
   11ed0:	e59f102c 	ldr	r1, [pc, #44]	; 11f04 <.text+0x1f04>
   11ed4:	e3a03080 	mov	r3, #128	; 0x80
   11ed8:	e5823004 	str	r3, [r2, #4]
   11edc:	e3a03008 	mov	r3, #8	; 0x8
   11ee0:	e5c13000 	strb	r3, [r1]
   11ee4:	e2833028 	add	r3, r3, #40	; 0x28
   11ee8:	e5c13000 	strb	r3, [r1]
   11eec:	e49de004 	ldr	lr, [sp], #4
   11ef0:	e12fff1e 	bx	lr
   11ef4:	00012764 	andeq	r2, r1, r4, ror #14
   11ef8:	e002c000 	and	ip, r2, r0
   11efc:	cf351505 	svcgt	0x00351505
   11f00:	15441801 	strneb	r1, [r4, #-2049]
   11f04:	e0020000 	and	r0, r2, r0

00011f08 <main>:
   11f08:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   11f0c:	e24dd020 	sub	sp, sp, #32	; 0x20
   11f10:	eb0013da 	bl	16e80 <enableFIQ>
   11f14:	ebffffe0 	bl	11e9c <Initialize>
   11f18:	ebfffa06 	bl	10738 <fat_initialize>
   11f1c:	e3a00d96 	mov	r0, #9600	; 0x2580
   11f20:	e3a01000 	mov	r1, #0	; 0x0
   11f24:	ebfffac1 	bl	10a30 <setup_uart0>
   11f28:	e3a04000 	mov	r4, #0	; 0x0
   11f2c:	e3a01001 	mov	r1, #1	; 0x1
   11f30:	e3a00000 	mov	r0, #0	; 0x0
   11f34:	ebfff965 	bl	104d0 <stat>
   11f38:	e3a00032 	mov	r0, #50	; 0x32
   11f3c:	ebfff989 	bl	10568 <delay_ms>
   11f40:	e3a00000 	mov	r0, #0	; 0x0
   11f44:	e1a01000 	mov	r1, r0
   11f48:	ebfff960 	bl	104d0 <stat>
   11f4c:	e3a00001 	mov	r0, #1	; 0x1
   11f50:	e1a01000 	mov	r1, r0
   11f54:	ebfff95d 	bl	104d0 <stat>
   11f58:	e3a00032 	mov	r0, #50	; 0x32
   11f5c:	ebfff981 	bl	10568 <delay_ms>
   11f60:	e2844001 	add	r4, r4, #1	; 0x1
   11f64:	e3a00001 	mov	r0, #1	; 0x1
   11f68:	e3a01000 	mov	r1, #0	; 0x0
   11f6c:	ebfff957 	bl	104d0 <stat>
   11f70:	e3540005 	cmp	r4, #5	; 0x5
   11f74:	1affffec 	bne	11f2c <main+0x24>
   11f78:	eb000221 	bl	12804 <SPI1_Init>
   11f7c:	e3a000aa 	mov	r0, #170	; 0xaa
   11f80:	eb000237 	bl	12864 <SPI1_Write>
   11f84:	e3a00055 	mov	r0, #85	; 0x55
   11f88:	eb000235 	bl	12864 <SPI1_Write>
   11f8c:	ebfffe37 	bl	11870 <Log_init>
   11f90:	e1a0000d 	mov	r0, sp
   11f94:	e59f10d8 	ldr	r1, [pc, #216]	; 12074 <.text+0x2074>
   11f98:	e3a02001 	mov	r2, #1	; 0x1
   11f9c:	eb000110 	bl	123e4 <string_printf>
   11fa0:	e3a05001 	mov	r5, #1	; 0x1
   11fa4:	ea000015 	b	12000 <main+0xf8>
   11fa8:	e35500fa 	cmp	r5, #250	; 0xfa
   11fac:	1a000012 	bne	11ffc <main+0xf4>
   11fb0:	e59f00c0 	ldr	r0, [pc, #192]	; 12078 <.text+0x2078>
   11fb4:	eb000060 	bl	1213c <rprintf>
   11fb8:	e3a00000 	mov	r0, #0	; 0x0
   11fbc:	e3a01001 	mov	r1, #1	; 0x1
   11fc0:	ebfff942 	bl	104d0 <stat>
   11fc4:	e3a00001 	mov	r0, #1	; 0x1
   11fc8:	e1a01000 	mov	r1, r0
   11fcc:	ebfff93f 	bl	104d0 <stat>
   11fd0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
   11fd4:	ebfff963 	bl	10568 <delay_ms>
   11fd8:	e3a00000 	mov	r0, #0	; 0x0
   11fdc:	e1a01000 	mov	r1, r0
   11fe0:	ebfff93a 	bl	104d0 <stat>
   11fe4:	e3a00001 	mov	r0, #1	; 0x1
   11fe8:	e3a01000 	mov	r1, #0	; 0x0
   11fec:	ebfff937 	bl	104d0 <stat>
   11ff0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
   11ff4:	ebfff95b 	bl	10568 <delay_ms>
   11ff8:	eaffffee 	b	11fb8 <main+0xb0>
   11ffc:	eb0000f8 	bl	123e4 <string_printf>
   12000:	e1a0000d 	mov	r0, sp
   12004:	eb000226 	bl	128a4 <root_file_exists>
   12008:	e2855001 	add	r5, r5, #1	; 0x1
   1200c:	e3500000 	cmp	r0, #0	; 0x0
   12010:	e1a0400d 	mov	r4, sp
   12014:	e59f1060 	ldr	r1, [pc, #96]	; 1207c <.text+0x207c>
   12018:	e1a02005 	mov	r2, r5
   1201c:	e1a0000d 	mov	r0, sp
   12020:	1affffe0 	bne	11fa8 <main+0xa0>
   12024:	eb0002f3 	bl	12bf8 <root_open_new>
   12028:	e59f3050 	ldr	r3, [pc, #80]	; 12080 <.text+0x2080>
   1202c:	e5830000 	str	r0, [r3]
   12030:	eb00051a 	bl	134a0 <sd_raw_sync>
   12034:	e59f3048 	ldr	r3, [pc, #72]	; 12084 <.text+0x2084>
   12038:	e5d33000 	ldrb	r3, [r3]
   1203c:	e3530000 	cmp	r3, #0	; 0x0
   12040:	1a000001 	bne	1204c <main+0x144>
   12044:	ebfffaea 	bl	10bf4 <mode_0>
   12048:	ea000005 	b	12064 <main+0x15c>
   1204c:	e3530001 	cmp	r3, #1	; 0x1
   12050:	1a000001 	bne	1205c <main+0x154>
   12054:	ebfffad4 	bl	10bac <mode_1>
   12058:	ea000001 	b	12064 <main+0x15c>
   1205c:	e3530002 	cmp	r3, #2	; 0x2
   12060:	0bfffa4b 	bleq	10994 <mode_2>
   12064:	e3a00000 	mov	r0, #0	; 0x0
   12068:	e28dd020 	add	sp, sp, #32	; 0x20
   1206c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12070:	e12fff1e 	bx	lr
   12074:	000181b0 	streqh	r8, [r1], -r0
   12078:	000181c4 	andeq	r8, r1, r4, asr #3
   1207c:	000181d8 	ldreqd	r8, [r1], -r8
   12080:	400012d4 	ldrmid	r1, [r0], -r4
   12084:	400008a9 	andmi	r0, r0, r9, lsr #17

00012088 <_read_r>:
	}
*/
//	return len - i;
	return 0;
}
   12088:	e3a00000 	mov	r0, #0	; 0x0
   1208c:	e12fff1e 	bx	lr

00012090 <_write_r>:

_ssize_t _write_r (
    struct _reent *r, 
    int file, 
    const void *ptr, 
    size_t len)
{
/*
	int i;
	const unsigned char *p;
	
	p = (const unsigned char*) ptr;
	
	for (i = 0; i < len; i++) {
		if (*p == '\n' ) uart0Putch('\r');
		uart0Putch(*p++);
	}
*/
	return len;
}
   12090:	e1a00003 	mov	r0, r3
   12094:	e12fff1e 	bx	lr

00012098 <_close_r>:

int _close_r(
    struct _reent *r, 
    int file)
{
	return 0;
}
   12098:	e3a00000 	mov	r0, #0	; 0x0
   1209c:	e12fff1e 	bx	lr

000120a0 <_lseek_r>:

_off_t _lseek_r(
    struct _reent *r, 
    int file, 
    _off_t ptr, 
    int dir)
{
	return (_off_t)0;	/*  Always indicate we are at file beginning.	*/
}
   120a0:	e3a00000 	mov	r0, #0	; 0x0
   120a4:	e12fff1e 	bx	lr

000120a8 <_fstat_r>:


int _fstat_r(
    struct _reent *r, 
    int file, 
    struct stat *st)
{
	/*  Always set as character device.				*/
	st->st_mode = S_IFCHR;	
   120a8:	e3a03a02 	mov	r3, #8192	; 0x2000
		/* assigned to strong type with implicit 	*/
		/* signed/unsigned conversion.  Required by 	*/
		/* newlib.					*/

	return 0;
}
   120ac:	e3a00000 	mov	r0, #0	; 0x0
   120b0:	e5823004 	str	r3, [r2, #4]
   120b4:	e12fff1e 	bx	lr

000120b8 <isatty>:

int isatty(int file); /* avoid warning */

int isatty(int file)
{
	return 1;
}
   120b8:	e3a00001 	mov	r0, #1	; 0x1
   120bc:	e12fff1e 	bx	lr

000120c0 <_sbrk_r>:

#if 0
static void _exit (int n) {
label:  goto label; /* endless loop */
}
#endif 

/* "malloc clue function" */

	/**** Locally used variables. ****/
extern char end[];              /*  end is set in the linker command 	*/
				/* file and is the end of statically 	*/
				/* allocated data (thus start of heap).	*/

static char *heap_ptr;		/* Points to current end of the heap.	*/

/************************** _sbrk_r *************************************/
/*  Support function.  Adjusts end of heap to provide more memory to	*/
/* memory allocator. Simple and dumb with no sanity checks.		*/
/*  struct _reent *r	-- re-entrancy structure, used by newlib to 	*/
/*			support multiple threads of operation.		*/
/*  ptrdiff_t nbytes	-- number of bytes to add.			*/
/*  Returns pointer to start of new heap area.				*/
/*  Note:  This implementation is not thread safe (despite taking a	*/
/* _reent structure as a parameter).  					*/
/*  Since _s_r is not used in the current implementation, the following	*/
/* messages must be suppressed.						*/

void * _sbrk_r(
    struct _reent *_s_r, 
    ptrdiff_t nbytes)
{
	char  *base;		/*  errno should be set to  ENOMEM on error	*/

	if (!heap_ptr) {	/*  Initialize if first time through.		*/
   120c0:	e59f201c 	ldr	r2, [pc, #28]	; 120e4 <.text+0x20e4>
   120c4:	e5923000 	ldr	r3, [r2]
   120c8:	e3530000 	cmp	r3, #0	; 0x0
		heap_ptr = end;
   120cc:	059f3014 	ldreq	r3, [pc, #20]	; 120e8 <.text+0x20e8>
   120d0:	05823000 	streq	r3, [r2]
	}
	base = heap_ptr;	/*  Point to end of heap.			*/
   120d4:	e5920000 	ldr	r0, [r2]
	heap_ptr += nbytes;	/*  Increase heap.				*/
   120d8:	e0803001 	add	r3, r0, r1
   120dc:	e5823000 	str	r3, [r2]
	
	return base;		/*  Return pointer to start of new heap area.	*/
}
   120e0:	e12fff1e 	bx	lr
   120e4:	400008ac 	andmi	r0, r0, ip, lsr #17
   120e8:	40002000 	andmi	r2, r0, r0

000120ec <rprintf_devopen>:
static int (*putcharfunc)(int c);

void rprintf_devopen( int(*put)(int) )
{
    putcharfunc = put;
   120ec:	e59f3004 	ldr	r3, [pc, #4]	; 120f8 <.text+0x20f8>
   120f0:	e5830000 	str	r0, [r3]
}
   120f4:	e12fff1e 	bx	lr
   120f8:	400008b0 	strmih	r0, [r0], -r0

000120fc <myputchar>:

static void myputchar(unsigned char c)
{
   120fc:	e92d4010 	stmdb	sp!, {r4, lr}
   12100:	e20040ff 	and	r4, r0, #255	; 0xff
    if(c == '\n') putcharfunc('\r');
   12104:	e354000a 	cmp	r4, #10	; 0xa
   12108:	e3a0000d 	mov	r0, #13	; 0xd
   1210c:	059f3024 	ldreq	r3, [pc, #36]	; 12138 <.text+0x2138>
   12110:	0593c000 	ldreq	ip, [r3]
   12114:	01a0e00f 	moveq	lr, pc
   12118:	012fff1c 	bxeq	ip
    putcharfunc(c);
   1211c:	e1a00004 	mov	r0, r4
   12120:	e59f3010 	ldr	r3, [pc, #16]	; 12138 <.text+0x2138>
   12124:	e593c000 	ldr	ip, [r3]
   12128:	e1a0e00f 	mov	lr, pc
   1212c:	e12fff1c 	bx	ip
}
   12130:	e8bd4010 	ldmia	sp!, {r4, lr}
   12134:	e12fff1e 	bx	lr
   12138:	400008b0 	strmih	r0, [r0], -r0

0001213c <rprintf>:

void rprintf(char const *format, ...)
{
   1213c:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
   12140:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   12144:	e24dd010 	sub	sp, sp, #16	; 0x10
    unsigned char scratch[SCRATCH];
    unsigned char format_flag;
    unsigned short base;
    unsigned char *ptr;
    unsigned char issigned=0;
    va_list ap;

    #ifdef USE_LONG
        // #warning "use long"
        unsigned char islong=0;
        unsigned long u_val=0;
        long s_val=0;
    #else
        unsigned int u_val=0;
        int s_val=0;
    #endif

    unsigned char fill;
    unsigned char width;

    va_start (ap, format);
   12148:	e28d3030 	add	r3, sp, #48	; 0x30
   1214c:	e58d300c 	str	r3, [sp, #12]
   12150:	e59d502c 	ldr	r5, [sp, #44]
    for (;;)
    {
		delay_ms(1); //Added for VCOM testing - without it, rprintf will overrun the VCOM buffer causing it to crash
   12154:	e3a00001 	mov	r0, #1	; 0x1
   12158:	ebfff902 	bl	10568 <delay_ms>
   1215c:	ea000002 	b	1216c <rprintf+0x30>
		
        while ((format_flag = *(format++)) != '%')
        {      // Until '%' or '\0'
            if (!format_flag){va_end (ap); return;}
   12160:	e3530000 	cmp	r3, #0	; 0x0
   12164:	0a00008e 	beq	123a4 <rprintf+0x268>
                myputchar(format_flag);
   12168:	ebffffe3 	bl	120fc <myputchar>
   1216c:	e4d53001 	ldrb	r3, [r5], #1
   12170:	e3530025 	cmp	r3, #37	; 0x25
   12174:	e1a00003 	mov	r0, r3
   12178:	1afffff8 	bne	12160 <rprintf+0x24>
        }

        issigned=0; //default unsigned
        base = 10;

        format_flag = *format++; //get char after '%'
   1217c:	e4d52001 	ldrb	r2, [r5], #1

        #ifdef PADDING
            width=0; //no formatting
            fill=0;  //no formatting
            if(format_flag=='0' || format_flag==' ') //SPACE or ZERO padding  ?
   12180:	e3520020 	cmp	r2, #32	; 0x20
   12184:	13520030 	cmpne	r2, #48	; 0x30
   12188:	13a03000 	movne	r3, #0	; 0x0
   1218c:	03a03001 	moveq	r3, #1	; 0x1
   12190:	11a07003 	movne	r7, r3
   12194:	11a00002 	movne	r0, r2
   12198:	11a0a007 	movne	sl, r7
   1219c:	1a000007 	bne	121c0 <rprintf+0x84>
            {
                fill=format_flag;
                format_flag = *format++; //get char after padding char
   121a0:	e4d50001 	ldrb	r0, [r5], #1
                if(format_flag>='0' && format_flag<='9')
   121a4:	e2403030 	sub	r3, r0, #48	; 0x30
   121a8:	e20370ff 	and	r7, r3, #255	; 0xff
   121ac:	e3570009 	cmp	r7, #9	; 0x9
                {
                    width=format_flag-'0';
                    format_flag = *format++; //get char after width char
   121b0:	94d50001 	ldrlsb	r0, [r5], #1
   121b4:	81a0a002 	movhi	sl, r2
   121b8:	83a07000 	movhi	r7, #0	; 0x0
   121bc:	91a0a002 	movls	sl, r2
                }
            }
        #endif

        #ifdef USE_LONG
            islong=0; //default int value
            #ifdef USE_UPPER
            if(format_flag=='l' || format_flag=='L') //Long value
   121c0:	e350004c 	cmp	r0, #76	; 0x4c
   121c4:	1350006c 	cmpne	r0, #108	; 0x6c
            #else
            if(format_flag=='l') //Long value
            #endif
        {
            islong=1;
            format_flag = *format++; //get char after 'l' or 'L'
   121c8:	04d50001 	ldreqb	r0, [r5], #1
   121cc:	13a03000 	movne	r3, #0	; 0x0
   121d0:	03a03001 	moveq	r3, #1	; 0x1
   121d4:	03a03001 	moveq	r3, #1	; 0x1
        }
        #endif

        switch (format_flag)
   121d8:	e3500058 	cmp	r0, #88	; 0x58
   121dc:	0a00003e 	beq	122dc <rprintf+0x1a0>
   121e0:	8a00000b 	bhi	12214 <rprintf+0xd8>
   121e4:	e3500049 	cmp	r0, #73	; 0x49
   121e8:	0a00006a 	beq	12398 <rprintf+0x25c>
   121ec:	8a000003 	bhi	12200 <rprintf+0xc4>
   121f0:	e3500043 	cmp	r0, #67	; 0x43
   121f4:	0a000015 	beq	12250 <rprintf+0x114>
   121f8:	e3500044 	cmp	r0, #68	; 0x44
   121fc:	ea00000a 	b	1222c <rprintf+0xf0>
   12200:	e3500053 	cmp	r0, #83	; 0x53
   12204:	0a000017 	beq	12268 <rprintf+0x12c>
   12208:	e3500055 	cmp	r0, #85	; 0x55
   1220c:	1a000013 	bne	12260 <rprintf+0x124>
   12210:	ea000020 	b	12298 <rprintf+0x15c>
   12214:	e3500069 	cmp	r0, #105	; 0x69
   12218:	0a00005e 	beq	12398 <rprintf+0x25c>
   1221c:	8a000004 	bhi	12234 <rprintf+0xf8>
   12220:	e3500063 	cmp	r0, #99	; 0x63
   12224:	0a000009 	beq	12250 <rprintf+0x114>
   12228:	e3500064 	cmp	r0, #100	; 0x64
   1222c:	1a00000b 	bne	12260 <rprintf+0x124>
   12230:	ea000058 	b	12398 <rprintf+0x25c>
   12234:	e3500075 	cmp	r0, #117	; 0x75
   12238:	0a000016 	beq	12298 <rprintf+0x15c>
   1223c:	e3500078 	cmp	r0, #120	; 0x78
   12240:	0a000025 	beq	122dc <rprintf+0x1a0>
   12244:	e3500073 	cmp	r0, #115	; 0x73
   12248:	1a000004 	bne	12260 <rprintf+0x124>
   1224c:	ea000005 	b	12268 <rprintf+0x12c>
        {
            #ifdef USE_CHAR
                case 'c':
                    #ifdef USE_UPPER
                    case 'C':
                #endif
                format_flag = va_arg(ap,int);
   12250:	e59d200c 	ldr	r2, [sp, #12]
   12254:	e2823004 	add	r3, r2, #4	; 0x4
   12258:	e58d300c 	str	r3, [sp, #12]
   1225c:	e5d20000 	ldrb	r0, [r2]
                // no break -> run into default
            #endif

            default:
                myputchar(format_flag);
   12260:	ebffffa5 	bl	120fc <myputchar>
   12264:	eaffffba 	b	12154 <rprintf+0x18>
                continue;

                #ifdef USE_STRING
                    #ifdef USE_UPPER
                    case 'S':
                #endif
                case 's':
                ptr = (unsigned char*)va_arg(ap,char *);
   12268:	e59d300c 	ldr	r3, [sp, #12]
   1226c:	e5936000 	ldr	r6, [r3]
   12270:	e3a04000 	mov	r4, #0	; 0x0
   12274:	e2833004 	add	r3, r3, #4	; 0x4
   12278:	e58d300c 	str	r3, [sp, #12]
   1227c:	ea000000 	b	12284 <rprintf+0x148>
                while(*ptr) { myputchar(*ptr); ptr++; }
   12280:	ebffff9d 	bl	120fc <myputchar>
   12284:	e7d43006 	ldrb	r3, [r4, r6]
   12288:	e2530000 	subs	r0, r3, #0	; 0x0
   1228c:	e2844001 	add	r4, r4, #1	; 0x1
   12290:	1afffffa 	bne	12280 <rprintf+0x144>
   12294:	eaffffae 	b	12154 <rprintf+0x18>
                    continue;
                #endif

                #ifdef USE_OCTAL
                    case 'o':
                    #ifdef USE_UPPER
                    case 'O':
                #endif
                base = 8;
                myputchar('0');
                goto CONVERSION_LOOP;
                #endif

                #ifdef USE_INTEGER //don't use %i, is same as %d
                    case 'i':
                    #ifdef USE_UPPER
                    case 'I':
                #endif
                #endif
                case 'd':
                #ifdef USE_UPPER
                    case 'D':
                #endif
                issigned=1;
                // no break -> run into next case
            case 'u':
                #ifdef USE_UPPER
                    case 'U':
                #endif

                //don't insert some case below this if USE_HEX is undefined !
                //or put       goto CONVERSION_LOOP;  before next case.
                #ifdef USE_HEX
                    goto CONVERSION_LOOP;
                    case 'x':
                    #ifdef USE_UPPER
                    case 'X':
                #endif
                base = 16;
                #endif

                CONVERSION_LOOP:
   12298:	e3a0800a 	mov	r8, #10	; 0xa
   1229c:	ea00000f 	b	122e0 <rprintf+0x1a4>

                if(issigned) //Signed types
                {
                    #ifdef USE_LONG
                        if(islong) { s_val = va_arg(ap,long); }
   122a0:	e59d300c 	ldr	r3, [sp, #12]
   122a4:	e5934000 	ldr	r4, [r3]
   122a8:	e2833004 	add	r3, r3, #4	; 0x4
   122ac:	e58d300c 	str	r3, [sp, #12]
   122b0:	ea000003 	b	122c4 <rprintf+0x188>
                            else { s_val = va_arg(ap,int); }
   122b4:	e59d200c 	ldr	r2, [sp, #12]
   122b8:	e2823004 	add	r3, r2, #4	; 0x4
   122bc:	e58d300c 	str	r3, [sp, #12]
   122c0:	e5924000 	ldr	r4, [r2]
                        #else
                        s_val = va_arg(ap,int);
                    #endif

                    if(s_val < 0) //Value negativ ?
   122c4:	e3540000 	cmp	r4, #0	; 0x0
                    {
                        s_val = - s_val; //Make it positiv
                        myputchar('-');    //Output sign
   122c8:	b3a0002d 	movlt	r0, #45	; 0x2d
   122cc:	b2644000 	rsblt	r4, r4, #0	; 0x0
   122d0:	bbffff89 	bllt	120fc <myputchar>
                    }

                    u_val = (unsigned long)s_val;
   122d4:	e3a0800a 	mov	r8, #10	; 0xa
   122d8:	ea000008 	b	12300 <rprintf+0x1c4>
   122dc:	e3a08010 	mov	r8, #16	; 0x10
   122e0:	e59d200c 	ldr	r2, [sp, #12]
                }
                else //Unsigned types
                {
                    #ifdef USE_LONG
                        if(islong) { u_val = va_arg(ap,unsigned long); }
   122e4:	e3530000 	cmp	r3, #0	; 0x0
   122e8:	12823004 	addne	r3, r2, #4	; 0x4
                            else { u_val = va_arg(ap,unsigned int); }
   122ec:	02823004 	addeq	r3, r2, #4	; 0x4
   122f0:	15924000 	ldrne	r4, [r2]
   122f4:	158d300c 	strne	r3, [sp, #12]
   122f8:	058d300c 	streq	r3, [sp, #12]
   122fc:	05924000 	ldreq	r4, [r2]
                        #else
                        u_val = va_arg(ap,unsigned int);
                    #endif
                }

                ptr = scratch + SCRATCH;
                *--ptr = 0;
   12300:	e3a03000 	mov	r3, #0	; 0x0
   12304:	e5cd300b 	strb	r3, [sp, #11]
   12308:	e28d600b 	add	r6, sp, #11	; 0xb
                do
                {
                    char ch = u_val % base + '0';
   1230c:	e1a00004 	mov	r0, r4
   12310:	e1a01008 	mov	r1, r8
   12314:	eb001675 	bl	17cf0 <__umodsi3>
   12318:	e2800030 	add	r0, r0, #48	; 0x30
   1231c:	e20030ff 	and	r3, r0, #255	; 0xff
                    #ifdef USE_HEX
                        if (ch > '9')
   12320:	e3530039 	cmp	r3, #57	; 0x39
                        {
                            ch += 'a' - '9' - 1;
                            #ifdef USE_UPPERHEX
                            ch-=0x20;
   12324:	e2832007 	add	r2, r3, #7	; 0x7
   12328:	820230ff 	andhi	r3, r2, #255	; 0xff
                        #endif
                    }
                    #endif
                    *--ptr = ch;
   1232c:	e5463001 	strb	r3, [r6, #-1]
                    u_val /= base;
   12330:	e1a00004 	mov	r0, r4
   12334:	e1a01008 	mov	r1, r8
   12338:	eb0015d6 	bl	17a98 <__aeabi_uidiv>

                    #ifdef PADDING
                        if(width) width--; //calculate number of padding chars
   1233c:	e3570000 	cmp	r7, #0	; 0x0
   12340:	e2473001 	sub	r3, r7, #1	; 0x1
   12344:	120370ff 	andne	r7, r3, #255	; 0xff
                    #endif
                }
                while (u_val);
   12348:	e3500000 	cmp	r0, #0	; 0x0
   1234c:	e2466001 	sub	r6, r6, #1	; 0x1
   12350:	e1a04000 	mov	r4, r0
   12354:	1affffec 	bne	1230c <rprintf+0x1d0>
   12358:	e1a01007 	mov	r1, r7
   1235c:	e1a02006 	mov	r2, r6
   12360:	ea000000 	b	12368 <rprintf+0x22c>

                #ifdef PADDING
                    while(width--) *--ptr = fill; //insert padding chars
   12364:	e562a001 	strb	sl, [r2, #-1]!
   12368:	e2473001 	sub	r3, r7, #1	; 0x1
   1236c:	e20370ff 	and	r7, r3, #255	; 0xff
   12370:	e35700ff 	cmp	r7, #255	; 0xff
   12374:	1afffffa 	bne	12364 <rprintf+0x228>
   12378:	e0614006 	rsb	r4, r1, r6
   1237c:	ea000000 	b	12384 <rprintf+0x248>
                #endif

                while(*ptr) { myputchar(*ptr); ptr++; }
   12380:	ebffff5d 	bl	120fc <myputchar>
   12384:	e5d43000 	ldrb	r3, [r4]
   12388:	e2530000 	subs	r0, r3, #0	; 0x0
   1238c:	e2844001 	add	r4, r4, #1	; 0x1
   12390:	1afffffa 	bne	12380 <rprintf+0x244>
   12394:	eaffff6e 	b	12154 <rprintf+0x18>
   12398:	e3530000 	cmp	r3, #0	; 0x0
   1239c:	1affffbf 	bne	122a0 <rprintf+0x164>
   123a0:	eaffffc3 	b	122b4 <rprintf+0x178>
                    }
        }
    }
   123a4:	e28dd010 	add	sp, sp, #16	; 0x10
   123a8:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   123ac:	e28dd010 	add	sp, sp, #16	; 0x10
   123b0:	e12fff1e 	bx	lr

000123b4 <string_printf_devopen>:
static int (*putcharfunc)(int c);

void string_printf_devopen( int(*put)(int) )
{
    putcharfunc = put;
   123b4:	e59f3004 	ldr	r3, [pc, #4]	; 123c0 <.text+0x23c0>
   123b8:	e5830000 	str	r0, [r3]
}
   123bc:	e12fff1e 	bx	lr
   123c0:	400008b4 	strmih	r0, [r0], -r4

000123c4 <string_myputchar>:

void string_myputchar(char* s_printf_buffer, unsigned char c)
{
	s_printf_buffer[buffer_ptr] = c;
   123c4:	e59f2014 	ldr	r2, [pc, #20]	; 123e0 <.text+0x23e0>
   123c8:	e5d23000 	ldrb	r3, [r2]
   123cc:	e7c01003 	strb	r1, [r0, r3]
	buffer_ptr++;
   123d0:	e5d23000 	ldrb	r3, [r2]
   123d4:	e2833001 	add	r3, r3, #1	; 0x1
   123d8:	e5c23000 	strb	r3, [r2]
}
   123dc:	e12fff1e 	bx	lr
   123e0:	400012dc 	ldrmid	r1, [r0], -ip

000123e4 <string_printf>:

void string_printf(char* string_printf_buffer, char const *format, ...)
{
   123e4:	e92d000e 	stmdb	sp!, {r1, r2, r3}
   123e8:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    unsigned char scratch[SCRATCH];
    unsigned char format_flag;
    unsigned short base;
    unsigned char *ptr;
    unsigned char issigned=0;
    va_list ap;
	
	buffer_ptr = 0;
   123ec:	e59f2280 	ldr	r2, [pc, #640]	; 12674 <.text+0x2674>
   123f0:	e24dd010 	sub	sp, sp, #16	; 0x10
   123f4:	e3a03000 	mov	r3, #0	; 0x0
   123f8:	e59d5030 	ldr	r5, [sp, #48]
   123fc:	e5c23000 	strb	r3, [r2]
   12400:	e1a08000 	mov	r8, r0
	
    #ifdef USE_LONG
        // #warning "use long"
        unsigned char islong=0;
        unsigned long u_val=0;
        long s_val=0;
    #else
        unsigned int u_val=0;
        int s_val=0;
    #endif

    unsigned char fill;
    unsigned char width;

    va_start (ap, format);
   12404:	e28d3034 	add	r3, sp, #52	; 0x34
   12408:	e58d300c 	str	r3, [sp, #12]
   1240c:	ea000009 	b	12438 <string_printf+0x54>

    for (;;)
    {
        while ((format_flag = *(format++)) != '%')
        {      // Until '%' or '\0'
            if (!format_flag)
   12410:	e3510000 	cmp	r1, #0	; 0x0
   12414:	1a000005 	bne	12430 <string_printf+0x4c>
			{
				va_end (ap); 

				string_myputchar(string_printf_buffer, '\0');
   12418:	e1a00008 	mov	r0, r8
   1241c:	ebffffe8 	bl	123c4 <string_myputchar>
				
				return;
			}
            string_myputchar(string_printf_buffer, format_flag);
        }

        issigned=0; //default unsigned
        base = 10;

        format_flag = *format++; //get char after '%'

        #ifdef PADDING
            width=0; //no formatting
            fill=0;  //no formatting
            if(format_flag=='0' || format_flag==' ') //SPACE or ZERO padding  ?
            {
                fill=format_flag;
                format_flag = *format++; //get char after padding char
                if(format_flag>='0' && format_flag<='9')
                {
                    width=format_flag-'0';
                    format_flag = *format++; //get char after width char
                }
            }
        #endif

        #ifdef USE_LONG
            islong=0; //default int value
            #ifdef USE_UPPER
            if(format_flag=='l' || format_flag=='L') //Long value
            #else
            if(format_flag=='l') //Long value
            #endif
        {
            islong=1;
            format_flag = *format++; //get char after 'l' or 'L'
        }
        #endif

        switch (format_flag)
        {
            #ifdef USE_CHAR
                case 'c':
                    #ifdef USE_UPPER
                    case 'C':
                #endif
                format_flag = va_arg(ap,int);
                // no break -> run into default
            #endif

            default:
                string_myputchar(string_printf_buffer, format_flag);
                continue;

                #ifdef USE_STRING
                    #ifdef USE_UPPER
                    case 'S':
                #endif
                case 's':
                ptr = (unsigned char*)va_arg(ap,char *);
                while(*ptr) 
				{ 
					string_myputchar(string_printf_buffer, *ptr); 
					ptr++; 
				}
                    continue;
                #endif

                #ifdef USE_OCTAL
                    case 'o':
                    #ifdef USE_UPPER
                    case 'O':
                #endif
                base = 8;
                string_myputchar(string_printf_buffer, '0');
                goto CONVERSION_LOOP;
                #endif

                #ifdef USE_INTEGER //don't use %i, is same as %d
                    case 'i':
                    #ifdef USE_UPPER
                    case 'I':
                #endif
                #endif
                case 'd':
                #ifdef USE_UPPER
                    case 'D':
                #endif
                issigned=1;
                // no break -> run into next case
            case 'u':
                #ifdef USE_UPPER
                    case 'U':
                #endif

                //don't insert some case below this if USE_HEX is undefined !
                //or put       goto CONVERSION_LOOP;  before next case.
                #ifdef USE_HEX
                    goto CONVERSION_LOOP;
                    case 'x':
                    #ifdef USE_UPPER
                    case 'X':
                #endif
                base = 16;
                #endif

                CONVERSION_LOOP:

                if(issigned) //Signed types
                {
                    #ifdef USE_LONG
                        if(islong) { s_val = va_arg(ap,long); }
                            else { s_val = va_arg(ap,int); }
                        #else
                        s_val = va_arg(ap,int);
                    #endif

                    if(s_val < 0) //Value negativ ?
                    {
                        s_val = - s_val; //Make it positiv
                        string_myputchar(string_printf_buffer, '-');    //Output sign
                    }

                    u_val = (unsigned long)s_val;
                }
                else //Unsigned types
                {
                    #ifdef USE_LONG
                        if(islong) { u_val = va_arg(ap,unsigned long); }
                            else { u_val = va_arg(ap,unsigned int); }
                        #else
                        u_val = va_arg(ap,unsigned int);
                    #endif
                }

                ptr = scratch + SCRATCH;
                *--ptr = 0;
                do
                {
                    char ch = u_val % base + '0';
                    #ifdef USE_HEX
                        if (ch > '9')
                        {
                            ch += 'a' - '9' - 1;
                            #ifdef USE_UPPERHEX
                            ch-=0x20;
                        #endif
                    }
                    #endif
                    *--ptr = ch;
                    u_val /= base;

                    #ifdef PADDING
                        if(width) width--; //calculate number of padding chars
                    #endif
                }
                while (u_val);

                #ifdef PADDING
                    while(width--) *--ptr = fill; //insert padding chars
                #endif

                //Add to buffer
				while(*ptr) 
				{ 
					string_myputchar(string_printf_buffer, *ptr); 
					ptr++; 
				}
            }
        }
    }
   12420:	e28dd010 	add	sp, sp, #16	; 0x10
   12424:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12428:	e28dd00c 	add	sp, sp, #12	; 0xc
   1242c:	e12fff1e 	bx	lr
   12430:	e1a00008 	mov	r0, r8
   12434:	ebffffe2 	bl	123c4 <string_myputchar>
   12438:	e4d51001 	ldrb	r1, [r5], #1
   1243c:	e3510025 	cmp	r1, #37	; 0x25
   12440:	1afffff2 	bne	12410 <string_printf+0x2c>
   12444:	e4d52001 	ldrb	r2, [r5], #1
   12448:	e3520020 	cmp	r2, #32	; 0x20
   1244c:	13520030 	cmpne	r2, #48	; 0x30
   12450:	13a03000 	movne	r3, #0	; 0x0
   12454:	03a03001 	moveq	r3, #1	; 0x1
   12458:	11a07003 	movne	r7, r3
   1245c:	11a01002 	movne	r1, r2
   12460:	11a09007 	movne	r9, r7
   12464:	1a000007 	bne	12488 <string_printf+0xa4>
   12468:	e4d51001 	ldrb	r1, [r5], #1
   1246c:	e2413030 	sub	r3, r1, #48	; 0x30
   12470:	e20370ff 	and	r7, r3, #255	; 0xff
   12474:	e3570009 	cmp	r7, #9	; 0x9
   12478:	94d51001 	ldrlsb	r1, [r5], #1
   1247c:	81a09002 	movhi	r9, r2
   12480:	83a07000 	movhi	r7, #0	; 0x0
   12484:	91a09002 	movls	r9, r2
   12488:	e351004c 	cmp	r1, #76	; 0x4c
   1248c:	1351006c 	cmpne	r1, #108	; 0x6c
   12490:	04d51001 	ldreqb	r1, [r5], #1
   12494:	13a03000 	movne	r3, #0	; 0x0
   12498:	03a03001 	moveq	r3, #1	; 0x1
   1249c:	03a03001 	moveq	r3, #1	; 0x1
   124a0:	e3510058 	cmp	r1, #88	; 0x58
   124a4:	0a00003f 	beq	125a8 <string_printf+0x1c4>
   124a8:	8a00000b 	bhi	124dc <string_printf+0xf8>
   124ac:	e3510049 	cmp	r1, #73	; 0x49
   124b0:	0a00006c 	beq	12668 <string_printf+0x284>
   124b4:	8a000003 	bhi	124c8 <string_printf+0xe4>
   124b8:	e3510043 	cmp	r1, #67	; 0x43
   124bc:	0a000015 	beq	12518 <string_printf+0x134>
   124c0:	e3510044 	cmp	r1, #68	; 0x44
   124c4:	ea00000a 	b	124f4 <string_printf+0x110>
   124c8:	e3510053 	cmp	r1, #83	; 0x53
   124cc:	0a000016 	beq	1252c <string_printf+0x148>
   124d0:	e3510055 	cmp	r1, #85	; 0x55
   124d4:	1affffd5 	bne	12430 <string_printf+0x4c>
   124d8:	ea000020 	b	12560 <string_printf+0x17c>
   124dc:	e3510069 	cmp	r1, #105	; 0x69
   124e0:	0a000060 	beq	12668 <string_printf+0x284>
   124e4:	8a000004 	bhi	124fc <string_printf+0x118>
   124e8:	e3510063 	cmp	r1, #99	; 0x63
   124ec:	0a000009 	beq	12518 <string_printf+0x134>
   124f0:	e3510064 	cmp	r1, #100	; 0x64
   124f4:	1affffcd 	bne	12430 <string_printf+0x4c>
   124f8:	ea00005a 	b	12668 <string_printf+0x284>
   124fc:	e3510075 	cmp	r1, #117	; 0x75
   12500:	0a000016 	beq	12560 <string_printf+0x17c>
   12504:	e3510078 	cmp	r1, #120	; 0x78
   12508:	0a000026 	beq	125a8 <string_printf+0x1c4>
   1250c:	e3510073 	cmp	r1, #115	; 0x73
   12510:	1affffc6 	bne	12430 <string_printf+0x4c>
   12514:	ea000004 	b	1252c <string_printf+0x148>
   12518:	e59d200c 	ldr	r2, [sp, #12]
   1251c:	e5d21000 	ldrb	r1, [r2]
   12520:	e2823004 	add	r3, r2, #4	; 0x4
   12524:	e58d300c 	str	r3, [sp, #12]
   12528:	eaffffc0 	b	12430 <string_printf+0x4c>
   1252c:	e59d300c 	ldr	r3, [sp, #12]
   12530:	e5936000 	ldr	r6, [r3]
   12534:	e3a04000 	mov	r4, #0	; 0x0
   12538:	e2833004 	add	r3, r3, #4	; 0x4
   1253c:	e58d300c 	str	r3, [sp, #12]
   12540:	ea000000 	b	12548 <string_printf+0x164>
   12544:	ebffff9e 	bl	123c4 <string_myputchar>
   12548:	e7d43006 	ldrb	r3, [r4, r6]
   1254c:	e2531000 	subs	r1, r3, #0	; 0x0
   12550:	e1a00008 	mov	r0, r8
   12554:	e2844001 	add	r4, r4, #1	; 0x1
   12558:	1afffff9 	bne	12544 <string_printf+0x160>
   1255c:	eaffffb5 	b	12438 <string_printf+0x54>
   12560:	e3a0a00a 	mov	sl, #10	; 0xa
   12564:	ea000010 	b	125ac <string_printf+0x1c8>
   12568:	e59d300c 	ldr	r3, [sp, #12]
   1256c:	e5934000 	ldr	r4, [r3]
   12570:	e2833004 	add	r3, r3, #4	; 0x4
   12574:	e58d300c 	str	r3, [sp, #12]
   12578:	ea000003 	b	1258c <string_printf+0x1a8>
   1257c:	e59d200c 	ldr	r2, [sp, #12]
   12580:	e2823004 	add	r3, r2, #4	; 0x4
   12584:	e58d300c 	str	r3, [sp, #12]
   12588:	e5924000 	ldr	r4, [r2]
   1258c:	e3540000 	cmp	r4, #0	; 0x0
   12590:	b1a00008 	movlt	r0, r8
   12594:	b3a0102d 	movlt	r1, #45	; 0x2d
   12598:	b2644000 	rsblt	r4, r4, #0	; 0x0
   1259c:	bbffff88 	bllt	123c4 <string_myputchar>
   125a0:	e3a0a00a 	mov	sl, #10	; 0xa
   125a4:	ea000008 	b	125cc <string_printf+0x1e8>
   125a8:	e3a0a010 	mov	sl, #16	; 0x10
   125ac:	e59d200c 	ldr	r2, [sp, #12]
   125b0:	e3530000 	cmp	r3, #0	; 0x0
   125b4:	12823004 	addne	r3, r2, #4	; 0x4
   125b8:	02823004 	addeq	r3, r2, #4	; 0x4
   125bc:	15924000 	ldrne	r4, [r2]
   125c0:	158d300c 	strne	r3, [sp, #12]
   125c4:	058d300c 	streq	r3, [sp, #12]
   125c8:	05924000 	ldreq	r4, [r2]
   125cc:	e3a03000 	mov	r3, #0	; 0x0
   125d0:	e5cd300b 	strb	r3, [sp, #11]
   125d4:	e28d600b 	add	r6, sp, #11	; 0xb
   125d8:	e1a00004 	mov	r0, r4
   125dc:	e1a0100a 	mov	r1, sl
   125e0:	eb0015c2 	bl	17cf0 <__umodsi3>
   125e4:	e2800030 	add	r0, r0, #48	; 0x30
   125e8:	e20030ff 	and	r3, r0, #255	; 0xff
   125ec:	e3530039 	cmp	r3, #57	; 0x39
   125f0:	e2832007 	add	r2, r3, #7	; 0x7
   125f4:	820230ff 	andhi	r3, r2, #255	; 0xff
   125f8:	e5463001 	strb	r3, [r6, #-1]
   125fc:	e1a00004 	mov	r0, r4
   12600:	e1a0100a 	mov	r1, sl
   12604:	eb001523 	bl	17a98 <__aeabi_uidiv>
   12608:	e3570000 	cmp	r7, #0	; 0x0
   1260c:	e2473001 	sub	r3, r7, #1	; 0x1
   12610:	120370ff 	andne	r7, r3, #255	; 0xff
   12614:	e3500000 	cmp	r0, #0	; 0x0
   12618:	e2466001 	sub	r6, r6, #1	; 0x1
   1261c:	e1a04000 	mov	r4, r0
   12620:	1affffec 	bne	125d8 <string_printf+0x1f4>
   12624:	e1a01007 	mov	r1, r7
   12628:	e1a02006 	mov	r2, r6
   1262c:	ea000000 	b	12634 <string_printf+0x250>
   12630:	e5629001 	strb	r9, [r2, #-1]!
   12634:	e2473001 	sub	r3, r7, #1	; 0x1
   12638:	e20370ff 	and	r7, r3, #255	; 0xff
   1263c:	e35700ff 	cmp	r7, #255	; 0xff
   12640:	1afffffa 	bne	12630 <string_printf+0x24c>
   12644:	e0614006 	rsb	r4, r1, r6
   12648:	ea000000 	b	12650 <string_printf+0x26c>
   1264c:	ebffff5c 	bl	123c4 <string_myputchar>
   12650:	e5d43000 	ldrb	r3, [r4]
   12654:	e2531000 	subs	r1, r3, #0	; 0x0
   12658:	e1a00008 	mov	r0, r8
   1265c:	e2844001 	add	r4, r4, #1	; 0x1
   12660:	1afffff9 	bne	1264c <string_printf+0x268>
   12664:	eaffff73 	b	12438 <string_printf+0x54>
   12668:	e3530000 	cmp	r3, #0	; 0x0
   1266c:	1affffbd 	bne	12568 <string_printf+0x184>
   12670:	eaffffc1 	b	1257c <string_printf+0x198>
   12674:	400012dc 	ldrmid	r1, [r0], -ip

00012678 <init_serial0>:
void init_serial0 ( unsigned long baudrate )
{
    unsigned long Fdiv;

    PINSEL0 = 0x00000005;                  /* Enable RxD0 and TxD0              */
   12678:	e59f3040 	ldr	r3, [pc, #64]	; 126c0 <.text+0x26c0>
   1267c:	e92d4010 	stmdb	sp!, {r4, lr}
   12680:	e3a02005 	mov	r2, #5	; 0x5
    U0LCR = 0x83;                          /* 8 bits, no Parity, 1 Stop bit     */
   12684:	e59f4038 	ldr	r4, [pc, #56]	; 126c4 <.text+0x26c4>
   12688:	e5832000 	str	r2, [r3]
   1268c:	e3a03083 	mov	r3, #131	; 0x83
   12690:	e1a01000 	mov	r1, r0
   12694:	e584300c 	str	r3, [r4, #12]
    Fdiv = ( Fcclk / 16 ) / baudrate ;     /* baud rate                        */
   12698:	e59f0028 	ldr	r0, [pc, #40]	; 126c8 <.text+0x26c8>
   1269c:	eb0014fd 	bl	17a98 <__aeabi_uidiv>
    U0DLM = Fdiv / 256;
    U0DLL = Fdiv % 256;
   126a0:	e20030ff 	and	r3, r0, #255	; 0xff
   126a4:	e1a00420 	mov	r0, r0, lsr #8
   126a8:	e5840004 	str	r0, [r4, #4]
   126ac:	e5843000 	str	r3, [r4]
    U0LCR = 0x03;                           /* DLAB = 0                         */
   126b0:	e3a03003 	mov	r3, #3	; 0x3
   126b4:	e584300c 	str	r3, [r4, #12]
}
   126b8:	e8bd4010 	ldmia	sp!, {r4, lr}
   126bc:	e12fff1e 	bx	lr
   126c0:	e002c000 	and	ip, r2, r0
   126c4:	e000c000 	and	ip, r0, r0
   126c8:	00393870 	eoreqs	r3, r9, r0, ror r8

000126cc <init_serial1>:

/* Initialize Serial Interface UART0 */
void init_serial1 ( unsigned long baudrate )
{
    unsigned long Fdiv;

    PINSEL0 |= (1<<16) | (1<<18);         /* Enable RxD1 and TxD1              */
   126cc:	e59f2044 	ldr	r2, [pc, #68]	; 12718 <.text+0x2718>
   126d0:	e5923000 	ldr	r3, [r2]
   126d4:	e92d4010 	stmdb	sp!, {r4, lr}
   126d8:	e3833805 	orr	r3, r3, #327680	; 0x50000
    U1LCR = 0x83;                          /* 8 bits, no Parity, 1 Stop bit     */
   126dc:	e59f4038 	ldr	r4, [pc, #56]	; 1271c <.text+0x271c>
   126e0:	e5823000 	str	r3, [r2]
   126e4:	e3a03083 	mov	r3, #131	; 0x83
   126e8:	e1a01000 	mov	r1, r0
   126ec:	e584300c 	str	r3, [r4, #12]
    Fdiv = ( Fcclk / 16 ) / baudrate ;     /* baud rate                        */
   126f0:	e59f0028 	ldr	r0, [pc, #40]	; 12720 <.text+0x2720>
   126f4:	eb0014e7 	bl	17a98 <__aeabi_uidiv>
    U1DLM = Fdiv / 256;
    U1DLL = Fdiv % 256;
   126f8:	e20030ff 	and	r3, r0, #255	; 0xff
   126fc:	e1a00420 	mov	r0, r0, lsr #8
   12700:	e5840004 	str	r0, [r4, #4]
   12704:	e5843000 	str	r3, [r4]
    U1LCR = 0x03;                           /* DLAB = 0                         */
   12708:	e3a03003 	mov	r3, #3	; 0x3
   1270c:	e584300c 	str	r3, [r4, #12]
}
   12710:	e8bd4010 	ldmia	sp!, {r4, lr}
   12714:	e12fff1e 	bx	lr
   12718:	e002c000 	and	ip, r2, r0
   1271c:	e0010000 	and	r0, r1, r0
   12720:	00393870 	eoreqs	r3, r9, r0, ror r8

00012724 <putchar_serial0>:

/* Write character to Serial Port 0 with \n -> \r\n  */
int putchar_serial0 (int ch)
{
    if (ch == '\n')
   12724:	e350000a 	cmp	r0, #10	; 0xa
   12728:	1a000005 	bne	12744 <putchar_serial0+0x20>
    {
        while (!(U0LSR & 0x20));
   1272c:	e59f202c 	ldr	r2, [pc, #44]	; 12760 <.text+0x2760>
   12730:	e5923014 	ldr	r3, [r2, #20]
   12734:	e3130020 	tst	r3, #32	; 0x20
   12738:	0afffffb 	beq	1272c <putchar_serial0+0x8>
        U0THR = CR;                  /* output CR */
   1273c:	e3a0300d 	mov	r3, #13	; 0xd
   12740:	e5823000 	str	r3, [r2]
    }
    while (!(U0LSR & 0x20));
   12744:	e59f2014 	ldr	r2, [pc, #20]	; 12760 <.text+0x2760>
   12748:	e5923014 	ldr	r3, [r2, #20]
   1274c:	e3130020 	tst	r3, #32	; 0x20
   12750:	0afffffb 	beq	12744 <putchar_serial0+0x20>
    return (U0THR = ch);
   12754:	e5820000 	str	r0, [r2]
   12758:	e5920000 	ldr	r0, [r2]
}
   1275c:	e12fff1e 	bx	lr
   12760:	e000c000 	and	ip, r0, r0

00012764 <putc_serial0>:

/* Write character to Serial Port 0 without \n -> \r\n  */
int putc_serial0 (int ch)
{
    while (!(U0LSR & 0x20));
   12764:	e59f2014 	ldr	r2, [pc, #20]	; 12780 <.text+0x2780>
   12768:	e5923014 	ldr	r3, [r2, #20]
   1276c:	e3130020 	tst	r3, #32	; 0x20
   12770:	0afffffb 	beq	12764 <putc_serial0>
    return (U0THR = ch);
   12774:	e5820000 	str	r0, [r2]
   12778:	e5920000 	ldr	r0, [r2]
}
   1277c:	e12fff1e 	bx	lr
   12780:	e000c000 	and	ip, r0, r0

00012784 <putc_serial1>:

/* Write character to Serial Port 1 without \n -> \r\n  */
int putc_serial1 (int ch)
{
    while (!(U1LSR & 0x20));
   12784:	e59f2014 	ldr	r2, [pc, #20]	; 127a0 <.text+0x27a0>
   12788:	e5923014 	ldr	r3, [r2, #20]
   1278c:	e3130020 	tst	r3, #32	; 0x20
   12790:	0afffffb 	beq	12784 <putc_serial1>
    return (U1THR = ch);
   12794:	e5820000 	str	r0, [r2]
   12798:	e5920000 	ldr	r0, [r2]
}
   1279c:	e12fff1e 	bx	lr
   127a0:	e0010000 	and	r0, r1, r0

000127a4 <putstring_serial0>:

void putstring_serial0 (const char *string)
{
   127a4:	e92d4010 	stmdb	sp!, {r4, lr}
   127a8:	e1a04000 	mov	r4, r0
   127ac:	ea000000 	b	127b4 <putstring_serial0+0x10>
    char ch;

    while ((ch = *string))
    {
        putchar_serial0(ch);
   127b0:	ebffffdb 	bl	12724 <putchar_serial0>
   127b4:	e5d43000 	ldrb	r3, [r4]
   127b8:	e2530000 	subs	r0, r3, #0	; 0x0
        string++;
   127bc:	e2844001 	add	r4, r4, #1	; 0x1
   127c0:	1afffffa 	bne	127b0 <putstring_serial0+0xc>
    }
}
   127c4:	e8bd4010 	ldmia	sp!, {r4, lr}
   127c8:	e12fff1e 	bx	lr

000127cc <getkey_serial0>:


/* Read character from Serial Port   */
int getkey_serial0 (void)
{
	if (U0LSR & 0x01)
   127cc:	e59f2010 	ldr	r2, [pc, #16]	; 127e4 <.text+0x27e4>
   127d0:	e5923014 	ldr	r3, [r2, #20]
   127d4:	e2133001 	ands	r3, r3, #1	; 0x1
   127d8:	e1a00003 	mov	r0, r3
    {
        return (U0RBR);
   127dc:	15920000 	ldrne	r0, [r2]
    }
    else
    {
        return 0;
    }
}
   127e0:	e12fff1e 	bx	lr
   127e4:	e000c000 	and	ip, r0, r0

000127e8 <getc0>:

/* Read character from Serial Port   */
int getc0 (void)
{
	while ( (U0LSR & 0x01) == 0 ); //Wait for character
   127e8:	e59f2010 	ldr	r2, [pc, #16]	; 12800 <.text+0x2800>
   127ec:	e5923014 	ldr	r3, [r2, #20]
   127f0:	e3130001 	tst	r3, #1	; 0x1
   127f4:	0afffffb 	beq	127e8 <getc0>
	return U0RBR;
   127f8:	e5920000 	ldr	r0, [r2]
}
   127fc:	e12fff1e 	bx	lr
   12800:	e000c000 	and	ip, r0, r0

00012804 <SPI1_Init>:

void SPI1_Init(void)
{
	//Set configuration of peripheral
	SSPCPSR = 2;//min value, caution SPI clock = PCLK/(SSPCPSR * (SPI_PCLK_DIVIDER + 1))
   12804:	e59f104c 	ldr	r1, [pc, #76]	; 12858 <.text+0x2858>
   12808:	e3a03002 	mov	r3, #2	; 0x2
   1280c:	e5813010 	str	r3, [r1, #16]
	SSPCR0 = SPI_8_BIT_FRAME | SPI_FRAME_TYPE | SPI_PCLK_DIVIDER | SPI_PHASE | SPI_POLARITY;
   12810:	e59f3044 	ldr	r3, [pc, #68]	; 1285c <.text+0x285c>
   12814:	e5813000 	str	r3, [r1]
	SSPCR1 = 0;
   12818:	e3a03000 	mov	r3, #0	; 0x0
   1281c:	e5813004 	str	r3, [r1, #4]

	//turn on the pins
	configure_pin_miso();
   12820:	e59f2038 	ldr	r2, [pc, #56]	; 12860 <.text+0x2860>
   12824:	e5923004 	ldr	r3, [r2, #4]
   12828:	e3833020 	orr	r3, r3, #32	; 0x20
   1282c:	e5823004 	str	r3, [r2, #4]
	configure_pin_sck();
   12830:	e5923004 	ldr	r3, [r2, #4]
   12834:	e3833008 	orr	r3, r3, #8	; 0x8
   12838:	e5823004 	str	r3, [r2, #4]
	configure_pin_mosi();
   1283c:	e5923004 	ldr	r3, [r2, #4]
   12840:	e3833080 	orr	r3, r3, #128	; 0x80
   12844:	e5823004 	str	r3, [r2, #4]

	//fire it up
	SSPCR1 |= SPI_ENABLE;
   12848:	e5913004 	ldr	r3, [r1, #4]
   1284c:	e3833002 	orr	r3, r3, #2	; 0x2
   12850:	e5813004 	str	r3, [r1, #4]
}
   12854:	e12fff1e 	bx	lr
   12858:	e0068000 	and	r8, r6, r0
   1285c:	00001d07 	andeq	r1, r0, r7, lsl #26
   12860:	e002c000 	and	ip, r2, r0

00012864 <SPI1_Write>:

unsigned char SPI1_Write(unsigned char data)
{
	SSPDR = (unsigned long)data;
   12864:	e59f3020 	ldr	r3, [pc, #32]	; 1288c <.text+0x288c>
   12868:	e20000ff 	and	r0, r0, #255	; 0xff
   1286c:	e5830008 	str	r0, [r3, #8]
	while (SSPSR & SPI_BUSY);//wait for the send to complete
   12870:	e59f2014 	ldr	r2, [pc, #20]	; 1288c <.text+0x288c>
   12874:	e592300c 	ldr	r3, [r2, #12]
   12878:	e3130010 	tst	r3, #16	; 0x10
   1287c:	1afffffb 	bne	12870 <SPI1_Write+0xc>
	//I am assuming RNE is set, because we just clocked data out
	return (unsigned char)(SSPDR & 0x000000ff);
   12880:	e5920008 	ldr	r0, [r2, #8]
   12884:	e20000ff 	and	r0, r0, #255	; 0xff
}
   12888:	e12fff1e 	bx	lr
   1288c:	e0068000 	and	r8, r6, r0

00012890 <SPI1_Read>:

unsigned char SPI1_Read(void)
{
   12890:	e52de004 	str	lr, [sp, #-4]!
	return SPI1_Write(0x00);
   12894:	e3a00000 	mov	r0, #0	; 0x0
   12898:	ebfffff1 	bl	12864 <SPI1_Write>
}
   1289c:	e49de004 	ldr	lr, [sp], #4
   128a0:	e12fff1e 	bx	lr

000128a4 <root_file_exists>:

/* returns 1 if file exists, 0 else */
int root_file_exists(char* name)
{
    return(find_file_in_dir(fs,dd,name,&dir_entry));
   128a4:	e59f3020 	ldr	r3, [pc, #32]	; 128cc <.text+0x28cc>
   128a8:	e5931000 	ldr	r1, [r3]
   128ac:	e59f301c 	ldr	r3, [pc, #28]	; 128d0 <.text+0x28d0>
   128b0:	e1a02000 	mov	r2, r0
   128b4:	e52de004 	str	lr, [sp, #-4]!
   128b8:	e5930000 	ldr	r0, [r3]
   128bc:	e59f3010 	ldr	r3, [pc, #16]	; 128d4 <.text+0x28d4>
   128c0:	eb0006eb 	bl	14474 <find_file_in_dir>
}
   128c4:	e49de004 	ldr	lr, [sp], #4
   128c8:	e12fff1e 	bx	lr
   128cc:	40001314 	andmi	r1, r0, r4, lsl r3
   128d0:	400012e0 	andmi	r1, r0, r0, ror #5
   128d4:	400012e4 	andmi	r1, r0, r4, ror #5

000128d8 <root_delete>:

/* returns NULL if error, pointer if file opened */
struct fat16_file_struct * root_open_new(char* name)
{
    if(fat16_create_file(dd,name,&dir_entry))
    {
        return(open_file_in_dir(fs,dd,name));
    }
    else
    {
        return NULL;
    }
}

struct fat16_file_struct * root_open(char* name)
{
    return(open_file_in_dir(fs,dd,name));
}

uint8_t print_disk_info(const struct fat16_fs_struct* disk_fs)
{
    if(!disk_fs)
        return 0;

    struct sd_raw_info disk_info;
    if(!sd_raw_get_info(&disk_info))
        return 0;

//    int temp = get_output();
//    set_output(UART_ONLY);
    rprintf("manuf:  0x%02x\n\r", disk_info.manufacturer);
    rprintf("oem:    %s\n\r", disk_info.oem);
    rprintf("prod:   %s\n\r", disk_info.product);
    rprintf("rev:    %02x\n\r", disk_info.revision);
    rprintf("serial: 0x%08lx\n\r", disk_info.serial);
    rprintf("date:   %02d/%02d\n\r", disk_info.manufacturing_month, disk_info.manufacturing_year);
    rprintf("size:   %ld\n\r", disk_info.capacity);
    rprintf("copy:   %d\n\r", disk_info.flag_copy);
    rprintf("wr.pr.: %d/%d\n\r", disk_info.flag_write_protect_temp, disk_info.flag_write_protect);
    rprintf("format: %d\n\r", disk_info.format);
    rprintf("free:   %ld/%ld\n\r", fat16_get_fs_free(disk_fs), fat16_get_fs_size(disk_fs));
//    set_output(temp);
    return 1;
}

void root_disk_info(void)
{
    print_disk_info(fs);
}

/* sequential calls return sequential characters
 * of the sequence of file names in the rootdir
 * in place of '\0' it returns ',' only
 * returning a zero when the end of all files
 * has been reached.
 *
 * Assert (1) reset whenever you want to re-start
 */
char rootDirectory_files_stream(int reset)
{

    static int idx = 0;

    /* If reset, we need to reset the dir */
    if(reset)
    {
        fat16_reset_dir(dd);
        return 0;
    }

    /* Whenever IDX is zero, we're gonna start a new file,
       * so read a new one.
       * if there's no new file,
       * return 0, because it's over
       */
    if(idx == 0)
    {
        if(fat16_read_dir(dd,&dir_entry)==0)
        {
            return '\0';
        }
    }

    /* If we've reached the end of a string,
       * return comma instead of \0,
       * so the list is comma delimited,
       * and terminated with a zero
       */
    if(dir_entry.long_name[idx]=='\0')
    {
        idx = 0;
        return ',';
    }


    return dir_entry.long_name[idx++];

}
//Description: Fills buf with len number of chars.  Returns the number of files
//				that were cycled through during the read
//Pre: buf is an array of characters at least as big as len
//		len is the size of the array to read
//Post: buf contains the characters of the filenames in Root, starting at the first file
//		and ending after len characters
int rootDirectory_files(char* buf, int len)
{
    int i;
    int num=0;
    /* Loop will walk through every file in directory dd */
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        i = 0;
        /* Spin through the filename */
        while(dir_entry.long_name[i]!='\0')
        {
            /* And copy each character into buf */
            *buf++=dir_entry.long_name[i++];
            len--;
            if(len==1)
            {
                /* Buf if we ever get to the end of buf, quit */
                *buf='\0';
                return 1;
            }
        }
        *buf++=',';
        num++;
        len--;
        if(len==1)
        {
            /* Buf if we ever get to the end of buf, quit */
            *buf='\0';
            return 1;
        }
    }
    *buf='\0';
    return num;
}

void root_format(void)
{
    fat16_reset_dir(dd);
    while(fat16_read_dir(dd,&dir_entry))
    {
        fat16_delete_file(fs,&dir_entry);
        fat16_reset_dir(dd);
    }
}

int root_delete(char* filename)
{
   128d8:	e92d4010 	stmdb	sp!, {r4, lr}
    if(find_file_in_dir(fs,dd,filename,&dir_entry))
   128dc:	e59f3038 	ldr	r3, [pc, #56]	; 1291c <.text+0x291c>
   128e0:	e59f4038 	ldr	r4, [pc, #56]	; 12920 <.text+0x2920>
   128e4:	e5931000 	ldr	r1, [r3]
   128e8:	e1a02000 	mov	r2, r0
   128ec:	e59f3030 	ldr	r3, [pc, #48]	; 12924 <.text+0x2924>
   128f0:	e5940000 	ldr	r0, [r4]
   128f4:	eb0006de 	bl	14474 <find_file_in_dir>
   128f8:	e3500000 	cmp	r0, #0	; 0x0
    {
        fat16_delete_file(fs,&dir_entry);
   128fc:	e59f1020 	ldr	r1, [pc, #32]	; 12924 <.text+0x2924>
   12900:	e3a00001 	mov	r0, #1	; 0x1
   12904:	0a000002 	beq	12914 <root_delete+0x3c>
   12908:	e5940000 	ldr	r0, [r4]
   1290c:	eb0005db 	bl	14080 <fat16_delete_file>
   12910:	e3a00000 	mov	r0, #0	; 0x0
        return 0;
    }
    return 1;
}
   12914:	e8bd4010 	ldmia	sp!, {r4, lr}
   12918:	e12fff1e 	bx	lr
   1291c:	40001314 	andmi	r1, r0, r4, lsl r3
   12920:	400012e0 	andmi	r1, r0, r0, ror #5
   12924:	400012e4 	andmi	r1, r0, r4, ror #5

00012928 <root_format>:
   12928:	e92d4010 	stmdb	sp!, {r4, lr}
   1292c:	e59f303c 	ldr	r3, [pc, #60]	; 12970 <.text+0x2970>
   12930:	e5930000 	ldr	r0, [r3]
   12934:	ea000003 	b	12948 <root_format+0x20>
   12938:	e59f3034 	ldr	r3, [pc, #52]	; 12974 <.text+0x2974>
   1293c:	e5930000 	ldr	r0, [r3]
   12940:	eb0005ce 	bl	14080 <fat16_delete_file>
   12944:	e5940000 	ldr	r0, [r4]
   12948:	e59f4020 	ldr	r4, [pc, #32]	; 12970 <.text+0x2970>
   1294c:	eb0005bc 	bl	14044 <fat16_reset_dir>
   12950:	e59f1020 	ldr	r1, [pc, #32]	; 12978 <.text+0x2978>
   12954:	e5940000 	ldr	r0, [r4]
   12958:	eb00063f 	bl	1425c <fat16_read_dir>
   1295c:	e3500000 	cmp	r0, #0	; 0x0
   12960:	e59f1010 	ldr	r1, [pc, #16]	; 12978 <.text+0x2978>
   12964:	1afffff3 	bne	12938 <root_format+0x10>
   12968:	e8bd4010 	ldmia	sp!, {r4, lr}
   1296c:	e12fff1e 	bx	lr
   12970:	40001314 	andmi	r1, r0, r4, lsl r3
   12974:	400012e0 	andmi	r1, r0, r0, ror #5
   12978:	400012e4 	andmi	r1, r0, r4, ror #5

0001297c <rootDirectory_files>:
   1297c:	e59f30a0 	ldr	r3, [pc, #160]	; 12a24 <.text+0x2a24>
   12980:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   12984:	e1a04000 	mov	r4, r0
   12988:	e5930000 	ldr	r0, [r3]
   1298c:	e1a05001 	mov	r5, r1
   12990:	eb0005ab 	bl	14044 <fat16_reset_dir>
   12994:	e3a06000 	mov	r6, #0	; 0x0
   12998:	ea000017 	b	129fc <rootDirectory_files+0x80>
   1299c:	e3520001 	cmp	r2, #1	; 0x1
   129a0:	e5c41000 	strb	r1, [r4]
   129a4:	e1a04000 	mov	r4, r0
   129a8:	1a000004 	bne	129c0 <rootDirectory_files+0x44>
   129ac:	e3a03000 	mov	r3, #0	; 0x0
   129b0:	e1a06002 	mov	r6, r2
   129b4:	e5c03000 	strb	r3, [r0]
   129b8:	ea000016 	b	12a18 <rootDirectory_files+0x9c>
   129bc:	e59f3064 	ldr	r3, [pc, #100]	; 12a28 <.text+0x2a28>
   129c0:	e5d31000 	ldrb	r1, [r3]
   129c4:	e2452001 	sub	r2, r5, #1	; 0x1
   129c8:	e3510000 	cmp	r1, #0	; 0x0
   129cc:	e2833001 	add	r3, r3, #1	; 0x1
   129d0:	e1a05002 	mov	r5, r2
   129d4:	e2840001 	add	r0, r4, #1	; 0x1
   129d8:	1affffef 	bne	1299c <rootDirectory_files+0x20>
   129dc:	e3a0302c 	mov	r3, #44	; 0x2c
   129e0:	e3520001 	cmp	r2, #1	; 0x1
   129e4:	e5c43000 	strb	r3, [r4]
   129e8:	e1a04000 	mov	r4, r0
   129ec:	01a06002 	moveq	r6, r2
   129f0:	05c01000 	streqb	r1, [r0]
   129f4:	0a000007 	beq	12a18 <rootDirectory_files+0x9c>
   129f8:	e2866001 	add	r6, r6, #1	; 0x1
   129fc:	e59f3020 	ldr	r3, [pc, #32]	; 12a24 <.text+0x2a24>
   12a00:	e59f1020 	ldr	r1, [pc, #32]	; 12a28 <.text+0x2a28>
   12a04:	e5930000 	ldr	r0, [r3]
   12a08:	eb000613 	bl	1425c <fat16_read_dir>
   12a0c:	e3500000 	cmp	r0, #0	; 0x0
   12a10:	1affffe9 	bne	129bc <rootDirectory_files+0x40>
   12a14:	e5c40000 	strb	r0, [r4]
   12a18:	e1a00006 	mov	r0, r6
   12a1c:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   12a20:	e12fff1e 	bx	lr
   12a24:	40001314 	andmi	r1, r0, r4, lsl r3
   12a28:	400012e4 	andmi	r1, r0, r4, ror #5

00012a2c <rootDirectory_files_stream>:
   12a2c:	e3500000 	cmp	r0, #0	; 0x0
   12a30:	e52de004 	str	lr, [sp, #-4]!
   12a34:	0a000004 	beq	12a4c <rootDirectory_files_stream+0x20>
   12a38:	e59f3064 	ldr	r3, [pc, #100]	; 12aa4 <.text+0x2aa4>
   12a3c:	e5930000 	ldr	r0, [r3]
   12a40:	eb00057f 	bl	14044 <fat16_reset_dir>
   12a44:	e3a00000 	mov	r0, #0	; 0x0
   12a48:	ea000013 	b	12a9c <rootDirectory_files_stream+0x70>
   12a4c:	e59f3054 	ldr	r3, [pc, #84]	; 12aa8 <.text+0x2aa8>
   12a50:	e5933000 	ldr	r3, [r3]
   12a54:	e3530000 	cmp	r3, #0	; 0x0
   12a58:	e59f104c 	ldr	r1, [pc, #76]	; 12aac <.text+0x2aac>
   12a5c:	1a000004 	bne	12a74 <rootDirectory_files_stream+0x48>
   12a60:	e59f303c 	ldr	r3, [pc, #60]	; 12aa4 <.text+0x2aa4>
   12a64:	e5930000 	ldr	r0, [r3]
   12a68:	eb0005fb 	bl	1425c <fat16_read_dir>
   12a6c:	e3500000 	cmp	r0, #0	; 0x0
   12a70:	0a000009 	beq	12a9c <rootDirectory_files_stream+0x70>
   12a74:	e59f102c 	ldr	r1, [pc, #44]	; 12aa8 <.text+0x2aa8>
   12a78:	e59f302c 	ldr	r3, [pc, #44]	; 12aac <.text+0x2aac>
   12a7c:	e5912000 	ldr	r2, [r1]
   12a80:	e7d33002 	ldrb	r3, [r3, r2]
   12a84:	e2822001 	add	r2, r2, #1	; 0x1
   12a88:	e3530000 	cmp	r3, #0	; 0x0
   12a8c:	05813000 	streq	r3, [r1]
   12a90:	15812000 	strne	r2, [r1]
   12a94:	e3a0002c 	mov	r0, #44	; 0x2c
   12a98:	11a00003 	movne	r0, r3
   12a9c:	e49de004 	ldr	lr, [sp], #4
   12aa0:	e12fff1e 	bx	lr
   12aa4:	40001314 	andmi	r1, r0, r4, lsl r3
   12aa8:	400008b8 	strmih	r0, [r0], -r8
   12aac:	400012e4 	andmi	r1, r0, r4, ror #5

00012ab0 <print_disk_info>:
   12ab0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   12ab4:	e2505000 	subs	r5, r0, #0	; 0x0
   12ab8:	e24dd01c 	sub	sp, sp, #28	; 0x1c
   12abc:	e1a0400d 	mov	r4, sp
   12ac0:	e1a0000d 	mov	r0, sp
   12ac4:	0a00002d 	beq	12b80 <print_disk_info+0xd0>
   12ac8:	eb0000f2 	bl	12e98 <sd_raw_get_info>
   12acc:	e3500000 	cmp	r0, #0	; 0x0
   12ad0:	e59f00b8 	ldr	r0, [pc, #184]	; 12b90 <.text+0x2b90>
   12ad4:	0a000029 	beq	12b80 <print_disk_info+0xd0>
   12ad8:	e5dd1000 	ldrb	r1, [sp]
   12adc:	ebfffd96 	bl	1213c <rprintf>
   12ae0:	e59f00ac 	ldr	r0, [pc, #172]	; 12b94 <.text+0x2b94>
   12ae4:	e28d1001 	add	r1, sp, #1	; 0x1
   12ae8:	ebfffd93 	bl	1213c <rprintf>
   12aec:	e28d1004 	add	r1, sp, #4	; 0x4
   12af0:	e59f00a0 	ldr	r0, [pc, #160]	; 12b98 <.text+0x2b98>
   12af4:	ebfffd90 	bl	1213c <rprintf>
   12af8:	e59f009c 	ldr	r0, [pc, #156]	; 12b9c <.text+0x2b9c>
   12afc:	e5dd100a 	ldrb	r1, [sp, #10]
   12b00:	ebfffd8d 	bl	1213c <rprintf>
   12b04:	e59f0094 	ldr	r0, [pc, #148]	; 12ba0 <.text+0x2ba0>
   12b08:	e59d100c 	ldr	r1, [sp, #12]
   12b0c:	ebfffd8a 	bl	1213c <rprintf>
   12b10:	e5dd2010 	ldrb	r2, [sp, #16]
   12b14:	e59f0088 	ldr	r0, [pc, #136]	; 12ba4 <.text+0x2ba4>
   12b18:	e5dd1011 	ldrb	r1, [sp, #17]
   12b1c:	ebfffd86 	bl	1213c <rprintf>
   12b20:	e59f0080 	ldr	r0, [pc, #128]	; 12ba8 <.text+0x2ba8>
   12b24:	e59d1014 	ldr	r1, [sp, #20]
   12b28:	ebfffd83 	bl	1213c <rprintf>
   12b2c:	e59f0078 	ldr	r0, [pc, #120]	; 12bac <.text+0x2bac>
   12b30:	e5dd1018 	ldrb	r1, [sp, #24]
   12b34:	ebfffd80 	bl	1213c <rprintf>
   12b38:	e5dd2019 	ldrb	r2, [sp, #25]
   12b3c:	e59f006c 	ldr	r0, [pc, #108]	; 12bb0 <.text+0x2bb0>
   12b40:	e5dd101a 	ldrb	r1, [sp, #26]
   12b44:	ebfffd7c 	bl	1213c <rprintf>
   12b48:	e5dd101b 	ldrb	r1, [sp, #27]
   12b4c:	e59f0060 	ldr	r0, [pc, #96]	; 12bb4 <.text+0x2bb4>
   12b50:	ebfffd79 	bl	1213c <rprintf>
   12b54:	e1a00005 	mov	r0, r5
   12b58:	eb00057c 	bl	14150 <fat16_get_fs_free>
   12b5c:	e1a04000 	mov	r4, r0
   12b60:	e1a00005 	mov	r0, r5
   12b64:	eb000570 	bl	1412c <fat16_get_fs_size>
   12b68:	e1a01004 	mov	r1, r4
   12b6c:	e1a02000 	mov	r2, r0
   12b70:	e59f0040 	ldr	r0, [pc, #64]	; 12bb8 <.text+0x2bb8>
   12b74:	ebfffd70 	bl	1213c <rprintf>
   12b78:	e3a00001 	mov	r0, #1	; 0x1
   12b7c:	ea000000 	b	12b84 <print_disk_info+0xd4>
   12b80:	e3a00000 	mov	r0, #0	; 0x0
   12b84:	e28dd01c 	add	sp, sp, #28	; 0x1c
   12b88:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12b8c:	e12fff1e 	bx	lr
   12b90:	000181e4 	andeq	r8, r1, r4, ror #3
   12b94:	000181f8 	streqd	r8, [r1], -r8
   12b98:	00018208 	andeq	r8, r1, r8, lsl #4
   12b9c:	00018218 	andeq	r8, r1, r8, lsl r2
   12ba0:	00018228 	andeq	r8, r1, r8, lsr #4
   12ba4:	0001823c 	andeq	r8, r1, ip, lsr r2
   12ba8:	00018250 	andeq	r8, r1, r0, asr r2
   12bac:	00018260 	andeq	r8, r1, r0, ror #4
   12bb0:	00018270 	andeq	r8, r1, r0, ror r2
   12bb4:	00018280 	andeq	r8, r1, r0, lsl #5
   12bb8:	00018290 	muleq	r1, r0, r2

00012bbc <root_disk_info>:
   12bbc:	e59f3004 	ldr	r3, [pc, #4]	; 12bc8 <.text+0x2bc8>
   12bc0:	e5930000 	ldr	r0, [r3]
   12bc4:	eaffffb9 	b	12ab0 <print_disk_info>
   12bc8:	400012e0 	andmi	r1, r0, r0, ror #5

00012bcc <root_open>:
   12bcc:	e59f301c 	ldr	r3, [pc, #28]	; 12bf0 <.text+0x2bf0>
   12bd0:	e5931000 	ldr	r1, [r3]
   12bd4:	e59f3018 	ldr	r3, [pc, #24]	; 12bf4 <.text+0x2bf4>
   12bd8:	e1a02000 	mov	r2, r0
   12bdc:	e52de004 	str	lr, [sp, #-4]!
   12be0:	e5930000 	ldr	r0, [r3]
   12be4:	eb000840 	bl	14cec <open_file_in_dir>
   12be8:	e49de004 	ldr	lr, [sp], #4
   12bec:	e12fff1e 	bx	lr
   12bf0:	40001314 	andmi	r1, r0, r4, lsl r3
   12bf4:	400012e0 	andmi	r1, r0, r0, ror #5

00012bf8 <root_open_new>:
   12bf8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   12bfc:	e59f5030 	ldr	r5, [pc, #48]	; 12c34 <.text+0x2c34>
   12c00:	e1a04000 	mov	r4, r0
   12c04:	e1a01000 	mov	r1, r0
   12c08:	e59f2028 	ldr	r2, [pc, #40]	; 12c38 <.text+0x2c38>
   12c0c:	e5950000 	ldr	r0, [r5]
   12c10:	eb00090c 	bl	15048 <fat16_create_file>
   12c14:	e3500000 	cmp	r0, #0	; 0x0
   12c18:	e1a02004 	mov	r2, r4
   12c1c:	159f3018 	ldrne	r3, [pc, #24]	; 12c3c <.text+0x2c3c>
   12c20:	15951000 	ldrne	r1, [r5]
   12c24:	15930000 	ldrne	r0, [r3]
   12c28:	1b00082f 	blne	14cec <open_file_in_dir>
   12c2c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12c30:	e12fff1e 	bx	lr
   12c34:	40001314 	andmi	r1, r0, r4, lsl r3
   12c38:	400012e4 	andmi	r1, r0, r4, ror #5
   12c3c:	400012e0 	andmi	r1, r0, r0, ror #5

00012c40 <openroot>:
   12c40:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   12c44:	e3a03000 	mov	r3, #0	; 0x0
   12c48:	e59f10ac 	ldr	r1, [pc, #172]	; 12cfc <.text+0x2cfc>
   12c4c:	e59f20ac 	ldr	r2, [pc, #172]	; 12d00 <.text+0x2d00>
   12c50:	e59f00ac 	ldr	r0, [pc, #172]	; 12d04 <.text+0x2d04>
   12c54:	eb000977 	bl	15238 <partition_open>
   12c58:	e59f40a8 	ldr	r4, [pc, #168]	; 12d08 <.text+0x2d08>
   12c5c:	e1a0c000 	mov	ip, r0
   12c60:	e35c0000 	cmp	ip, #0	; 0x0
   12c64:	e3e03000 	mvn	r3, #0	; 0x0
   12c68:	e59f108c 	ldr	r1, [pc, #140]	; 12cfc <.text+0x2cfc>
   12c6c:	e59f208c 	ldr	r2, [pc, #140]	; 12d00 <.text+0x2d00>
   12c70:	e59f008c 	ldr	r0, [pc, #140]	; 12d04 <.text+0x2d04>
   12c74:	e59f5090 	ldr	r5, [pc, #144]	; 12d0c <.text+0x2d0c>
   12c78:	e584c000 	str	ip, [r4]
   12c7c:	1a000005 	bne	12c98 <openroot+0x58>
   12c80:	eb00096c 	bl	15238 <partition_open>
   12c84:	e1a03000 	mov	r3, r0
   12c88:	e3530000 	cmp	r3, #0	; 0x0
   12c8c:	e59f007c 	ldr	r0, [pc, #124]	; 12d10 <.text+0x2d10>
   12c90:	e5843000 	str	r3, [r4]
   12c94:	0a000013 	beq	12ce8 <openroot+0xa8>
   12c98:	e59f3068 	ldr	r3, [pc, #104]	; 12d08 <.text+0x2d08>
   12c9c:	e5930000 	ldr	r0, [r3]
   12ca0:	eb00086b 	bl	14e54 <fat16_open>
   12ca4:	e3500000 	cmp	r0, #0	; 0x0
   12ca8:	e5850000 	str	r0, [r5]
   12cac:	e59f2060 	ldr	r2, [pc, #96]	; 12d14 <.text+0x2d14>
   12cb0:	e59f1060 	ldr	r1, [pc, #96]	; 12d18 <.text+0x2d18>
   12cb4:	059f0060 	ldreq	r0, [pc, #96]	; 12d1c <.text+0x2d1c>
   12cb8:	0a00000a 	beq	12ce8 <openroot+0xa8>
   12cbc:	eb00081b 	bl	14d30 <fat16_get_dir_entry_of_path>
   12cc0:	e59f104c 	ldr	r1, [pc, #76]	; 12d14 <.text+0x2d14>
   12cc4:	e5950000 	ldr	r0, [r5]
   12cc8:	eb0007c7 	bl	14bec <fat16_open_dir>
   12ccc:	e59f304c 	ldr	r3, [pc, #76]	; 12d20 <.text+0x2d20>
   12cd0:	e1a02000 	mov	r2, r0
   12cd4:	e3500000 	cmp	r0, #0	; 0x0
   12cd8:	e3a01000 	mov	r1, #0	; 0x0
   12cdc:	e59f0040 	ldr	r0, [pc, #64]	; 12d24 <.text+0x2d24>
   12ce0:	e5832000 	str	r2, [r3]
   12ce4:	1a000001 	bne	12cf0 <openroot+0xb0>
   12ce8:	ebfffd13 	bl	1213c <rprintf>
   12cec:	e3a01001 	mov	r1, #1	; 0x1
   12cf0:	e1a00001 	mov	r0, r1
   12cf4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12cf8:	e12fff1e 	bx	lr
   12cfc:	000134e8 	andeq	r3, r1, r8, ror #9
   12d00:	0001328c 	andeq	r3, r1, ip, lsl #5
   12d04:	0001312c 	andeq	r3, r1, ip, lsr #2
   12d08:	40001310 	andmi	r1, r0, r0, lsl r3
   12d0c:	400012e0 	andmi	r1, r0, r0, ror #5
   12d10:	000182a4 	andeq	r8, r1, r4, lsr #5
   12d14:	400012e4 	andmi	r1, r0, r4, ror #5
   12d18:	000182dc 	ldreqd	r8, [r1], -ip
   12d1c:	000182c0 	andeq	r8, r1, r0, asr #5
   12d20:	40001314 	andmi	r1, r0, r4, lsl r3
   12d24:	000182e0 	andeq	r8, r1, r0, ror #5

00012d28 <sd_raw_available>:
 */
unsigned char sd_raw_available()
{
    unsigned int i;
    configure_pin_available();
   12d28:	e59f2028 	ldr	r2, [pc, #40]	; 12d58 <.text+0x2d58>
   12d2c:	e5923008 	ldr	r3, [r2, #8]
   12d30:	e3c33080 	bic	r3, r3, #128	; 0x80
   12d34:	e5823008 	str	r3, [r2, #8]
    for(i=0;i<100000;i++);
    i = get_pin_available();
   12d38:	e5921000 	ldr	r1, [r2]
    configure_pin_ss();
   12d3c:	e5923008 	ldr	r3, [r2, #8]
   12d40:	e3110080 	tst	r1, #128	; 0x80
   12d44:	e3833080 	orr	r3, r3, #128	; 0x80
    return i == 0x00;
}
   12d48:	03a00000 	moveq	r0, #0	; 0x0
   12d4c:	13a00001 	movne	r0, #1	; 0x1
   12d50:	e5823008 	str	r3, [r2, #8]
   12d54:	e12fff1e 	bx	lr
   12d58:	e0028000 	and	r8, r2, r0

00012d5c <sd_raw_locked>:

/**
 * \ingroup sd_raw
 * Checks wether the memory card is locked for write access.
 *
 * \returns 1 if the card is locked, 0 if it is not.
 */
unsigned char sd_raw_locked()
{
    return get_pin_locked() == 0x00;
}
   12d5c:	e3a00001 	mov	r0, #1	; 0x1
   12d60:	e12fff1e 	bx	lr

00012d64 <sd_raw_rec_byte>:

/**
 * \ingroup sd_raw
 * Sends a raw byte to the memory card.
 *
 * \param[in] b The byte to sent.
 * \see sd_raw_rec_byte
 */
void sd_raw_send_byte(unsigned char b)
{
    S0SPDR = b;
    /* wait for byte to be shifted out */
    while(!(S0SPSR & 0x80));
}

/**
 * \ingroup sd_raw
 * Receives a raw byte from the memory card.
 *
 * \returns The byte which should be read.
 * \see sd_raw_send_byte
 */
unsigned char sd_raw_rec_byte(void)
{
    /* send dummy data for receiving some */
    S0SPDR = 0xff;
   12d64:	e59f3020 	ldr	r3, [pc, #32]	; 12d8c <.text+0x2d8c>
   12d68:	e3a020ff 	mov	r2, #255	; 0xff
   12d6c:	e5832008 	str	r2, [r3, #8]
    while(!(S0SPSR & 0x80));
   12d70:	e59f2014 	ldr	r2, [pc, #20]	; 12d8c <.text+0x2d8c>
   12d74:	e5923004 	ldr	r3, [r2, #4]
   12d78:	e3130080 	tst	r3, #128	; 0x80
   12d7c:	0afffffb 	beq	12d70 <sd_raw_rec_byte+0xc>

    return S0SPDR;
   12d80:	e5920008 	ldr	r0, [r2, #8]
   12d84:	e20000ff 	and	r0, r0, #255	; 0xff
}
   12d88:	e12fff1e 	bx	lr
   12d8c:	e0020000 	and	r0, r2, r0

00012d90 <sd_raw_send_command_r1>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R1 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
unsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg)
{
   12d90:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   12d94:	e20050ff 	and	r5, r0, #255	; 0xff
   12d98:	e1a04001 	mov	r4, r1
    unsigned char response;
    unsigned char i;

    /* wait some clock cycles */
    sd_raw_rec_byte();
   12d9c:	ebfffff0 	bl	12d64 <sd_raw_rec_byte>
   12da0:	e59f30c4 	ldr	r3, [pc, #196]	; 12e6c <.text+0x2e6c>
   12da4:	e3852040 	orr	r2, r5, #64	; 0x40
   12da8:	e5832008 	str	r2, [r3, #8]
   12dac:	e59f20b8 	ldr	r2, [pc, #184]	; 12e6c <.text+0x2e6c>
   12db0:	e5923004 	ldr	r3, [r2, #4]
   12db4:	e3130080 	tst	r3, #128	; 0x80
   12db8:	0afffffb 	beq	12dac <sd_raw_send_command_r1+0x1c>
   12dbc:	e1a03c24 	mov	r3, r4, lsr #24
   12dc0:	e5823008 	str	r3, [r2, #8]
   12dc4:	e59f20a0 	ldr	r2, [pc, #160]	; 12e6c <.text+0x2e6c>
   12dc8:	e5923004 	ldr	r3, [r2, #4]
   12dcc:	e3130080 	tst	r3, #128	; 0x80
   12dd0:	0afffffb 	beq	12dc4 <sd_raw_send_command_r1+0x34>
   12dd4:	e1a03824 	mov	r3, r4, lsr #16
   12dd8:	e20330ff 	and	r3, r3, #255	; 0xff
   12ddc:	e5823008 	str	r3, [r2, #8]
   12de0:	e59f2084 	ldr	r2, [pc, #132]	; 12e6c <.text+0x2e6c>
   12de4:	e5923004 	ldr	r3, [r2, #4]
   12de8:	e3130080 	tst	r3, #128	; 0x80
   12dec:	0afffffb 	beq	12de0 <sd_raw_send_command_r1+0x50>
   12df0:	e1a03424 	mov	r3, r4, lsr #8
   12df4:	e20330ff 	and	r3, r3, #255	; 0xff
   12df8:	e5823008 	str	r3, [r2, #8]
   12dfc:	e59f2068 	ldr	r2, [pc, #104]	; 12e6c <.text+0x2e6c>
   12e00:	e5923004 	ldr	r3, [r2, #4]
   12e04:	e3130080 	tst	r3, #128	; 0x80
   12e08:	0afffffb 	beq	12dfc <sd_raw_send_command_r1+0x6c>
   12e0c:	e20430ff 	and	r3, r4, #255	; 0xff
   12e10:	e5823008 	str	r3, [r2, #8]
   12e14:	e59f2050 	ldr	r2, [pc, #80]	; 12e6c <.text+0x2e6c>
   12e18:	e5923004 	ldr	r3, [r2, #4]
   12e1c:	e3130080 	tst	r3, #128	; 0x80
   12e20:	0afffffb 	beq	12e14 <sd_raw_send_command_r1+0x84>
   12e24:	e3550000 	cmp	r5, #0	; 0x0
   12e28:	13a030ff 	movne	r3, #255	; 0xff
   12e2c:	03a03095 	moveq	r3, #149	; 0x95
   12e30:	e5823008 	str	r3, [r2, #8]
   12e34:	e59f3030 	ldr	r3, [pc, #48]	; 12e6c <.text+0x2e6c>
   12e38:	e5933004 	ldr	r3, [r3, #4]
   12e3c:	e3130080 	tst	r3, #128	; 0x80
   12e40:	0afffffb 	beq	12e34 <sd_raw_send_command_r1+0xa4>
   12e44:	e3a04000 	mov	r4, #0	; 0x0

    /* send command via SPI */
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte((command == CMD_GO_IDLE_STATE) ? 0x95 : 0xff);

    /* receive response */
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
   12e48:	ebffffc5 	bl	12d64 <sd_raw_rec_byte>
   12e4c:	e2843001 	add	r3, r4, #1	; 0x1
        if(response != 0xff)
   12e50:	e35000ff 	cmp	r0, #255	; 0xff
   12e54:	e20340ff 	and	r4, r3, #255	; 0xff
   12e58:	1a000001 	bne	12e64 <sd_raw_send_command_r1+0xd4>
   12e5c:	e354000a 	cmp	r4, #10	; 0xa
   12e60:	1afffff8 	bne	12e48 <sd_raw_send_command_r1+0xb8>
            break;
    }

    return response;
}
   12e64:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   12e68:	e12fff1e 	bx	lr
   12e6c:	e0020000 	and	r0, r2, r0

00012e70 <SDoff>:

/**
 * \ingroup sd_raw
 * Send a command to the memory card which responses with a R2 response.
 *
 * \param[in] command The command to send.
 * \param[in] arg The argument for command.
 * \returns The command answer.
 */
/*
unsigned short sd_raw_send_command_r2(unsigned char command, unsigned int arg)
{
    unsigned short response;
    unsigned char i;

    // wait some clock cycles
    sd_raw_rec_byte();

    // send command via SPI
    sd_raw_send_byte(0x40 | command);
    sd_raw_send_byte((arg >> 24) & 0xff);
    sd_raw_send_byte((arg >> 16) & 0xff);
    sd_raw_send_byte((arg >> 8) & 0xff);
    sd_raw_send_byte((arg >> 0) & 0xff);
    sd_raw_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);

    // receive response
    for(i = 0; i < 10; ++i)
    {
        response = sd_raw_rec_byte();
        if(response != 0xff)
            break;
    }
    response <<= 8;
    response |= sd_raw_rec_byte();

    return response;
}
*/

/**
 * \ingroup sd_raw
 * Reads raw data from the card.
 *
 * \param[in] offset The offset from which to read.
 * \param[out] buffer The buffer into which to write the data.
 * \param[in] length The number of bytes to read.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read_interval, sd_raw_write
 */
unsigned char sd_raw_read(unsigned int offset, unsigned char* buffer, unsigned short length)
{
    unsigned int block_address;
    unsigned short block_offset;
    unsigned short read_length;
    while(length > 0)
    {
        /* determine byte count to read at once */
        block_address = offset & 0xfffffe00;
        block_offset = offset & 0x01ff;
        read_length = 512 - block_offset; /* read up to block border */
        if(read_length > length)
            read_length = length;

        #if !SD_RAW_SAVE_RAM
            /* check if the requested data is cached */
            if(block_address != raw_block_address)
            #endif
        {
            #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            /* address card */
            select_card();

            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
            {
                unselect_card();
                return 0;
            }

            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);

            #if SD_RAW_SAVE_RAM
                /* read byte block */
                unsigned short read_to = block_offset + read_length;
                for(unsigned short i = 0; i < 512; ++i)
                {
                    unsigned char b = sd_raw_rec_byte();
                    if(i >= block_offset && i < read_to)
                        *buffer++ = b;
                }
            #else
                /* read byte block */
                unsigned char* cache = raw_block;
                unsigned short i;
                for(i = 0; i < 512; ++i)
                    *cache++ = sd_raw_rec_byte();
                raw_block_address = block_address;
    
                memcpy(buffer, raw_block + block_offset, read_length);
                buffer += read_length;
            #endif

            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();

            /* deaddress card */
            unselect_card();

            /* let card some time to finish */
            sd_raw_rec_byte();
        }
        #if !SD_RAW_SAVE_RAM
            else
            {
                /* use cached data */
                memcpy(buffer, raw_block + block_offset, read_length);
            }
        #endif

        length -= read_length;
        offset += read_length;
    }

    return 1;
}

/**
 * \ingroup sd_raw
 * Continuously reads units of \c interval bytes and calls a callback function.
 *
 * This function starts reading at the specified offset. Every \c interval bytes,
 * it calls the callback function with the associated data buffer.
 *
 * By returning zero, the callback may stop reading.
 *
 * \note Within the callback function, you can not start another read or
 *       write operation.
 * \note This function only works if the following conditions are met:
 *       - (offset - (offset % 512)) % interval == 0
 *       - length % interval == 0
 *
 * \param[in] offset Offset from which to start reading.
 * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 * \param[in] interval Number of bytes to read before calling the callback function.
 * \param[in] length Number of bytes to read altogether.
 * \param[in] callback The function to call every interval bytes.
 * \param[in] p An opaque pointer directly passed to the callback function.
 * \returns 0 on failure, 1 on success
 * \see sd_raw_read, sd_raw_write
 */
unsigned char sd_raw_read_interval(unsigned int offset, unsigned char* buffer, unsigned short interval, unsigned short length, sd_raw_interval_handler callback, void* p)
{
    if(!buffer || interval == 0 || length < interval || !callback)
        return 0;

    #if !SD_RAW_SAVE_RAM
        while(length >= interval)
        {
            /* as reading is now buffered, we directly
                     * hand over the request to sd_raw_read()
                     */
            if(!sd_raw_read(offset, buffer, interval))
                return 0;
            if(!callback(buffer, offset, p))
                break;
            offset += interval;
            length -= interval;
        }
    
        return 1;
    #else
        /* address card */
        select_card();
    
        unsigned short block_offset;
        unsigned short read_length;
        unsigned char* buffer_cur;
        unsigned char finished = 0;
        do
        {
            /* determine byte count to read at once */
            block_offset = offset & 0x01ff;
            read_length = 512 - block_offset;
    
            /* send single block request */
            if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, offset & 0xfffffe00))
            {
                unselect_card();
                return 0;
            }
    
            /* wait for data block (start byte 0xfe) */
            while(sd_raw_rec_byte() != 0xfe);
            unsigned short i;
            /* read up to the data of interest */
            for(i = 0; i < block_offset; ++i)
                sd_raw_rec_byte();
    
            /* read interval bytes of data and execute the callback */
            do
            {
                if(read_length < interval || length < interval)
                    break;
    
                buffer_cur = buffer;
                for(i = 0; i < interval; ++i)
                    *buffer_cur++ = sd_raw_rec_byte();
    
                if(!callback(buffer, offset + (512 - read_length), p))
                {
                    finished = 1;
                    break;
                }
    
                read_length -= interval;
                length -= interval;
    
            }
            while(read_length > 0 && length > 0);
    
            /* read rest of data block */
            while(read_length-- > 0)
                sd_raw_rec_byte();
    
            /* read crc16 */
            sd_raw_rec_byte();
            sd_raw_rec_byte();
    
            if(length < interval)
                break;
    
            offset = (offset & 0xfffffe00) + 512;
    
        }
        while(!finished);
    
        /* deaddress card */
        unselect_card();
    
        /* let card some time to finish */
        sd_raw_rec_byte();
    
        return 1;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes raw data to the card.
 *
 * \note If write buffering is enabled, you might have to
 *       call sd_raw_sync() before disconnecting the card
 *       to ensure all remaining data has been written.
 *
 * \param[in] offset The offset where to start writing.
 * \param[in] buffer The buffer containing the data to be written.
 * \param[in] length The number of bytes to write.
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_read
 */
unsigned char sd_raw_write(unsigned int offset, const unsigned char* buffer, unsigned short length)
{
    #if SD_RAW_WRITE_SUPPORT
    
        if(get_pin_locked())
            return 0;
    
        unsigned int block_address;
        unsigned short block_offset;
        unsigned short write_length;
        while(length > 0)
        {
            /* determine byte count to write at once */
            block_address = offset & 0xfffffe00;
            block_offset = offset & 0x01ff;
            write_length = 512 - block_offset; /* write up to block border */
            if(write_length > length)
                write_length = length;
    
            /* Merge the data to write with the content of the block.
                     * Use the cached block if available.
                     */
            if(block_address != raw_block_address)
            {
                #if SD_RAW_WRITE_BUFFERING
                if(!raw_block_written)
                {
                    if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
                        return 0;
                }
            #endif

            if(block_offset || write_length < 512)
            {
                if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
                    return 0;
            }
            raw_block_address = block_address;
        }

        if(buffer != raw_block)
        {
            memcpy(raw_block + block_offset, buffer, write_length);

            #if SD_RAW_WRITE_BUFFERING
                raw_block_written = 0;
    
                if(length == write_length)
                    return 1;
            #endif
        }

        buffer += write_length;

        /* address card */
        select_card();

        /* send single block request */
        if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
        {
            unselect_card();
            return 0;
        }

        /* send start byte */
        sd_raw_send_byte(0xfe);

        /* write byte block */
        unsigned char* cache = raw_block;
        unsigned short i;
        for(i = 0; i < 512; ++i)
            sd_raw_send_byte(*cache++);

        /* write dummy crc16 */
        sd_raw_send_byte(0xff);
        sd_raw_send_byte(0xff);

        /* wait while card is busy */
        while(sd_raw_rec_byte() != 0xff);
        sd_raw_rec_byte();

        /* deaddress card */
        unselect_card();

        length -= write_length;
        offset += write_length;

        #if SD_RAW_WRITE_BUFFERING
            raw_block_written = 1;
        #endif
    }

    return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Writes the write buffer's content to the card.
 *
 * \note When write buffering is enabled, you should
 *       call this function before disconnecting the
 *       card to ensure all remaining data has been
 *       written.
 *
 * \returns 0 on failure, 1 on success.
 * \see sd_raw_write
 */
unsigned char sd_raw_sync()
{
    #if SD_RAW_WRITE_SUPPORT
        #if SD_RAW_WRITE_BUFFERING
        if(raw_block_written)
            return 1;
        if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
            return 0;
    #endif
    return 1;
    #else
    return 0;
    #endif
}

/**
 * \ingroup sd_raw
 * Reads informational data from the card.
 *
 * This function reads and returns the card's registers
 * containing manufacturing and status information.
 *
 * \note: The information retrieved by this function is
 *        not required in any way to operate on the card,
 *        but it might be nice to display some of the data
 *        to the user.
 *
 * \param[in] info A pointer to the structure into which to save the information.
 * \returns 0 on failure, 1 on success.
 */
unsigned char sd_raw_get_info(struct sd_raw_info* info)
{
    if(!info || !sd_raw_available())
        return 0;

    memset(info, 0, sizeof(*info));

    select_card();

    /* read cid register */
    if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    unsigned char i;
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 0:
                info->manufacturer = b;
                break;
            case 1:
            case 2:
                info->oem[i - 1] = b;
                break;
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                info->product[i - 3] = b;
                break;
            case 8:
                info->revision = b;
                break;
            case 9:
            case 10:
            case 11:
            case 12:
                info->serial |= (unsigned int) b << ((12 - i) * 8);
                break;
            case 13:
                info->manufacturing_year = b << 4;
                break;
            case 14:
                info->manufacturing_year |= b >> 4;
                info->manufacturing_month = b & 0x0f;
                break;
        }
    }

    /* read csd register */
    unsigned char csd_read_bl_len = 0;
    unsigned char csd_c_size_mult = 0;
    unsigned short csd_c_size = 0;
    if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
    {
        unselect_card();
        return 0;
    }
    while(sd_raw_rec_byte() != 0xfe);
    for(i = 0; i < 18; ++i)
    {
        unsigned char b = sd_raw_rec_byte();

        switch(i)
        {
            case 5:
                csd_read_bl_len = b & 0x0f;
                break;
            case 6:
                csd_c_size = (unsigned short) (b & 0x03) << 8;
                break;
            case 7:
                csd_c_size |= b;
                csd_c_size <<= 2;
                break;
            case 8:
                csd_c_size |= b >> 6;
                ++csd_c_size;
                break;
            case 9:
                csd_c_size_mult = (b & 0x03) << 1;
                break;
            case 10:
                csd_c_size_mult |= b >> 7;

                info->capacity = (unsigned int) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 2);

                break;
            case 14:
                if(b & 0x40)
                    info->flag_copy = 1;
                if(b & 0x20)
                    info->flag_write_protect = 1;
                if(b & 0x10)
                    info->flag_write_protect_temp = 1;
                info->format = (b & 0x0c) >> 2;
                break;
        }
    }

    unselect_card();

    return 1;
}

void SDoff(void)
{
    SPI_SS_IODIR &= ~(1<<SPI_SS_PIN);
   12e70:	e59f201c 	ldr	r2, [pc, #28]	; 12e94 <.text+0x2e94>
   12e74:	e5923008 	ldr	r3, [r2, #8]
   12e78:	e3c33080 	bic	r3, r3, #128	; 0x80
   12e7c:	e5823008 	str	r3, [r2, #8]
    PINSEL0 &= ~(0x1500);
   12e80:	e2822901 	add	r2, r2, #16384	; 0x4000
   12e84:	e5923000 	ldr	r3, [r2]
   12e88:	e3c33c15 	bic	r3, r3, #5376	; 0x1500
   12e8c:	e5823000 	str	r3, [r2]
}
   12e90:	e12fff1e 	bx	lr
   12e94:	e0028000 	and	r8, r2, r0

00012e98 <sd_raw_get_info>:
   12e98:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12e9c:	e2504000 	subs	r4, r0, #0	; 0x0
   12ea0:	0a000097 	beq	13104 <.text+0x3104>
   12ea4:	ebffff9f 	bl	12d28 <sd_raw_available>
   12ea8:	e3500000 	cmp	r0, #0	; 0x0
   12eac:	0a000094 	beq	13104 <.text+0x3104>
   12eb0:	e59f5270 	ldr	r5, [pc, #624]	; 13128 <.text+0x3128>
   12eb4:	e3a01000 	mov	r1, #0	; 0x0
   12eb8:	e3a0201c 	mov	r2, #28	; 0x1c
   12ebc:	e1a00004 	mov	r0, r4
   12ec0:	eb0011b4 	bl	17598 <memset>
   12ec4:	e595300c 	ldr	r3, [r5, #12]
   12ec8:	e3833080 	orr	r3, r3, #128	; 0x80
   12ecc:	e3a0000a 	mov	r0, #10	; 0xa
   12ed0:	e3a01000 	mov	r1, #0	; 0x0
   12ed4:	e585300c 	str	r3, [r5, #12]
   12ed8:	ebffffac 	bl	12d90 <sd_raw_send_command_r1>
   12edc:	e3500000 	cmp	r0, #0	; 0x0
   12ee0:	15953004 	ldrne	r3, [r5, #4]
   12ee4:	13a00000 	movne	r0, #0	; 0x0
   12ee8:	13833080 	orrne	r3, r3, #128	; 0x80
   12eec:	15853004 	strne	r3, [r5, #4]
   12ef0:	1a00008a 	bne	13120 <.text+0x3120>
   12ef4:	ebffff9a 	bl	12d64 <sd_raw_rec_byte>
   12ef8:	e35000fe 	cmp	r0, #254	; 0xfe
   12efc:	1afffffc 	bne	12ef4 <sd_raw_get_info+0x5c>
   12f00:	ebffff97 	bl	12d64 <sd_raw_rec_byte>
   12f04:	e3a05000 	mov	r5, #0	; 0x0
   12f08:	ea000012 	b	12f58 <.text+0x2f58>
   12f0c:	ebffff94 	bl	12d64 <sd_raw_rec_byte>
   12f10:	e355000e 	cmp	r5, #14	; 0xe
   12f14:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
   12f18:	ea000026 	b	12fb8 <.text+0x2fb8>
   12f1c:	00012f58 	andeq	r2, r1, r8, asr pc
   12f20:	00012f60 	andeq	r2, r1, r0, ror #30
   12f24:	00012f60 	andeq	r2, r1, r0, ror #30
   12f28:	00012f68 	andeq	r2, r1, r8, ror #30
   12f2c:	00012f68 	andeq	r2, r1, r8, ror #30
   12f30:	00012f68 	andeq	r2, r1, r8, ror #30
   12f34:	00012f68 	andeq	r2, r1, r8, ror #30
   12f38:	00012f68 	andeq	r2, r1, r8, ror #30
   12f3c:	00012f74 	andeq	r2, r1, r4, ror pc
   12f40:	00012f7c 	andeq	r2, r1, ip, ror pc
   12f44:	00012f7c 	andeq	r2, r1, ip, ror pc
   12f48:	00012f7c 	andeq	r2, r1, ip, ror pc
   12f4c:	00012f7c 	andeq	r2, r1, ip, ror pc
   12f50:	00012f94 	muleq	r1, r4, pc
   12f54:	00012fa0 	andeq	r2, r1, r0, lsr #31
   12f58:	e5c40000 	strb	r0, [r4]
   12f5c:	ea00006a 	b	1310c <.text+0x310c>
   12f60:	e7c50004 	strb	r0, [r5, r4]
   12f64:	ea000013 	b	12fb8 <.text+0x2fb8>
   12f68:	e0853004 	add	r3, r5, r4
   12f6c:	e5c30001 	strb	r0, [r3, #1]
   12f70:	ea000010 	b	12fb8 <.text+0x2fb8>
   12f74:	e5c4000a 	strb	r0, [r4, #10]
   12f78:	ea000063 	b	1310c <.text+0x310c>
   12f7c:	e594200c 	ldr	r2, [r4, #12]
   12f80:	e265300c 	rsb	r3, r5, #12	; 0xc
   12f84:	e1a03183 	mov	r3, r3, lsl #3
   12f88:	e1822310 	orr	r2, r2, r0, lsl r3
   12f8c:	e584200c 	str	r2, [r4, #12]
   12f90:	ea000008 	b	12fb8 <.text+0x2fb8>
   12f94:	e1a03200 	mov	r3, r0, lsl #4
   12f98:	e5c43010 	strb	r3, [r4, #16]
   12f9c:	ea00005a 	b	1310c <.text+0x310c>
   12fa0:	e5d43010 	ldrb	r3, [r4, #16]
   12fa4:	e200200f 	and	r2, r0, #15	; 0xf
   12fa8:	e1833220 	orr	r3, r3, r0, lsr #4
   12fac:	e5c43010 	strb	r3, [r4, #16]
   12fb0:	e5c42011 	strb	r2, [r4, #17]
   12fb4:	ea000054 	b	1310c <.text+0x310c>
   12fb8:	e2853001 	add	r3, r5, #1	; 0x1
   12fbc:	e20350ff 	and	r5, r3, #255	; 0xff
   12fc0:	e3550011 	cmp	r5, #17	; 0x11
   12fc4:	9affffd0 	bls	12f0c <sd_raw_get_info+0x74>
   12fc8:	e3a00009 	mov	r0, #9	; 0x9
   12fcc:	e3a01000 	mov	r1, #0	; 0x0
   12fd0:	ebffff6e 	bl	12d90 <sd_raw_send_command_r1>
   12fd4:	e3500000 	cmp	r0, #0	; 0x0
   12fd8:	159f2148 	ldrne	r2, [pc, #328]	; 13128 <.text+0x3128>
   12fdc:	15923004 	ldrne	r3, [r2, #4]
   12fe0:	13a00000 	movne	r0, #0	; 0x0
   12fe4:	13833080 	orrne	r3, r3, #128	; 0x80
   12fe8:	1a000043 	bne	130fc <.text+0x30fc>
   12fec:	ebffff5c 	bl	12d64 <sd_raw_rec_byte>
   12ff0:	e35000fe 	cmp	r0, #254	; 0xfe
   12ff4:	1afffffc 	bne	12fec <.text+0x2fec>
   12ff8:	ebffff59 	bl	12d64 <sd_raw_rec_byte>
   12ffc:	e3a07000 	mov	r7, #0	; 0x0
   13000:	e3a05001 	mov	r5, #1	; 0x1
   13004:	e1a08007 	mov	r8, r7
   13008:	e1a06007 	mov	r6, r7
   1300c:	ebffff54 	bl	12d64 <sd_raw_rec_byte>
   13010:	e2453005 	sub	r3, r5, #5	; 0x5
   13014:	e2852001 	add	r2, r5, #1	; 0x1
   13018:	e3530009 	cmp	r3, #9	; 0x9
   1301c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   13020:	ea00002e 	b	130e0 <.text+0x30e0>
   13024:	0001304c 	andeq	r3, r1, ip, asr #32
   13028:	00013054 	andeq	r3, r1, r4, asr r0
   1302c:	00013060 	andeq	r3, r1, r0, rrx
   13030:	0001306c 	andeq	r3, r1, ip, rrx
   13034:	00013084 	andeq	r3, r1, r4, lsl #1
   13038:	00013090 	muleq	r1, r0, r0
   1303c:	000130e0 	andeq	r3, r1, r0, ror #1
   13040:	000130e0 	andeq	r3, r1, r0, ror #1
   13044:	000130e0 	andeq	r3, r1, r0, ror #1
   13048:	000130ac 	andeq	r3, r1, ip, lsr #1
   1304c:	e200800f 	and	r8, r0, #15	; 0xf
   13050:	ea000030 	b	13118 <.text+0x3118>
   13054:	e2003003 	and	r3, r0, #3	; 0x3
   13058:	e1a06403 	mov	r6, r3, lsl #8
   1305c:	ea00002d 	b	13118 <.text+0x3118>
   13060:	e1863000 	orr	r3, r6, r0
   13064:	e1a03903 	mov	r3, r3, lsl #18
   13068:	ea000003 	b	1307c <.text+0x307c>
   1306c:	e1a03900 	mov	r3, r0, lsl #18
   13070:	e1863c23 	orr	r3, r6, r3, lsr #24
   13074:	e2833001 	add	r3, r3, #1	; 0x1
   13078:	e1a03803 	mov	r3, r3, lsl #16
   1307c:	e1a06823 	mov	r6, r3, lsr #16
   13080:	ea000024 	b	13118 <.text+0x3118>
   13084:	e2003003 	and	r3, r0, #3	; 0x3
   13088:	e1a07083 	mov	r7, r3, lsl #1
   1308c:	ea000021 	b	13118 <.text+0x3118>
   13090:	e18733a0 	orr	r3, r7, r0, lsr #7
   13094:	e20370ff 	and	r7, r3, #255	; 0xff
   13098:	e2883002 	add	r3, r8, #2	; 0x2
   1309c:	e0873003 	add	r3, r7, r3
   130a0:	e1a03316 	mov	r3, r6, lsl r3
   130a4:	e5843014 	str	r3, [r4, #20]
   130a8:	ea00001a 	b	13118 <.text+0x3118>
   130ac:	e3100040 	tst	r0, #64	; 0x40
   130b0:	13a03001 	movne	r3, #1	; 0x1
   130b4:	15c43018 	strneb	r3, [r4, #24]
   130b8:	e3100020 	tst	r0, #32	; 0x20
   130bc:	13a03001 	movne	r3, #1	; 0x1
   130c0:	15c43019 	strneb	r3, [r4, #25]
   130c4:	e3100010 	tst	r0, #16	; 0x10
   130c8:	13a03001 	movne	r3, #1	; 0x1
   130cc:	15c4301a 	strneb	r3, [r4, #26]
   130d0:	e200300c 	and	r3, r0, #12	; 0xc
   130d4:	e1a03143 	mov	r3, r3, asr #2
   130d8:	e5c4301b 	strb	r3, [r4, #27]
   130dc:	ea00000d 	b	13118 <.text+0x3118>
   130e0:	e20250ff 	and	r5, r2, #255	; 0xff
   130e4:	e3550011 	cmp	r5, #17	; 0x11
   130e8:	9affffc7 	bls	1300c <.text+0x300c>
   130ec:	e59f2034 	ldr	r2, [pc, #52]	; 13128 <.text+0x3128>
   130f0:	e5923004 	ldr	r3, [r2, #4]
   130f4:	e3a00001 	mov	r0, #1	; 0x1
   130f8:	e3833080 	orr	r3, r3, #128	; 0x80
   130fc:	e5823004 	str	r3, [r2, #4]
   13100:	ea000006 	b	13120 <.text+0x3120>
   13104:	e3a00000 	mov	r0, #0	; 0x0
   13108:	ea000004 	b	13120 <.text+0x3120>
   1310c:	e2853001 	add	r3, r5, #1	; 0x1
   13110:	e20350ff 	and	r5, r3, #255	; 0xff
   13114:	eaffff7c 	b	12f0c <sd_raw_get_info+0x74>
   13118:	e20250ff 	and	r5, r2, #255	; 0xff
   1311c:	eaffffba 	b	1300c <.text+0x300c>
   13120:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   13124:	e12fff1e 	bx	lr
   13128:	e0028000 	and	r8, r2, r0

0001312c <sd_raw_read>:
   1312c:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13130:	e1a02802 	mov	r2, r2, lsl #16
   13134:	e1a09000 	mov	r9, r0
   13138:	e1a0a001 	mov	sl, r1
   1313c:	e1a08822 	mov	r8, r2, lsr #16
   13140:	ea000046 	b	13260 <sd_raw_read+0x134>
   13144:	e1a06b89 	mov	r6, r9, lsl #23
   13148:	e1a06ba6 	mov	r6, r6, lsr #23
   1314c:	e59f3120 	ldr	r3, [pc, #288]	; 13274 <.text+0x3274>
   13150:	e2662c02 	rsb	r2, r6, #512	; 0x200
   13154:	e1a02802 	mov	r2, r2, lsl #16
   13158:	e5930000 	ldr	r0, [r3]
   1315c:	e3c95f7f 	bic	r5, r9, #508	; 0x1fc
   13160:	e3c55003 	bic	r5, r5, #3	; 0x3
   13164:	e1a02822 	mov	r2, r2, lsr #16
   13168:	e1580002 	cmp	r8, r2
   1316c:	31a07008 	movcc	r7, r8
   13170:	21a07002 	movcs	r7, r2
   13174:	e1550000 	cmp	r5, r0
   13178:	0a00002f 	beq	1323c <sd_raw_read+0x110>
   1317c:	e59f30f4 	ldr	r3, [pc, #244]	; 13278 <.text+0x3278>
   13180:	e5d33000 	ldrb	r3, [r3]
   13184:	e3530000 	cmp	r3, #0	; 0x0
   13188:	1a000004 	bne	131a0 <sd_raw_read+0x74>
   1318c:	e59f10e8 	ldr	r1, [pc, #232]	; 1327c <.text+0x327c>
   13190:	e3a02c02 	mov	r2, #512	; 0x200
   13194:	eb00003c 	bl	1328c <sd_raw_write>
   13198:	e3500000 	cmp	r0, #0	; 0x0
   1319c:	0a000032 	beq	1326c <sd_raw_read+0x140>
   131a0:	e59f40d8 	ldr	r4, [pc, #216]	; 13280 <.text+0x3280>
   131a4:	e594300c 	ldr	r3, [r4, #12]
   131a8:	e3833080 	orr	r3, r3, #128	; 0x80
   131ac:	e3a00011 	mov	r0, #17	; 0x11
   131b0:	e1a01005 	mov	r1, r5
   131b4:	e584300c 	str	r3, [r4, #12]
   131b8:	ebfffef4 	bl	12d90 <sd_raw_send_command_r1>
   131bc:	e3500000 	cmp	r0, #0	; 0x0
   131c0:	15943004 	ldrne	r3, [r4, #4]
   131c4:	13a00000 	movne	r0, #0	; 0x0
   131c8:	13833080 	orrne	r3, r3, #128	; 0x80
   131cc:	15843004 	strne	r3, [r4, #4]
   131d0:	1a000025 	bne	1326c <sd_raw_read+0x140>
   131d4:	ebfffee2 	bl	12d64 <sd_raw_rec_byte>
   131d8:	e35000fe 	cmp	r0, #254	; 0xfe
   131dc:	1afffffc 	bne	131d4 <sd_raw_read+0xa8>
   131e0:	e59f409c 	ldr	r4, [pc, #156]	; 13284 <.text+0x3284>
   131e4:	ebfffede 	bl	12d64 <sd_raw_rec_byte>
   131e8:	e59f3098 	ldr	r3, [pc, #152]	; 13288 <.text+0x3288>
   131ec:	e5440001 	strb	r0, [r4, #-1]
   131f0:	e2844001 	add	r4, r4, #1	; 0x1
   131f4:	e1540003 	cmp	r4, r3
   131f8:	1afffff9 	bne	131e4 <sd_raw_read+0xb8>
   131fc:	e59f3070 	ldr	r3, [pc, #112]	; 13274 <.text+0x3274>
   13200:	e59f1074 	ldr	r1, [pc, #116]	; 1327c <.text+0x327c>
   13204:	e1a02007 	mov	r2, r7
   13208:	e5835000 	str	r5, [r3]
   1320c:	e0861001 	add	r1, r6, r1
   13210:	e1a0000a 	mov	r0, sl
   13214:	eb0010d7 	bl	17578 <memcpy>
   13218:	ebfffed1 	bl	12d64 <sd_raw_rec_byte>
   1321c:	ebfffed0 	bl	12d64 <sd_raw_rec_byte>
   13220:	e59f2058 	ldr	r2, [pc, #88]	; 13280 <.text+0x3280>
   13224:	e5923004 	ldr	r3, [r2, #4]
   13228:	e3833080 	orr	r3, r3, #128	; 0x80
   1322c:	e5823004 	str	r3, [r2, #4]
   13230:	e08aa007 	add	sl, sl, r7
   13234:	ebfffeca 	bl	12d64 <sd_raw_rec_byte>
   13238:	ea000004 	b	13250 <sd_raw_read+0x124>
   1323c:	e59f1038 	ldr	r1, [pc, #56]	; 1327c <.text+0x327c>
   13240:	e1a0000a 	mov	r0, sl
   13244:	e0861001 	add	r1, r6, r1
   13248:	e1a02007 	mov	r2, r7
   1324c:	eb0010c9 	bl	17578 <memcpy>
   13250:	e0673008 	rsb	r3, r7, r8
   13254:	e1a03803 	mov	r3, r3, lsl #16
   13258:	e0899007 	add	r9, r9, r7
   1325c:	e1a08823 	mov	r8, r3, lsr #16
   13260:	e3580000 	cmp	r8, #0	; 0x0
   13264:	1affffb6 	bne	13144 <sd_raw_read+0x18>
   13268:	e3a00001 	mov	r0, #1	; 0x1
   1326c:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13270:	e12fff1e 	bx	lr
   13274:	40000abc 	strmih	r0, [r0], -ip
   13278:	40000ac0 	andmi	r0, r0, r0, asr #21
   1327c:	400008bc 	strmih	r0, [r0], -ip
   13280:	e0028000 	and	r8, r2, r0
   13284:	400008bd 	strmih	r0, [r0], -sp
   13288:	40000abd 	strmih	r0, [r0], -sp

0001328c <sd_raw_write>:
   1328c:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13290:	e1a02802 	mov	r2, r2, lsl #16
   13294:	e1a0a000 	mov	sl, r0
   13298:	e1a08001 	mov	r8, r1
   1329c:	e1a07822 	mov	r7, r2, lsr #16
   132a0:	ea000069 	b	1344c <sd_raw_write+0x1c0>
   132a4:	e1a04b8a 	mov	r4, sl, lsl #23
   132a8:	e1a04ba4 	mov	r4, r4, lsr #23
   132ac:	e59f91cc 	ldr	r9, [pc, #460]	; 13480 <.text+0x3480>
   132b0:	e2643c02 	rsb	r3, r4, #512	; 0x200
   132b4:	e1a03803 	mov	r3, r3, lsl #16
   132b8:	e3ca5f7f 	bic	r5, sl, #508	; 0x1fc
   132bc:	e5990000 	ldr	r0, [r9]
   132c0:	e3c55003 	bic	r5, r5, #3	; 0x3
   132c4:	e1a03823 	mov	r3, r3, lsr #16
   132c8:	e1570003 	cmp	r7, r3
   132cc:	31a06007 	movcc	r6, r7
   132d0:	21a06003 	movcs	r6, r3
   132d4:	e1550000 	cmp	r5, r0
   132d8:	0a000017 	beq	1333c <sd_raw_write+0xb0>
   132dc:	e59f31a0 	ldr	r3, [pc, #416]	; 13484 <.text+0x3484>
   132e0:	e5d33000 	ldrb	r3, [r3]
   132e4:	e3530000 	cmp	r3, #0	; 0x0
   132e8:	1a000004 	bne	13300 <sd_raw_write+0x74>
   132ec:	e59f1194 	ldr	r1, [pc, #404]	; 13488 <.text+0x3488>
   132f0:	e3a02c02 	mov	r2, #512	; 0x200
   132f4:	ebffffe4 	bl	1328c <sd_raw_write>
   132f8:	e3500000 	cmp	r0, #0	; 0x0
   132fc:	0a000055 	beq	13458 <sd_raw_write+0x1cc>
   13300:	e59f3184 	ldr	r3, [pc, #388]	; 1348c <.text+0x348c>
   13304:	e1560003 	cmp	r6, r3
   13308:	83a03000 	movhi	r3, #0	; 0x0
   1330c:	93a03001 	movls	r3, #1	; 0x1
   13310:	e3540000 	cmp	r4, #0	; 0x0
   13314:	13833001 	orrne	r3, r3, #1	; 0x1
   13318:	e3530000 	cmp	r3, #0	; 0x0
   1331c:	0a000005 	beq	13338 <sd_raw_write+0xac>
   13320:	e1a00005 	mov	r0, r5
   13324:	e59f115c 	ldr	r1, [pc, #348]	; 13488 <.text+0x3488>
   13328:	e3a02c02 	mov	r2, #512	; 0x200
   1332c:	ebffff7e 	bl	1312c <sd_raw_read>
   13330:	e3500000 	cmp	r0, #0	; 0x0
   13334:	0a000047 	beq	13458 <sd_raw_write+0x1cc>
   13338:	e5895000 	str	r5, [r9]
   1333c:	e59f3144 	ldr	r3, [pc, #324]	; 13488 <.text+0x3488>
   13340:	e1580003 	cmp	r8, r3
   13344:	0a000008 	beq	1336c <sd_raw_write+0xe0>
   13348:	e0840003 	add	r0, r4, r3
   1334c:	e1a02006 	mov	r2, r6
   13350:	e1a01008 	mov	r1, r8
   13354:	eb001087 	bl	17578 <memcpy>
   13358:	e59f3124 	ldr	r3, [pc, #292]	; 13484 <.text+0x3484>
   1335c:	e3a02000 	mov	r2, #0	; 0x0
   13360:	e1570006 	cmp	r7, r6
   13364:	e5c32000 	strb	r2, [r3]
   13368:	0a000041 	beq	13474 <sd_raw_write+0x1e8>
   1336c:	e59f411c 	ldr	r4, [pc, #284]	; 13490 <.text+0x3490>
   13370:	e594300c 	ldr	r3, [r4, #12]
   13374:	e3833080 	orr	r3, r3, #128	; 0x80
   13378:	e1a01005 	mov	r1, r5
   1337c:	e3a00018 	mov	r0, #24	; 0x18
   13380:	e584300c 	str	r3, [r4, #12]
   13384:	ebfffe81 	bl	12d90 <sd_raw_send_command_r1>
   13388:	e3500000 	cmp	r0, #0	; 0x0
   1338c:	1a000033 	bne	13460 <sd_raw_write+0x1d4>
   13390:	e59f30fc 	ldr	r3, [pc, #252]	; 13494 <.text+0x3494>
   13394:	e3a020fe 	mov	r2, #254	; 0xfe
   13398:	e5832008 	str	r2, [r3, #8]
   1339c:	e59f30f0 	ldr	r3, [pc, #240]	; 13494 <.text+0x3494>
   133a0:	e5933004 	ldr	r3, [r3, #4]
   133a4:	e3130080 	tst	r3, #128	; 0x80
   133a8:	0afffffb 	beq	1339c <sd_raw_write+0x110>
   133ac:	e59f10e4 	ldr	r1, [pc, #228]	; 13498 <.text+0x3498>
   133b0:	e5512001 	ldrb	r2, [r1, #-1]
   133b4:	e59f30d8 	ldr	r3, [pc, #216]	; 13494 <.text+0x3494>
   133b8:	e5832008 	str	r2, [r3, #8]
   133bc:	e59f20d0 	ldr	r2, [pc, #208]	; 13494 <.text+0x3494>
   133c0:	e5923004 	ldr	r3, [r2, #4]
   133c4:	e3130080 	tst	r3, #128	; 0x80
   133c8:	0afffffb 	beq	133bc <sd_raw_write+0x130>
   133cc:	e59f30c8 	ldr	r3, [pc, #200]	; 1349c <.text+0x349c>
   133d0:	e2811001 	add	r1, r1, #1	; 0x1
   133d4:	e1510003 	cmp	r1, r3
   133d8:	1afffff4 	bne	133b0 <sd_raw_write+0x124>
   133dc:	e3a030ff 	mov	r3, #255	; 0xff
   133e0:	e5823008 	str	r3, [r2, #8]
   133e4:	e59f20a8 	ldr	r2, [pc, #168]	; 13494 <.text+0x3494>
   133e8:	e5923004 	ldr	r3, [r2, #4]
   133ec:	e3130080 	tst	r3, #128	; 0x80
   133f0:	0afffffb 	beq	133e4 <sd_raw_write+0x158>
   133f4:	e3a030ff 	mov	r3, #255	; 0xff
   133f8:	e5823008 	str	r3, [r2, #8]
   133fc:	e59f3090 	ldr	r3, [pc, #144]	; 13494 <.text+0x3494>
   13400:	e5933004 	ldr	r3, [r3, #4]
   13404:	e3130080 	tst	r3, #128	; 0x80
   13408:	0afffffb 	beq	133fc <sd_raw_write+0x170>
   1340c:	ebfffe54 	bl	12d64 <sd_raw_rec_byte>
   13410:	e35000ff 	cmp	r0, #255	; 0xff
   13414:	1afffffc 	bne	1340c <sd_raw_write+0x180>
   13418:	ebfffe51 	bl	12d64 <sd_raw_rec_byte>
   1341c:	e59f206c 	ldr	r2, [pc, #108]	; 13490 <.text+0x3490>
   13420:	e5923004 	ldr	r3, [r2, #4]
   13424:	e3833080 	orr	r3, r3, #128	; 0x80
   13428:	e5823004 	str	r3, [r2, #4]
   1342c:	e59f3050 	ldr	r3, [pc, #80]	; 13484 <.text+0x3484>
   13430:	e0661007 	rsb	r1, r6, r7
   13434:	e3a02001 	mov	r2, #1	; 0x1
   13438:	e1a01801 	mov	r1, r1, lsl #16
   1343c:	e5c32000 	strb	r2, [r3]
   13440:	e08aa006 	add	sl, sl, r6
   13444:	e0888006 	add	r8, r8, r6
   13448:	e1a07821 	mov	r7, r1, lsr #16
   1344c:	e3570000 	cmp	r7, #0	; 0x0
   13450:	1affff93 	bne	132a4 <sd_raw_write+0x18>
   13454:	ea000006 	b	13474 <sd_raw_write+0x1e8>
   13458:	e3a00000 	mov	r0, #0	; 0x0
   1345c:	ea000005 	b	13478 <sd_raw_write+0x1ec>
   13460:	e5943004 	ldr	r3, [r4, #4]
   13464:	e3a00000 	mov	r0, #0	; 0x0
   13468:	e3833080 	orr	r3, r3, #128	; 0x80
   1346c:	e5843004 	str	r3, [r4, #4]
   13470:	ea000000 	b	13478 <sd_raw_write+0x1ec>
   13474:	e3a00001 	mov	r0, #1	; 0x1
   13478:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1347c:	e12fff1e 	bx	lr
   13480:	40000abc 	strmih	r0, [r0], -ip
   13484:	40000ac0 	andmi	r0, r0, r0, asr #21
   13488:	400008bc 	strmih	r0, [r0], -ip
   1348c:	000001ff 	streqd	r0, [r0], -pc
   13490:	e0028000 	and	r8, r2, r0
   13494:	e0020000 	and	r0, r2, r0
   13498:	400008bd 	strmih	r0, [r0], -sp
   1349c:	40000abd 	strmih	r0, [r0], -sp

000134a0 <sd_raw_sync>:
   134a0:	e52de004 	str	lr, [sp, #-4]!
   134a4:	e59f3030 	ldr	r3, [pc, #48]	; 134dc <.text+0x34dc>
   134a8:	e5d33000 	ldrb	r3, [r3]
   134ac:	e3530000 	cmp	r3, #0	; 0x0
   134b0:	e59f1028 	ldr	r1, [pc, #40]	; 134e0 <.text+0x34e0>
   134b4:	e3a02c02 	mov	r2, #512	; 0x200
   134b8:	e3a00001 	mov	r0, #1	; 0x1
   134bc:	1a000004 	bne	134d4 <sd_raw_sync+0x34>
   134c0:	e59f301c 	ldr	r3, [pc, #28]	; 134e4 <.text+0x34e4>
   134c4:	e5930000 	ldr	r0, [r3]
   134c8:	ebffff6f 	bl	1328c <sd_raw_write>
   134cc:	e2500000 	subs	r0, r0, #0	; 0x0
   134d0:	13a00001 	movne	r0, #1	; 0x1
   134d4:	e49de004 	ldr	lr, [sp], #4
   134d8:	e12fff1e 	bx	lr
   134dc:	40000ac0 	andmi	r0, r0, r0, asr #21
   134e0:	400008bc 	strmih	r0, [r0], -ip
   134e4:	40000abc 	strmih	r0, [r0], -ip

000134e8 <sd_raw_read_interval>:
   134e8:	e1a02802 	mov	r2, r2, lsl #16
   134ec:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
   134f0:	e1a03803 	mov	r3, r3, lsl #16
   134f4:	e3520000 	cmp	r2, #0	; 0x0
   134f8:	13510000 	cmpne	r1, #0	; 0x0
   134fc:	e1a07001 	mov	r7, r1
   13500:	e1a06000 	mov	r6, r0
   13504:	e1a05823 	mov	r5, r3, lsr #16
   13508:	e28d801c 	add	r8, sp, #28	; 0x1c
   1350c:	e8980500 	ldmia	r8, {r8, sl}
   13510:	e1a04822 	mov	r4, r2, lsr #16
   13514:	0a00001a 	beq	13584 <sd_raw_read_interval+0x9c>
   13518:	e2783001 	rsbs	r3, r8, #1	; 0x1
   1351c:	33a03000 	movcc	r3, #0	; 0x0
   13520:	e1550004 	cmp	r5, r4
   13524:	33833001 	orrcc	r3, r3, #1	; 0x1
   13528:	e3530000 	cmp	r3, #0	; 0x0
   1352c:	0a00000e 	beq	1356c <sd_raw_read_interval+0x84>
   13530:	ea000013 	b	13584 <sd_raw_read_interval+0x9c>
   13534:	ebfffefc 	bl	1312c <sd_raw_read>
   13538:	e3500000 	cmp	r0, #0	; 0x0
   1353c:	e1a01006 	mov	r1, r6
   13540:	e1a0200a 	mov	r2, sl
   13544:	e1a00007 	mov	r0, r7
   13548:	e0866004 	add	r6, r6, r4
   1354c:	0a00000c 	beq	13584 <sd_raw_read_interval+0x9c>
   13550:	e1a0e00f 	mov	lr, pc
   13554:	e12fff18 	bx	r8
   13558:	e3500000 	cmp	r0, #0	; 0x0
   1355c:	0a00000a 	beq	1358c <sd_raw_read_interval+0xa4>
   13560:	e0643005 	rsb	r3, r4, r5
   13564:	e1a03803 	mov	r3, r3, lsl #16
   13568:	e1a05823 	mov	r5, r3, lsr #16
   1356c:	e1550004 	cmp	r5, r4
   13570:	e1a00006 	mov	r0, r6
   13574:	e1a01007 	mov	r1, r7
   13578:	e1a02004 	mov	r2, r4
   1357c:	2affffec 	bcs	13534 <sd_raw_read_interval+0x4c>
   13580:	ea000001 	b	1358c <sd_raw_read_interval+0xa4>
   13584:	e3a00000 	mov	r0, #0	; 0x0
   13588:	ea000000 	b	13590 <sd_raw_read_interval+0xa8>
   1358c:	e3a00001 	mov	r0, #1	; 0x1
   13590:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
   13594:	e12fff1e 	bx	lr

00013598 <sd_raw_init>:
   13598:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   1359c:	e59f41e0 	ldr	r4, [pc, #480]	; 13784 <.text+0x3784>
   135a0:	e5943008 	ldr	r3, [r4, #8]
   135a4:	e3833080 	orr	r3, r3, #128	; 0x80
   135a8:	e5843008 	str	r3, [r4, #8]
   135ac:	e59f21d4 	ldr	r2, [pc, #468]	; 13788 <.text+0x3788>
   135b0:	e5923000 	ldr	r3, [r2]
   135b4:	e3833a01 	orr	r3, r3, #4096	; 0x1000
   135b8:	e5823000 	str	r3, [r2]
   135bc:	e5923000 	ldr	r3, [r2]
   135c0:	e3833b01 	orr	r3, r3, #1024	; 0x400
   135c4:	e5823000 	str	r3, [r2]
   135c8:	e5923000 	ldr	r3, [r2]
   135cc:	e3833c01 	orr	r3, r3, #256	; 0x100
   135d0:	e5823000 	str	r3, [r2]
   135d4:	e5943004 	ldr	r3, [r4, #4]
   135d8:	e3833080 	orr	r3, r3, #128	; 0x80
   135dc:	e5843004 	str	r3, [r4, #4]
   135e0:	e2422903 	sub	r2, r2, #49152	; 0xc000
   135e4:	e3a03096 	mov	r3, #150	; 0x96
   135e8:	e582300c 	str	r3, [r2, #12]
   135ec:	e3a03038 	mov	r3, #56	; 0x38
   135f0:	e5823000 	str	r3, [r2]
   135f4:	ebfffdcb 	bl	12d28 <sd_raw_available>
   135f8:	e2505000 	subs	r5, r0, #0	; 0x0
   135fc:	1a000002 	bne	1360c <sd_raw_init+0x74>
   13600:	e59f0184 	ldr	r0, [pc, #388]	; 1378c <.text+0x378c>
   13604:	ebfffacc 	bl	1213c <rprintf>
   13608:	ea000045 	b	13724 <sd_raw_init+0x18c>
   1360c:	e5943008 	ldr	r3, [r4, #8]
   13610:	e3833080 	orr	r3, r3, #128	; 0x80
   13614:	e5843008 	str	r3, [r4, #8]
   13618:	e5943004 	ldr	r3, [r4, #4]
   1361c:	e3833080 	orr	r3, r3, #128	; 0x80
   13620:	e5843004 	str	r3, [r4, #4]
   13624:	e3a04000 	mov	r4, #0	; 0x0
   13628:	ebfffdcd 	bl	12d64 <sd_raw_rec_byte>
   1362c:	e2843001 	add	r3, r4, #1	; 0x1
   13630:	e1a03803 	mov	r3, r3, lsl #16
   13634:	e1a04823 	mov	r4, r3, lsr #16
   13638:	e354000a 	cmp	r4, #10	; 0xa
   1363c:	1afffff9 	bne	13628 <sd_raw_init+0x90>
   13640:	e59f213c 	ldr	r2, [pc, #316]	; 13784 <.text+0x3784>
   13644:	e592300c 	ldr	r3, [r2, #12]
   13648:	e3833080 	orr	r3, r3, #128	; 0x80
   1364c:	e582300c 	str	r3, [r2, #12]
   13650:	e3a04000 	mov	r4, #0	; 0x0
   13654:	e3a00000 	mov	r0, #0	; 0x0
   13658:	e1a01000 	mov	r1, r0
   1365c:	ebfffdcb 	bl	12d90 <sd_raw_send_command_r1>
   13660:	e2843001 	add	r3, r4, #1	; 0x1
   13664:	e3500001 	cmp	r0, #1	; 0x1
   13668:	e1a02803 	mov	r2, r3, lsl #16
   1366c:	0a000004 	beq	13684 <sd_raw_init+0xec>
   13670:	e59f3118 	ldr	r3, [pc, #280]	; 13790 <.text+0x3790>
   13674:	e1540003 	cmp	r4, r3
   13678:	e1a04822 	mov	r4, r2, lsr #16
   1367c:	0a00002a 	beq	1372c <sd_raw_init+0x194>
   13680:	eafffff3 	b	13654 <sd_raw_init+0xbc>
   13684:	e3a04000 	mov	r4, #0	; 0x0
   13688:	e3a01000 	mov	r1, #0	; 0x0
   1368c:	e3a00001 	mov	r0, #1	; 0x1
   13690:	ebfffdbe 	bl	12d90 <sd_raw_send_command_r1>
   13694:	e2843001 	add	r3, r4, #1	; 0x1
   13698:	e3100001 	tst	r0, #1	; 0x1
   1369c:	e1a02803 	mov	r2, r3, lsl #16
   136a0:	0a000004 	beq	136b8 <sd_raw_init+0x120>
   136a4:	e59f30e8 	ldr	r3, [pc, #232]	; 13794 <.text+0x3794>
   136a8:	e1540003 	cmp	r4, r3
   136ac:	e1a04822 	mov	r4, r2, lsr #16
   136b0:	0a000026 	beq	13750 <sd_raw_init+0x1b8>
   136b4:	eafffff3 	b	13688 <sd_raw_init+0xf0>
   136b8:	e3a00010 	mov	r0, #16	; 0x10
   136bc:	e3a01c02 	mov	r1, #512	; 0x200
   136c0:	ebfffdb2 	bl	12d90 <sd_raw_send_command_r1>
   136c4:	e3500000 	cmp	r0, #0	; 0x0
   136c8:	159f20b4 	ldrne	r2, [pc, #180]	; 13784 <.text+0x3784>
   136cc:	15923004 	ldrne	r3, [r2, #4]
   136d0:	159f00c0 	ldrne	r0, [pc, #192]	; 13798 <.text+0x3798>
   136d4:	13833080 	orrne	r3, r3, #128	; 0x80
   136d8:	1a000020 	bne	13760 <sd_raw_init+0x1c8>
   136dc:	e59fc0a0 	ldr	ip, [pc, #160]	; 13784 <.text+0x3784>
   136e0:	e59c3004 	ldr	r3, [ip, #4]
   136e4:	e3833080 	orr	r3, r3, #128	; 0x80
   136e8:	e58c3004 	str	r3, [ip, #4]
   136ec:	e59f30a8 	ldr	r3, [pc, #168]	; 1379c <.text+0x379c>
   136f0:	e3e0c000 	mvn	ip, #0	; 0x0
   136f4:	e583c000 	str	ip, [r3]
   136f8:	e59f30a0 	ldr	r3, [pc, #160]	; 137a0 <.text+0x37a0>
   136fc:	e28cc03d 	add	ip, ip, #61	; 0x3d
   13700:	e583c00c 	str	ip, [r3, #12]
   13704:	e59f3098 	ldr	r3, [pc, #152]	; 137a4 <.text+0x37a4>
   13708:	e3a05001 	mov	r5, #1	; 0x1
   1370c:	e59f1094 	ldr	r1, [pc, #148]	; 137a8 <.text+0x37a8>
   13710:	e3a02c02 	mov	r2, #512	; 0x200
   13714:	e5c35000 	strb	r5, [r3]
   13718:	ebfffe83 	bl	1312c <sd_raw_read>
   1371c:	e2504000 	subs	r4, r0, #0	; 0x0
   13720:	0a000012 	beq	13770 <sd_raw_init+0x1d8>
   13724:	e1a00005 	mov	r0, r5
   13728:	ea000013 	b	1377c <sd_raw_init+0x1e4>
   1372c:	e1a01000 	mov	r1, r0
   13730:	e59f0074 	ldr	r0, [pc, #116]	; 137ac <.text+0x37ac>
   13734:	ebfffa80 	bl	1213c <rprintf>
   13738:	e59f2044 	ldr	r2, [pc, #68]	; 13784 <.text+0x3784>
   1373c:	e5923004 	ldr	r3, [r2, #4]
   13740:	e3a00000 	mov	r0, #0	; 0x0
   13744:	e3833080 	orr	r3, r3, #128	; 0x80
   13748:	e5823004 	str	r3, [r2, #4]
   1374c:	ea00000a 	b	1377c <sd_raw_init+0x1e4>
   13750:	e59f202c 	ldr	r2, [pc, #44]	; 13784 <.text+0x3784>
   13754:	e5923004 	ldr	r3, [r2, #4]
   13758:	e59f0050 	ldr	r0, [pc, #80]	; 137b0 <.text+0x37b0>
   1375c:	e3833080 	orr	r3, r3, #128	; 0x80
   13760:	e5823004 	str	r3, [r2, #4]
   13764:	ebfffa74 	bl	1213c <rprintf>
   13768:	e3a00000 	mov	r0, #0	; 0x0
   1376c:	ea000002 	b	1377c <sd_raw_init+0x1e4>
   13770:	e59f003c 	ldr	r0, [pc, #60]	; 137b4 <.text+0x37b4>
   13774:	ebfffa70 	bl	1213c <rprintf>
   13778:	e1a00004 	mov	r0, r4
   1377c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   13780:	e12fff1e 	bx	lr
   13784:	e0028000 	and	r8, r2, r0
   13788:	e002c000 	and	ip, r2, r0
   1378c:	00018300 	andeq	r8, r1, r0, lsl #6
   13790:	000001ff 	streqd	r0, [r0], -pc
   13794:	00007fff 	streqd	r7, [r0], -pc
   13798:	0001833c 	andeq	r8, r1, ip, lsr r3
   1379c:	40000abc 	strmih	r0, [r0], -ip
   137a0:	e0020000 	and	r0, r2, r0
   137a4:	40000ac0 	andmi	r0, r0, r0, asr #21
   137a8:	400008bc 	strmih	r0, [r0], -ip
   137ac:	00018318 	andeq	r8, r1, r8, lsl r3
   137b0:	0001832c 	andeq	r8, r1, ip, lsr #6
   137b4:	00018354 	andeq	r8, r1, r4, asr r3

000137b8 <format_card>:

//NES : 10-28-7 
//Low-level formats a 512MB card
//Assumes *many* things
//You must pass this fuction 0xAA to get it to work (safety check)
char format_card(char make_sure)
{
   137b8:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   137bc:	e20000ff 	and	r0, r0, #255	; 0xff
	#define MBR_LOCATION	0x00
	#define BR_LOCATION		(MBR_LOCATION+0x80000)
	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))

	//Safety check
	if (make_sure != 0xAA) return 0;
   137c0:	e35000aa 	cmp	r0, #170	; 0xaa
   137c4:	e24ddc02 	sub	sp, sp, #512	; 0x200
   137c8:	13a00000 	movne	r0, #0	; 0x0
   137cc:	1a00006d 	bne	13988 <format_card+0x1d0>
   137d0:	e3a04000 	mov	r4, #0	; 0x0
	
	int i;
	unsigned char my_buff[512];
	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
   137d4:	e3a06000 	mov	r6, #0	; 0x0
   137d8:	e7c4600d 	strb	r6, [r4, sp]
   137dc:	e2844001 	add	r4, r4, #1	; 0x1
   137e0:	e3540c02 	cmp	r4, #512	; 0x200
   137e4:	1afffffa 	bne	137d4 <format_card+0x1c>
	
	//Init SD card interface
	sd_raw_init();
   137e8:	ebffff6a 	bl	13598 <sd_raw_init>

	//Erase Master Boot record
	sd_raw_sync();
   137ec:	ebffff2b 	bl	134a0 <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
   137f0:	e1a02004 	mov	r2, r4
   137f4:	e1a0100d 	mov	r1, sp
   137f8:	e1a00006 	mov	r0, r6
   137fc:	ebfffea2 	bl	1328c <sd_raw_write>

	//Erase Boot record
	sd_raw_sync();
   13800:	ebffff26 	bl	134a0 <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
   13804:	e1a02004 	mov	r2, r4
   13808:	e1a0100d 	mov	r1, sp
   1380c:	e3a00702 	mov	r0, #524288	; 0x80000
   13810:	ebfffe9d 	bl	1328c <sd_raw_write>
   13814:	e3a04703 	mov	r4, #786432	; 0xc0000

	//Erase FAT tables
	for(i = 0 ; i < 0x00F5 ; i++) //0x00F5 = 245 bytes : comes from byte 0x16 from Boot Record
	{
		sd_raw_sync();
   13818:	ebffff20 	bl	134a0 <sd_raw_sync>
		sd_raw_write( (FAT_TABLE + (i*512)), my_buff, 512);
   1381c:	e1a00004 	mov	r0, r4
   13820:	e1a0100d 	mov	r1, sp
   13824:	e3a02c02 	mov	r2, #512	; 0x200
   13828:	ebfffe97 	bl	1328c <sd_raw_write>
   1382c:	e59f3160 	ldr	r3, [pc, #352]	; 13994 <.text+0x3994>
   13830:	e2844c02 	add	r4, r4, #512	; 0x200
   13834:	e1540003 	cmp	r4, r3
   13838:	e1a0900d 	mov	r9, sp
   1383c:	1afffff5 	bne	13818 <format_card+0x60>
	}
	
	//Write Master Boot Record
	#define PART1	0x01BE
	my_buff[PART1 + 0] = 0x00;
	my_buff[PART1 + 1] = 0x00;
	my_buff[PART1 + 2] = 0x01;
	my_buff[PART1 + 3] = 0x01;
	my_buff[PART1 + 4] = 0x06;
   13840:	e3a03006 	mov	r3, #6	; 0x6
   13844:	e5cd31c2 	strb	r3, [sp, #450]
	my_buff[PART1 + 5] = 0x1F;
   13848:	e2833019 	add	r3, r3, #25	; 0x19
   1384c:	e5cd31c3 	strb	r3, [sp, #451]
	my_buff[PART1 + 6] = 0xE0;
   13850:	e3e0301f 	mvn	r3, #31	; 0x1f
   13854:	e3a04000 	mov	r4, #0	; 0x0
   13858:	e3a02001 	mov	r2, #1	; 0x1
	my_buff[PART1 + 7] = 0xD3;
	my_buff[PART1 + 8] = 0x00;
	my_buff[PART1 + 9] = 0x04;
	my_buff[PART1 + 10] = 0x00;
	my_buff[PART1 + 11] = 0x00;
	my_buff[PART1 + 12] = 0x00;
	my_buff[PART1 + 13] = 0x4C;
	my_buff[PART1 + 14] = 0x0F;
	my_buff[510] = 0x55;
   1385c:	e3a05055 	mov	r5, #85	; 0x55
   13860:	e3a06004 	mov	r6, #4	; 0x4
   13864:	e3a0704c 	mov	r7, #76	; 0x4c
   13868:	e3a0800f 	mov	r8, #15	; 0xf
	my_buff[511] = 0xAA;
   1386c:	e3e0a055 	mvn	sl, #85	; 0x55
   13870:	e5cd31c4 	strb	r3, [sp, #452]
   13874:	e3e0302c 	mvn	r3, #44	; 0x2c
   13878:	e5cd31c5 	strb	r3, [sp, #453]
   1387c:	e5cd21c1 	strb	r2, [sp, #449]
   13880:	e5cd21c0 	strb	r2, [sp, #448]
   13884:	e5cd41be 	strb	r4, [sp, #446]
   13888:	e5cd41bf 	strb	r4, [sp, #447]
   1388c:	e5cd41c6 	strb	r4, [sp, #454]
   13890:	e5cd61c7 	strb	r6, [sp, #455]
   13894:	e5cd41c8 	strb	r4, [sp, #456]
   13898:	e5cd41c9 	strb	r4, [sp, #457]
   1389c:	e5cd41ca 	strb	r4, [sp, #458]
   138a0:	e5cd71cb 	strb	r7, [sp, #459]
   138a4:	e5cd81cc 	strb	r8, [sp, #460]
   138a8:	e5cd51fe 	strb	r5, [sp, #510]
   138ac:	e5cda1ff 	strb	sl, [sp, #511]

	sd_raw_sync();
   138b0:	ebfffefa 	bl	134a0 <sd_raw_sync>
	sd_raw_write(MBR_LOCATION, my_buff, 512);
   138b4:	e1a0100d 	mov	r1, sp
   138b8:	e3a02c02 	mov	r2, #512	; 0x200
   138bc:	e1a00004 	mov	r0, r4
   138c0:	ebfffe71 	bl	1328c <sd_raw_write>
	sd_raw_sync();
   138c4:	ebfffef5 	bl	134a0 <sd_raw_sync>

	//Write Boot Record
	#define BOOTRECORD1	0x80000
	my_buff[0] = 0xEB;
   138c8:	e3e03014 	mvn	r3, #20	; 0x14
   138cc:	e5cd3000 	strb	r3, [sp]
	my_buff[1] = 0xFE;
   138d0:	e2833013 	add	r3, r3, #19	; 0x13
   138d4:	e5cd3001 	strb	r3, [sp, #1]
	my_buff[2] = 0x90;
   138d8:	e3e0306f 	mvn	r3, #111	; 0x6f
   138dc:	e5cd3002 	strb	r3, [sp, #2]
	my_buff[12] = 0x02;
	my_buff[13] = 0x10;
   138e0:	e2833080 	add	r3, r3, #128	; 0x80
   138e4:	e5cd300d 	strb	r3, [sp, #13]
	my_buff[14] = 0x16;
   138e8:	e2833006 	add	r3, r3, #6	; 0x6
   138ec:	e5cd300e 	strb	r3, [sp, #14]
	my_buff[16] = 0x02;
	my_buff[18] = 0x02;
	my_buff[21] = 0xF8;
   138f0:	e3e03007 	mvn	r3, #7	; 0x7
   138f4:	e5cd3015 	strb	r3, [sp, #21]
	my_buff[22] = 0xF5;
   138f8:	e3e0300a 	mvn	r3, #10	; 0xa
   138fc:	e5cd3016 	strb	r3, [sp, #22]
	my_buff[24] = 0x20;
	my_buff[26] = 0x20;
	my_buff[29] = 0x04;
	my_buff[33] = 0x4C;
	my_buff[34] = 0x0F;
	my_buff[38] = 0x29;
   13900:	e2833034 	add	r3, r3, #52	; 0x34
   13904:	e5cd3026 	strb	r3, [sp, #38]
	my_buff[54] = 0x46;
   13908:	e283301d 	add	r3, r3, #29	; 0x1d
   1390c:	e5cd3036 	strb	r3, [sp, #54]
	my_buff[55] = 0x41;
   13910:	e3a03041 	mov	r3, #65	; 0x41
   13914:	e5cd3037 	strb	r3, [sp, #55]
	my_buff[56] = 0x54;
   13918:	e2833013 	add	r3, r3, #19	; 0x13
   1391c:	e5cd3038 	strb	r3, [sp, #56]
	my_buff[57] = 0x31;
   13920:	e3a03031 	mov	r3, #49	; 0x31
   13924:	e3a02020 	mov	r2, #32	; 0x20
   13928:	e3a01002 	mov	r1, #2	; 0x2
   1392c:	e5cd3039 	strb	r3, [sp, #57]
	my_buff[58] = 0x36;
   13930:	e2833005 	add	r3, r3, #5	; 0x5
   13934:	e5cd303a 	strb	r3, [sp, #58]
   13938:	e5cd1012 	strb	r1, [sp, #18]
	my_buff[59] = 0x20;
	my_buff[60] = 0x20;
	my_buff[61] = 0x20;
   1393c:	e5cd203d 	strb	r2, [sp, #61]
   13940:	e5cd100c 	strb	r1, [sp, #12]
   13944:	e5cd1010 	strb	r1, [sp, #16]
   13948:	e5cd2018 	strb	r2, [sp, #24]
   1394c:	e5cd201a 	strb	r2, [sp, #26]
   13950:	e5cd203b 	strb	r2, [sp, #59]
   13954:	e5cd203c 	strb	r2, [sp, #60]
   13958:	e5cd601d 	strb	r6, [sp, #29]
   1395c:	e5cd7021 	strb	r7, [sp, #33]
   13960:	e5cd8022 	strb	r8, [sp, #34]
	my_buff[510] = 0x55;
	my_buff[511] = 0xAA;
   13964:	e5cda1ff 	strb	sl, [sp, #511]
   13968:	e5cd51fe 	strb	r5, [sp, #510]
	
	sd_raw_sync();
   1396c:	ebfffecb 	bl	134a0 <sd_raw_sync>
	sd_raw_write(BR_LOCATION, my_buff, 512);
   13970:	e1a0100d 	mov	r1, sp
   13974:	e3a02c02 	mov	r2, #512	; 0x200
   13978:	e3a00702 	mov	r0, #524288	; 0x80000
   1397c:	ebfffe42 	bl	1328c <sd_raw_write>
	sd_raw_sync();
   13980:	ebfffec6 	bl	134a0 <sd_raw_sync>
   13984:	e1a00005 	mov	r0, r5
	
	return(0x55); //Successful format
}
   13988:	e28ddc02 	add	sp, sp, #512	; 0x200
   1398c:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13990:	e12fff1e 	bx	lr
   13994:	000dea00 	andeq	lr, sp, r0, lsl #20

00013998 <fat16_dir_entry_seek_callback>:
{
    struct fat16_read_callback_arg* arg = p;

    /* skip deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
   13998:	e5d03000 	ldrb	r3, [r0]
   1399c:	e3530000 	cmp	r3, #0	; 0x0
   139a0:	135300e5 	cmpne	r3, #229	; 0xe5
   139a4:	0a000015 	beq	13a00 <fat16_dir_entry_seek_callback+0x68>
        return 1;

    if(arg->entry_cur == arg->entry_num)
   139a8:	e1d2c0b0 	ldrh	ip, [r2]
   139ac:	e1d230b2 	ldrh	r3, [r2, #2]
   139b0:	e153000c 	cmp	r3, ip
   139b4:	1a00000b 	bne	139e8 <fat16_dir_entry_seek_callback+0x50>
    {
        arg->entry_offset = offset;
   139b8:	e5821004 	str	r1, [r2, #4]
        arg->byte_count = buffer[11] == 0x0f ?
   139bc:	e5d0300b 	ldrb	r3, [r0, #11]
   139c0:	e353000f 	cmp	r3, #15	; 0xf
   139c4:	05d03000 	ldreqb	r3, [r0]
   139c8:	0203303f 	andeq	r3, r3, #63	; 0x3f
   139cc:	01a03283 	moveq	r3, r3, lsl #5
   139d0:	02833020 	addeq	r3, r3, #32	; 0x20
   139d4:	e3a01020 	mov	r1, #32	; 0x20
   139d8:	e3a00000 	mov	r0, #0	; 0x0
   139dc:	020310ff 	andeq	r1, r3, #255	; 0xff
   139e0:	e5c21008 	strb	r1, [r2, #8]
   139e4:	e12fff1e 	bx	lr
        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
        32;
        return 0;
    }

    /* if we read a 8.3 entry, we reached a new directory entry */
    if(buffer[11] != 0x0f)
   139e8:	e5d0300b 	ldrb	r3, [r0, #11]
        ++arg->entry_cur;
   139ec:	e28c1001 	add	r1, ip, #1	; 0x1
   139f0:	e353000f 	cmp	r3, #15	; 0xf
   139f4:	e3a00001 	mov	r0, #1	; 0x1
   139f8:	11c210b0 	strneh	r1, [r2]
   139fc:	112fff1e 	bxne	lr
   13a00:	e3a00001 	mov	r0, #1	; 0x1

    return 1;
}
   13a04:	e12fff1e 	bx	lr

00013a08 <fat16_dir_entry_read_callback>:

/**
 * \ingroup fat16_fs
 * Callback function for reading a directory entry.
 */
uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
{
   13a08:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    struct fat16_dir_entry_struct* dir_entry = p;

    /* there should not be any deleted or empty entries */
    if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
   13a0c:	e5d03000 	ldrb	r3, [r0]
   13a10:	e3530000 	cmp	r3, #0	; 0x0
   13a14:	135300e5 	cmpne	r3, #229	; 0xe5
   13a18:	e1a0c002 	mov	ip, r2
   13a1c:	0a000062 	beq	13bac <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    if(!dir_entry->entry_offset)
   13a20:	e5923028 	ldr	r3, [r2, #40]
   13a24:	e3530000 	cmp	r3, #0	; 0x0
        dir_entry->entry_offset = offset;
   13a28:	05821028 	streq	r1, [r2, #40]

    switch(fat16_interpret_dir_entry(dir_entry, buffer))
    {
        case 0: /* failure */
            return 0;
            case 1: /* buffer successfully parsed, continue */
            return 1;
            case 2: /* directory entry complete, finish */
            return 0;
        }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Interprets a raw directory entry and puts the contained
 * information into the directory entry.
 *
 * For a single file there may exist multiple directory
 * entries. All except the last one are lfn entries, which
 * contain parts of the long filename. The last directory
 * entry is a traditional 8.3 style one. It contains all
 * other information like size, cluster, date and time.
 *
 * \param[in,out] dir_entry The directory entry to fill.
 * \param[in] raw_entry A pointer to 32 bytes of raw data.
 * \returns 0 on failure, 1 on success and 2 if the
 *          directory entry is complete.
 */
uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entry)
{
    if(!dir_entry || !raw_entry || !raw_entry[0])
   13a2c:	e5d02000 	ldrb	r2, [r0]
   13a30:	e3520000 	cmp	r2, #0	; 0x0
   13a34:	0a00005c 	beq	13bac <fat16_dir_entry_read_callback+0x1a4>
        return 0;

    char* long_name = dir_entry->long_name;
    if(raw_entry[11] == 0x0f)
   13a38:	e5d0300b 	ldrb	r3, [r0, #11]
   13a3c:	e353000f 	cmp	r3, #15	; 0xf
   13a40:	e280500b 	add	r5, r0, #11	; 0xb
   13a44:	1a000026 	bne	13ae4 <fat16_dir_entry_read_callback+0xdc>
    {
        uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
   13a48:	e202203f 	and	r2, r2, #63	; 0x3f
   13a4c:	e3a0300d 	mov	r3, #13	; 0xd
   13a50:	e0030392 	mul	r3, r2, r3
   13a54:	e243300d 	sub	r3, r3, #13	; 0xd
   13a58:	e1a03803 	mov	r3, r3, lsl #16
   13a5c:	e1a02823 	mov	r2, r3, lsr #16

        if(char_offset + 12 < sizeof(dir_entry->long_name))
   13a60:	e282300c 	add	r3, r2, #12	; 0xc
   13a64:	e353001f 	cmp	r3, #31	; 0x1f
   13a68:	83a00001 	movhi	r0, #1	; 0x1
   13a6c:	8a00004f 	bhi	13bb0 <fat16_dir_entry_read_callback+0x1a8>
        {
            /* Lfn supports unicode, but we do not, for now.
                                                 * So we assume pure ascii and read only every
                                                 * second byte.
                                                 */
            long_name[char_offset + 0] = raw_entry[1];
   13a70:	e5d03001 	ldrb	r3, [r0, #1]
   13a74:	e7cc3002 	strb	r3, [ip, r2]
            long_name[char_offset + 1] = raw_entry[3];
   13a78:	e5d03003 	ldrb	r3, [r0, #3]
   13a7c:	e08c2002 	add	r2, ip, r2
   13a80:	e5c23001 	strb	r3, [r2, #1]
            long_name[char_offset + 2] = raw_entry[5];
   13a84:	e5d03005 	ldrb	r3, [r0, #5]
   13a88:	e5c23002 	strb	r3, [r2, #2]
            long_name[char_offset + 3] = raw_entry[7];
   13a8c:	e5d03007 	ldrb	r3, [r0, #7]
   13a90:	e5c23003 	strb	r3, [r2, #3]
            long_name[char_offset + 4] = raw_entry[9];
   13a94:	e5d03009 	ldrb	r3, [r0, #9]
   13a98:	e5c23004 	strb	r3, [r2, #4]
            long_name[char_offset + 5] = raw_entry[14];
   13a9c:	e5d0300e 	ldrb	r3, [r0, #14]
   13aa0:	e5c23005 	strb	r3, [r2, #5]
            long_name[char_offset + 6] = raw_entry[16];
   13aa4:	e5d03010 	ldrb	r3, [r0, #16]
   13aa8:	e5c23006 	strb	r3, [r2, #6]
            long_name[char_offset + 7] = raw_entry[18];
   13aac:	e5d03012 	ldrb	r3, [r0, #18]
   13ab0:	e5c23007 	strb	r3, [r2, #7]
            long_name[char_offset + 8] = raw_entry[20];
   13ab4:	e5d03014 	ldrb	r3, [r0, #20]
   13ab8:	e5c23008 	strb	r3, [r2, #8]
            long_name[char_offset + 9] = raw_entry[22];
   13abc:	e5d03016 	ldrb	r3, [r0, #22]
   13ac0:	e5c23009 	strb	r3, [r2, #9]
            long_name[char_offset + 10] = raw_entry[24];
   13ac4:	e5d03018 	ldrb	r3, [r0, #24]
   13ac8:	e5c2300a 	strb	r3, [r2, #10]
            long_name[char_offset + 11] = raw_entry[28];
   13acc:	e5d0301c 	ldrb	r3, [r0, #28]
   13ad0:	e5c2300b 	strb	r3, [r2, #11]
            long_name[char_offset + 12] = raw_entry[30];
   13ad4:	e5d0301e 	ldrb	r3, [r0, #30]
   13ad8:	e3a00001 	mov	r0, #1	; 0x1
   13adc:	e5c2300c 	strb	r3, [r2, #12]
   13ae0:	ea000032 	b	13bb0 <fat16_dir_entry_read_callback+0x1a8>
        }

        return 1;
    }
    else
    {
        /* if we do not have a long name, take the short one */
        if(long_name[0] == '\0')
   13ae4:	e5dc2000 	ldrb	r2, [ip]
   13ae8:	e3520000 	cmp	r2, #0	; 0x0
   13aec:	1a00001d 	bne	13b68 <fat16_dir_entry_read_callback+0x160>
   13af0:	e1a01002 	mov	r1, r2
        {
            uint8_t i;
            for(i = 0; i < 8; ++i)
            {
                if(raw_entry[i] == ' ')
   13af4:	e7d23000 	ldrb	r3, [r2, r0]
   13af8:	e3530020 	cmp	r3, #32	; 0x20
   13afc:	e281e001 	add	lr, r1, #1	; 0x1
   13b00:	0a000004 	beq	13b18 <fat16_dir_entry_read_callback+0x110>
   13b04:	e20e10ff 	and	r1, lr, #255	; 0xff
   13b08:	e3510008 	cmp	r1, #8	; 0x8
                    break;
                long_name[i] = raw_entry[i];
   13b0c:	e7c2300c 	strb	r3, [r2, ip]
   13b10:	e2822001 	add	r2, r2, #1	; 0x1
   13b14:	1afffff6 	bne	13af4 <fat16_dir_entry_read_callback+0xec>
            }
            if(raw_entry[8] != ' ')
   13b18:	e5d03008 	ldrb	r3, [r0, #8]
   13b1c:	e3530020 	cmp	r3, #32	; 0x20
   13b20:	0a00000e 	beq	13b60 <fat16_dir_entry_read_callback+0x158>
            {
                long_name[i++] = '.';
   13b24:	e3a0302e 	mov	r3, #46	; 0x2e
   13b28:	e2812001 	add	r2, r1, #1	; 0x1
   13b2c:	e7cc3001 	strb	r3, [ip, r1]
   13b30:	e20210ff 	and	r1, r2, #255	; 0xff
   13b34:	e1a03000 	mov	r3, r0

                uint8_t j = 8;
                for(; j < 11; ++j)
                {
                    if(raw_entry[j] != ' ')
   13b38:	e5d32008 	ldrb	r2, [r3, #8]
   13b3c:	e3520020 	cmp	r2, #32	; 0x20
   13b40:	e280e003 	add	lr, r0, #3	; 0x3
                    {
                        long_name[i++] = raw_entry[j];
   13b44:	e2814001 	add	r4, r1, #1	; 0x1
   13b48:	e2833001 	add	r3, r3, #1	; 0x1
   13b4c:	0a000003 	beq	13b60 <fat16_dir_entry_read_callback+0x158>
   13b50:	e153000e 	cmp	r3, lr
   13b54:	e7cc2001 	strb	r2, [ip, r1]
   13b58:	e20410ff 	and	r1, r4, #255	; 0xff
   13b5c:	1afffff5 	bne	13b38 <fat16_dir_entry_read_callback+0x130>
                    }
                    else
                    {
                        break;
                    }
                }
            }

            long_name[i] = '\0';
   13b60:	e3a03000 	mov	r3, #0	; 0x0
   13b64:	e7cc3001 	strb	r3, [ip, r1]
        }

        /* extract properties of file and store them within the structure */
        dir_entry->attributes = raw_entry[11];
   13b68:	e5d53000 	ldrb	r3, [r5]
   13b6c:	e5cc3020 	strb	r3, [ip, #32]
        dir_entry->cluster = ((uint16_t) raw_entry[26]) |
   13b70:	e5d0201b 	ldrb	r2, [r0, #27]
   13b74:	e5d0301a 	ldrb	r3, [r0, #26]
   13b78:	e1833402 	orr	r3, r3, r2, lsl #8
   13b7c:	e1cc32b2 	strh	r3, [ip, #34]
        ((uint16_t) raw_entry[27] << 8);
        dir_entry->file_size = ((uint32_t) raw_entry[28]) |
   13b80:	e5d0301e 	ldrb	r3, [r0, #30]
   13b84:	e5d0201c 	ldrb	r2, [r0, #28]
   13b88:	e5d0101d 	ldrb	r1, [r0, #29]
   13b8c:	e5d0001f 	ldrb	r0, [r0, #31]
   13b90:	e1a03803 	mov	r3, r3, lsl #16
   13b94:	e1833c00 	orr	r3, r3, r0, lsl #24
   13b98:	e1822401 	orr	r2, r2, r1, lsl #8
   13b9c:	e1822003 	orr	r2, r2, r3
   13ba0:	e3a00000 	mov	r0, #0	; 0x0
   13ba4:	e58c2024 	str	r2, [ip, #36]
   13ba8:	ea000000 	b	13bb0 <fat16_dir_entry_read_callback+0x1a8>
   13bac:	e3a00000 	mov	r0, #0	; 0x0
   13bb0:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   13bb4:	e12fff1e 	bx	lr

00013bb8 <fat16_get_next_cluster>:
        ((uint32_t) raw_entry[29] << 8) |
        ((uint32_t) raw_entry[30] << 16) |
        ((uint32_t) raw_entry[31] << 24);

        return 2;
    }
}

/**
 * \ingroup fat16_file
 * Retrieves the directory entry of a path.
 *
 * The given path may both describe a file or a directory.
 *
 * \param[in] fs The FAT16 filesystem on which to search.
 * \param[in] path The path of which to read the directory entry.
 * \param[out] dir_entry The directory entry to fill.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !path || path[0] == '\0' || !dir_entry)
        return 0;

    if(path[0] == '/')
        ++path;

    /* begin with the root directory */
    memset(dir_entry, 0, sizeof(*dir_entry));
    dir_entry->attributes = FAT16_ATTRIB_DIR;

    if(path[0] == '\0')
        return 1;

    while(1)
    {
        struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
        if(!dd)
            break;

        /* extract the next hierarchy we will search for */
        const char* sep_pos = strchr(path, '/');
        if(!sep_pos)
            sep_pos = path + strlen(path);
        uint8_t length_to_sep = sep_pos - path;

        /* read directory entries */
        while(fat16_read_dir(dd, dir_entry))
        {
            /* check if we have found the next hierarchy */
            if((strlen(dir_entry->long_name) != length_to_sep ||
                strncmp(path, dir_entry->long_name, length_to_sep) != 0))
            continue;

            fat16_close_dir(dd);
            dd = 0;

            if(path[length_to_sep] == '\0')
    /* we iterated through the whole path and have found the file */
                return 1;

            if(dir_entry->attributes & FAT16_ATTRIB_DIR)
            {
                /* we found a parent directory of the file we are searching for */
                path = sep_pos + 1;
                break;
            }

            /* a parent of the file exists, but not the file itself */
            return 0;
        }

        fat16_close_dir(dd);
    }

    return 0;
}

/**
 * \ingroup fat16_fs
 * Retrieves the next following cluster of a given cluster.
 *
 * Using the filesystem file allocation table, this function returns
 * the number of the cluster containing the data directly following
 * the data within the cluster with the given number.
 *
 * \param[in] fs The filesystem for which to determine the next cluster.
 * \param[in] cluster_num The number of the cluster for which to determine its successor.
 * \returns The wanted cluster number, or 0 on error.
 */
uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
   13bb8:	e52de004 	str	lr, [sp, #-4]!
   13bbc:	e1a03801 	mov	r3, r1, lsl #16
   13bc0:	e1a03823 	mov	r3, r3, lsr #16
   13bc4:	e24dd004 	sub	sp, sp, #4	; 0x4
    if(!fs || cluster_num < 2)
        return 0;

    /* read appropriate fat entry */
    uint8_t fat_entry[2];
    if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
   13bc8:	e3a02002 	mov	r2, #2	; 0x2
   13bcc:	e3500000 	cmp	r0, #0	; 0x0
   13bd0:	13530001 	cmpne	r3, #1	; 0x1
   13bd4:	e08d1002 	add	r1, sp, r2
   13bd8:	e1a0c000 	mov	ip, r0
   13bdc:	9a00001a 	bls	13c4c <fat16_get_next_cluster+0x94>
   13be0:	e5900008 	ldr	r0, [r0, #8]
   13be4:	e0200293 	mla	r0, r3, r2, r0
   13be8:	e59c3000 	ldr	r3, [ip]
   13bec:	e593c000 	ldr	ip, [r3]
   13bf0:	e1a0e00f 	mov	lr, pc
   13bf4:	e12fff1c 	bx	ip
   13bf8:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    /* determine next cluster from fat */
    cluster_num = ((uint16_t) fat_entry[0]) |
    ((uint16_t) fat_entry[1] << 8);
	///*
    if(cluster_num == FAT16_CLUSTER_FREE ||
   13bfc:	e59f1058 	ldr	r1, [pc, #88]	; 13c5c <.text+0x3c5c>
   13c00:	0a000011 	beq	13c4c <fat16_get_next_cluster+0x94>
   13c04:	e5dd2002 	ldrb	r2, [sp, #2]
   13c08:	e5dd3003 	ldrb	r3, [sp, #3]
   13c0c:	e1920403 	orrs	r0, r2, r3, lsl #8
   13c10:	13a03000 	movne	r3, #0	; 0x0
   13c14:	03a03001 	moveq	r3, #1	; 0x1
   13c18:	e1500001 	cmp	r0, r1
   13c1c:	03833001 	orreq	r3, r3, #1	; 0x1
   13c20:	e2802010 	add	r2, r0, #16	; 0x10
   13c24:	e3530000 	cmp	r3, #0	; 0x0
   13c28:	e1a02802 	mov	r2, r2, lsl #16
   13c2c:	1a000006 	bne	13c4c <fat16_get_next_cluster+0x94>
   13c30:	e1500001 	cmp	r0, r1
   13c34:	93a03000 	movls	r3, #0	; 0x0
   13c38:	83a03001 	movhi	r3, #1	; 0x1
   13c3c:	e3520806 	cmp	r2, #393216	; 0x60000
   13c40:	93833001 	orrls	r3, r3, #1	; 0x1
   13c44:	e3530000 	cmp	r3, #0	; 0x0
   13c48:	0a000000 	beq	13c50 <fat16_get_next_cluster+0x98>
        cluster_num == FAT16_CLUSTER_BAD ||
       (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
       (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
    //*/
	return 0;

    return cluster_num;
   13c4c:	e3a00000 	mov	r0, #0	; 0x0
}
   13c50:	e28dd004 	add	sp, sp, #4	; 0x4
   13c54:	e49de004 	ldr	lr, [sp], #4
   13c58:	e12fff1e 	bx	lr
   13c5c:	0000fff7 	streqd	pc, [r0], -r7

00013c60 <fat16_free_clusters>:

/**
 * \ingroup fat16_fs
 * Appends a new cluster chain to an existing one.
 *
 * Set cluster_num to zero to create a completely new one.
 *
 * \param[in] fs The file system on which to operate.
 * \param[in] cluster_num The cluster to which to append the new chain.
 * \param[in] count The number of clusters to allocate.
 * \returns 0 on failure, the number of the first new cluster on success.
 */
uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t count)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs)
            return 0;
    
        device_read_t device_read = fs->partition->device_read;
        device_write_t device_write = fs->partition->device_write;
        uint32_t fat_offset = fs->header.fat_offset;
        uint16_t cluster_max = fs->header.fat_size / 2;
        uint16_t cluster_next = 0;
        uint16_t count_left = count;
        uint8_t buffer[2];
        uint16_t cluster_new;
        for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
        {
            if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                return 0;
    
            /* check if this is a free cluster */
            if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
                buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
            {
                /* allocate cluster */
                if(count_left == count)
                {
                    buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
                    buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
                }
                else
                {
                    buffer[0] = cluster_next & 0xff;
                    buffer[1] = (cluster_next >> 8) & 0xff;
                }
    
                if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
                    break;
    
                cluster_next = cluster_new;
                if(--count_left == 0)
                    break;
            }
        }
    
        do
        {
            if(count_left > 0)
                break;
    
            /* We allocated a new cluster chain. Now join
                                             * it with the existing one.
                                             */
            if(cluster_num >= 2)
            {
                buffer[0] = cluster_next & 0xff;
                buffer[1] = (cluster_next >> 8) & 0xff;
                if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
                    break;
            }
    
            return cluster_next;
    
        }
        while(0);
    
        /* No space left on device or writing error.
                             * Free up all clusters already allocated.
                             */
        fat16_free_clusters(fs, cluster_next);
    
        return 0;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_fs
 * Frees a cluster chain, or a part thereof.
 *
 * Marks the specified cluster and all clusters which are sequentially
 * referenced by it as free. They may then be used again for future
 * file allocations.
 *
 * \note If this function is used for freeing just a part of a cluster
 *       chain, the new end of the chain is not correctly terminated
 *       within the FAT. Use fat16_terminate_clusters() instead.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The starting cluster of the chain which to free.
 * \returns 0 on failure, 1 on success.
 * \see fat16_terminate_clusters
 */
uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
   13c60:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   13c64:	e1a01801 	mov	r1, r1, lsl #16
   13c68:	e1a03821 	mov	r3, r1, lsr #16
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
   13c6c:	e3500000 	cmp	r0, #0	; 0x0
   13c70:	13530001 	cmpne	r3, #1	; 0x1
   13c74:	e24dd004 	sub	sp, sp, #4	; 0x4
   13c78:	e1a05000 	mov	r5, r0
            return 0;
    
        uint32_t fat_offset = fs->header.fat_offset;
   13c7c:	85907008 	ldrhi	r7, [r0, #8]
   13c80:	8a00001d 	bhi	13cfc <fat16_free_clusters+0x9c>
   13c84:	ea000024 	b	13d1c <fat16_free_clusters+0xbc>
        uint8_t buffer[2];
        while(cluster_num)
        {
            if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
   13c88:	e5953000 	ldr	r3, [r5]
   13c8c:	e593c000 	ldr	ip, [r3]
   13c90:	e1a0e00f 	mov	lr, pc
   13c94:	e12fff1c 	bx	ip
                return 0;
    
            /* get next cluster of current cluster before freeing current cluster */
            uint16_t cluster_num_next = ((uint16_t) buffer[0]) |
            ((uint16_t) buffer[1] << 8);
    
            if(cluster_num_next == FAT16_CLUSTER_FREE)
                return 1;
            if(cluster_num_next == FAT16_CLUSTER_BAD ||
                (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
               cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
               )
               )
            return 0;
			///*
            if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
                (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
               )
			//*/
            cluster_num_next = 0;
    
            /* free cluster */
            buffer[0] = FAT16_CLUSTER_FREE & 0xff;
   13c98:	e3a0e000 	mov	lr, #0	; 0x0
   13c9c:	e150000e 	cmp	r0, lr
            buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
            fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
   13ca0:	e1a01006 	mov	r1, r6
   13ca4:	e3a02002 	mov	r2, #2	; 0x2
   13ca8:	e1a00004 	mov	r0, r4
   13cac:	0a00001a 	beq	13d1c <fat16_free_clusters+0xbc>
   13cb0:	e5dd3002 	ldrb	r3, [sp, #2]
   13cb4:	e5ddc003 	ldrb	ip, [sp, #3]
   13cb8:	e193340c 	orrs	r3, r3, ip, lsl #8
   13cbc:	e1a04003 	mov	r4, r3
   13cc0:	e2833010 	add	r3, r3, #16	; 0x10
   13cc4:	e1a03803 	mov	r3, r3, lsl #16
   13cc8:	0a000015 	beq	13d24 <fat16_free_clusters+0xc4>
   13ccc:	e3530807 	cmp	r3, #458752	; 0x70000
   13cd0:	9a000011 	bls	13d1c <fat16_free_clusters+0xbc>
   13cd4:	e59f3058 	ldr	r3, [pc, #88]	; 13d34 <.text+0x3d34>
   13cd8:	e5cde003 	strb	lr, [sp, #3]
   13cdc:	e5cde002 	strb	lr, [sp, #2]
   13ce0:	e1540003 	cmp	r4, r3
   13ce4:	81a0400e 	movhi	r4, lr
   13ce8:	e5953000 	ldr	r3, [r5]
   13cec:	e593c008 	ldr	ip, [r3, #8]
   13cf0:	e1a0e00f 	mov	lr, pc
   13cf4:	e12fff1c 	bx	ip
   13cf8:	e1a03004 	mov	r3, r4
   13cfc:	e0874083 	add	r4, r7, r3, lsl #1
   13d00:	e28d6002 	add	r6, sp, #2	; 0x2
   13d04:	e3530000 	cmp	r3, #0	; 0x0
   13d08:	e1a01006 	mov	r1, r6
   13d0c:	e3a02002 	mov	r2, #2	; 0x2
   13d10:	e1a00004 	mov	r0, r4
   13d14:	1affffdb 	bne	13c88 <fat16_free_clusters+0x28>
   13d18:	ea000001 	b	13d24 <fat16_free_clusters+0xc4>
   13d1c:	e3a00000 	mov	r0, #0	; 0x0
   13d20:	ea000000 	b	13d28 <fat16_free_clusters+0xc8>
   13d24:	e3a00001 	mov	r0, #1	; 0x1
    
            /* We continue in any case here, even if freeing the cluster failed.
                                             * The cluster is lost, but maybe we can still free up some later ones.
                                             */
    
            cluster_num = cluster_num_next;
        }
    
        return 1;
    #else
        return 0;
    #endif
}
   13d28:	e28dd004 	add	sp, sp, #4	; 0x4
   13d2c:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   13d30:	e12fff1e 	bx	lr
   13d34:	0000fff7 	streqd	pc, [r0], -r7

00013d38 <fat16_append_clusters>:
   13d38:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13d3c:	e1a01801 	mov	r1, r1, lsl #16
   13d40:	e24dd014 	sub	sp, sp, #20	; 0x14
   13d44:	e1a02802 	mov	r2, r2, lsl #16
   13d48:	e1a01821 	mov	r1, r1, lsr #16
   13d4c:	e2507000 	subs	r7, r0, #0	; 0x0
   13d50:	e58d1000 	str	r1, [sp]
   13d54:	e1a09822 	mov	r9, r2, lsr #16
   13d58:	0a00004e 	beq	13e98 <fat16_append_clusters+0x160>
   13d5c:	e5972000 	ldr	r2, [r7]
   13d60:	e597300c 	ldr	r3, [r7, #12]
   13d64:	e5921008 	ldr	r1, [r2, #8]
   13d68:	e1a03783 	mov	r3, r3, lsl #15
   13d6c:	e3a04000 	mov	r4, #0	; 0x0
   13d70:	e5922000 	ldr	r2, [r2]
   13d74:	e597b008 	ldr	fp, [r7, #8]
   13d78:	e1a03823 	mov	r3, r3, lsr #16
   13d7c:	e1a05009 	mov	r5, r9
   13d80:	e1a0a004 	mov	sl, r4
   13d84:	e58d1008 	str	r1, [sp, #8]
   13d88:	e58d2004 	str	r2, [sp, #4]
   13d8c:	e58d300c 	str	r3, [sp, #12]
   13d90:	ea000023 	b	13e24 <fat16_append_clusters+0xec>
   13d94:	e08b8086 	add	r8, fp, r6, lsl #1
   13d98:	e1a00008 	mov	r0, r8
   13d9c:	e28d1012 	add	r1, sp, #18	; 0x12
   13da0:	e3a02002 	mov	r2, #2	; 0x2
   13da4:	e59d3004 	ldr	r3, [sp, #4]
   13da8:	e1a0e00f 	mov	lr, pc
   13dac:	e12fff13 	bx	r3
   13db0:	e3500000 	cmp	r0, #0	; 0x0
   13db4:	0a000037 	beq	13e98 <fat16_append_clusters+0x160>
   13db8:	e5dd3012 	ldrb	r3, [sp, #18]
   13dbc:	e3530000 	cmp	r3, #0	; 0x0
   13dc0:	1a000016 	bne	13e20 <fat16_append_clusters+0xe8>
   13dc4:	e5dd3013 	ldrb	r3, [sp, #19]
   13dc8:	e3530000 	cmp	r3, #0	; 0x0
   13dcc:	1a000013 	bne	13e20 <fat16_append_clusters+0xe8>
   13dd0:	e1550009 	cmp	r5, r9
   13dd4:	03e03000 	mvneq	r3, #0	; 0x0
   13dd8:	11a03424 	movne	r3, r4, lsr #8
   13ddc:	05cd3013 	streqb	r3, [sp, #19]
   13de0:	05cd3012 	streqb	r3, [sp, #18]
   13de4:	15cd3013 	strneb	r3, [sp, #19]
   13de8:	15cd4012 	strneb	r4, [sp, #18]
   13dec:	e1a00008 	mov	r0, r8
   13df0:	e28d1012 	add	r1, sp, #18	; 0x12
   13df4:	e3a02002 	mov	r2, #2	; 0x2
   13df8:	e59d3008 	ldr	r3, [sp, #8]
   13dfc:	e1a0e00f 	mov	lr, pc
   13e00:	e12fff13 	bx	r3
   13e04:	e3500000 	cmp	r0, #0	; 0x0
   13e08:	0a00000a 	beq	13e38 <fat16_append_clusters+0x100>
   13e0c:	e2453001 	sub	r3, r5, #1	; 0x1
   13e10:	e1a03803 	mov	r3, r3, lsl #16
   13e14:	e1b05823 	movs	r5, r3, lsr #16
   13e18:	0a000019 	beq	13e84 <fat16_append_clusters+0x14c>
   13e1c:	e1a04006 	mov	r4, r6
   13e20:	e28aa001 	add	sl, sl, #1	; 0x1
   13e24:	e59d100c 	ldr	r1, [sp, #12]
   13e28:	e1a0380a 	mov	r3, sl, lsl #16
   13e2c:	e15a0001 	cmp	sl, r1
   13e30:	e1a06823 	mov	r6, r3, lsr #16
   13e34:	1affffd6 	bne	13d94 <fat16_append_clusters+0x5c>
   13e38:	e3550000 	cmp	r5, #0	; 0x0
   13e3c:	1a000012 	bne	13e8c <fat16_append_clusters+0x154>
   13e40:	e59d3000 	ldr	r3, [sp]
   13e44:	e3530001 	cmp	r3, #1	; 0x1
   13e48:	9a00000b 	bls	13e7c <fat16_append_clusters+0x144>
   13e4c:	e59d1000 	ldr	r1, [sp]
   13e50:	e1a03424 	mov	r3, r4, lsr #8
   13e54:	e5cd3013 	strb	r3, [sp, #19]
   13e58:	e08b0081 	add	r0, fp, r1, lsl #1
   13e5c:	e5cd4012 	strb	r4, [sp, #18]
   13e60:	e28d1012 	add	r1, sp, #18	; 0x12
   13e64:	e3a02002 	mov	r2, #2	; 0x2
   13e68:	e59d3008 	ldr	r3, [sp, #8]
   13e6c:	e1a0e00f 	mov	lr, pc
   13e70:	e12fff13 	bx	r3
   13e74:	e3500000 	cmp	r0, #0	; 0x0
   13e78:	0a000003 	beq	13e8c <fat16_append_clusters+0x154>
   13e7c:	e1a00004 	mov	r0, r4
   13e80:	ea000005 	b	13e9c <fat16_append_clusters+0x164>
   13e84:	e1a04006 	mov	r4, r6
   13e88:	eaffffec 	b	13e40 <fat16_append_clusters+0x108>
   13e8c:	e1a00007 	mov	r0, r7
   13e90:	e1a01004 	mov	r1, r4
   13e94:	ebffff71 	bl	13c60 <fat16_free_clusters>
   13e98:	e3a00000 	mov	r0, #0	; 0x0
   13e9c:	e28dd014 	add	sp, sp, #20	; 0x14
   13ea0:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13ea4:	e12fff1e 	bx	lr

00013ea8 <fat16_read_file>:

/**
 * \ingroup fat16_fs
 * Frees a part of a cluster chain and correctly terminates the rest.
 *
 * Marks the specified cluster as the new end of a cluster chain and
 * frees all following clusters.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] cluster_num The new end of the cluster chain.
 * \returns 0 on failure, 1 on success.
 * \see fat16_free_clusters
 */
uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || cluster_num < 2)
            return 0;
    
        /* fetch next cluster before overwriting the cluster entry */
        uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
    
        /* mark cluster as the last one */
        uint8_t buffer[2];
        buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
        buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
        if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
            return 0;
    
        /* free remaining clusters */
        if(cluster_num_next)
            return fat16_free_clusters(fs, cluster_num_next);
        else
            return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Opens a file on a FAT16 filesystem.
 *
 * \param[in] fs The filesystem on which the file to open lies.
 * \param[in] dir_entry The directory entry of the file to open.
 * \returns The file handle, or 0 on failure.
 * \see fat16_close_file
 */
struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_file_struct* fd = malloc(sizeof(*fd));
    if(!fd)
        return 0;

    memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
    fd->fs = fs;
    fd->pos = 0;
    fd->pos_cluster = dir_entry->cluster;

    return fd;
}

/**
 * \ingroup fat16_file
 * Closes a file.
 *
 * \param[in] fd The file handle of the file to close.
 * \see fat16_open_file
 */
void fat16_close_file(struct fat16_file_struct* fd)
{
    if(fd)
        free(fd);
}

/**
 * \ingroup fat16_file
 * Reads data from a file.
 *
 * The data requested is read from the current file location.
 *
 * \param[in] fd The file handle of the file from which to read.
 * \param[out] buffer The buffer into which to write.
 * \param[in] buffer_len The amount of data to read.
 * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 * \see fat16_write_file
 */
int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
{
   13ea8:	e1a02802 	mov	r2, r2, lsl #16
    /* check arguments */
    if(!fd || !buffer || buffer_len < 1)
   13eac:	e3510000 	cmp	r1, #0	; 0x0
   13eb0:	13500000 	cmpne	r0, #0	; 0x0
   13eb4:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13eb8:	e1a06000 	mov	r6, r0
   13ebc:	e1a0b001 	mov	fp, r1
   13ec0:	e1a08822 	mov	r8, r2, lsr #16
   13ec4:	0a000050 	beq	1400c <fat16_read_file+0x164>
   13ec8:	e3580000 	cmp	r8, #0	; 0x0
   13ecc:	0a00004e 	beq	1400c <fat16_read_file+0x164>
        return -1;

    /* determine number of bytes to read */
    if(fd->pos + buffer_len > fd->dir_entry.file_size)
   13ed0:	e5907030 	ldr	r7, [r0, #48]
   13ed4:	e5902028 	ldr	r2, [r0, #40]
   13ed8:	e0873008 	add	r3, r7, r8
   13edc:	e1530002 	cmp	r3, r2
   13ee0:	9a000003 	bls	13ef4 <fat16_read_file+0x4c>
        buffer_len = fd->dir_entry.file_size - fd->pos;
   13ee4:	e0673002 	rsb	r3, r7, r2
   13ee8:	e1a03803 	mov	r3, r3, lsl #16
    if(buffer_len == 0)
   13eec:	e1b08823 	movs	r8, r3, lsr #16
   13ef0:	0a000050 	beq	14038 <fat16_read_file+0x190>
        return 0;

    uint16_t cluster_size = fd->fs->header.cluster_size;
    uint16_t cluster_num = fd->pos_cluster;
   13ef4:	e1d653b4 	ldrh	r5, [r6, #52]
   13ef8:	e5963000 	ldr	r3, [r6]
    uint16_t buffer_left = buffer_len;
    uint16_t first_cluster_offset = fd->pos % cluster_size;

    /* find cluster in which to start reading */
    if(!cluster_num)
   13efc:	e3550000 	cmp	r5, #0	; 0x0
   13f00:	e1d391b2 	ldrh	r9, [r3, #18]
   13f04:	1a000011 	bne	13f50 <fat16_read_file+0xa8>
    {
        cluster_num = fd->dir_entry.cluster;
   13f08:	e1d652b6 	ldrh	r5, [r6, #38]

        if(!cluster_num)
   13f0c:	e3550000 	cmp	r5, #0	; 0x0
   13f10:	1a000002 	bne	13f20 <fat16_read_file+0x78>
        {
            if(!fd->pos)
   13f14:	e3570000 	cmp	r7, #0	; 0x0
   13f18:	0a000046 	beq	14038 <fat16_read_file+0x190>
   13f1c:	ea00003a 	b	1400c <fat16_read_file+0x164>
                return 0;
            else
                return -1;
        }

        if(fd->pos)
   13f20:	e3570000 	cmp	r7, #0	; 0x0
   13f24:	11a04007 	movne	r4, r7
   13f28:	1a000004 	bne	13f40 <fat16_read_file+0x98>
   13f2c:	ea000007 	b	13f50 <fat16_read_file+0xa8>
        {
            uint32_t pos = fd->pos;
            while(pos >= cluster_size)
            {
                pos -= cluster_size;
                cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
   13f30:	e5960000 	ldr	r0, [r6]
   13f34:	ebffff1f 	bl	13bb8 <fat16_get_next_cluster>
                if(!cluster_num)
   13f38:	e2505000 	subs	r5, r0, #0	; 0x0
   13f3c:	0a000032 	beq	1400c <fat16_read_file+0x164>
   13f40:	e1540009 	cmp	r4, r9
   13f44:	e1a01005 	mov	r1, r5
   13f48:	e0694004 	rsb	r4, r9, r4
   13f4c:	2afffff7 	bcs	13f30 <fat16_read_file+0x88>
   13f50:	e1a00007 	mov	r0, r7
   13f54:	e1a01009 	mov	r1, r9
   13f58:	eb000f64 	bl	17cf0 <__umodsi3>
   13f5c:	e1a00800 	mov	r0, r0, lsl #16
   13f60:	e1a0a820 	mov	sl, r0, lsr #16
   13f64:	e1a07008 	mov	r7, r8
                    return -1;
            }
        }
    }

    /* read data */
    do
    {
        /* calculate data size to copy from cluster */
        uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
        (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
        uint16_t copy_length = cluster_size - first_cluster_offset;
   13f68:	e06a3009 	rsb	r3, sl, r9
   13f6c:	e596c000 	ldr	ip, [r6]
   13f70:	e1a03803 	mov	r3, r3, lsl #16
   13f74:	e1a03823 	mov	r3, r3, lsr #16
   13f78:	e1570003 	cmp	r7, r3
   13f7c:	31a03007 	movcc	r3, r7
        if(copy_length > buffer_left)
            copy_length = buffer_left;

        /* read data */
        if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
   13f80:	e59c2018 	ldr	r2, [ip, #24]
   13f84:	e1a03803 	mov	r3, r3, lsl #16
   13f88:	e1a04823 	mov	r4, r3, lsr #16
   13f8c:	e08a2002 	add	r2, sl, r2
   13f90:	e2453002 	sub	r3, r5, #2	; 0x2
   13f94:	e0202399 	mla	r0, r9, r3, r2
   13f98:	e1a0100b 	mov	r1, fp
   13f9c:	e1a02004 	mov	r2, r4
   13fa0:	e59c3000 	ldr	r3, [ip]
   13fa4:	e593c000 	ldr	ip, [r3]
   13fa8:	e1a0e00f 	mov	lr, pc
   13fac:	e12fff1c 	bx	ip
            return buffer_len - buffer_left;

        /* calculate new file position */
        buffer += copy_length;
        buffer_left -= copy_length;
   13fb0:	e0643007 	rsb	r3, r4, r7
   13fb4:	e3500000 	cmp	r0, #0	; 0x0
        fd->pos += copy_length;

        if(first_cluster_offset + copy_length >= cluster_size)
        {
            /* we are on a cluster boundary, so get the next cluster */
            if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
   13fb8:	e1a01005 	mov	r1, r5
   13fbc:	e08bb004 	add	fp, fp, r4
   13fc0:	e08a2004 	add	r2, sl, r4
   13fc4:	e1a00803 	mov	r0, r3, lsl #16
   13fc8:	0a000011 	beq	14014 <fat16_read_file+0x16c>
   13fcc:	e5963030 	ldr	r3, [r6, #48]
   13fd0:	e1520009 	cmp	r2, r9
   13fd4:	e0833004 	add	r3, r3, r4
   13fd8:	e5863030 	str	r3, [r6, #48]
   13fdc:	e1a07820 	mov	r7, r0, lsr #16
   13fe0:	ba000004 	blt	13ff8 <fat16_read_file+0x150>
   13fe4:	e5960000 	ldr	r0, [r6]
   13fe8:	ebfffef2 	bl	13bb8 <fat16_get_next_cluster>
   13fec:	e2505000 	subs	r5, r0, #0	; 0x0
            {
                first_cluster_offset = 0;
            }
            else
            {
                fd->pos_cluster = 0;
                return buffer_len - buffer_left;
   13ff0:	e3a0a000 	mov	sl, #0	; 0x0
   13ff4:	0a00000a 	beq	14024 <fat16_read_file+0x17c>
            }
        }

        fd->pos_cluster = cluster_num;

    }
    while(buffer_left > 0); /* check if we are done */
   13ff8:	e3570000 	cmp	r7, #0	; 0x0
   13ffc:	e1c653b4 	strh	r5, [r6, #52]
   14000:	1affffd8 	bne	13f68 <fat16_read_file+0xc0>

    return buffer_len;
   14004:	e1a03808 	mov	r3, r8, lsl #16
   14008:	ea000003 	b	1401c <fat16_read_file+0x174>
   1400c:	e3e00000 	mvn	r0, #0	; 0x0
   14010:	ea000009 	b	1403c <fat16_read_file+0x194>
   14014:	e0673008 	rsb	r3, r7, r8
   14018:	e1a03803 	mov	r3, r3, lsl #16
   1401c:	e1a00843 	mov	r0, r3, asr #16
   14020:	ea000005 	b	1403c <fat16_read_file+0x194>
   14024:	e0673008 	rsb	r3, r7, r8
   14028:	e1a03803 	mov	r3, r3, lsl #16
   1402c:	e1a00843 	mov	r0, r3, asr #16
   14030:	e1c653b4 	strh	r5, [r6, #52]
   14034:	ea000000 	b	1403c <fat16_read_file+0x194>
   14038:	e3a00000 	mov	r0, #0	; 0x0
}
   1403c:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14040:	e12fff1e 	bx	lr

00014044 <fat16_reset_dir>:

/**
 * \ingroup fat16_file
 * Writes data to a file.
 *
 * The data is written to the current file location.
 *
 * \param[in] fd The file handle of the file to which to write.
 * \param[in] buffer The buffer from which to read the data to be written.
 * \param[in] buffer_len The amount of data to write.
 * \returns The number of bytes written, 0 on disk full, or -1 on failure.
 * \see fat16_read_file
 */
int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
{
    #if FAT16_WRITE_SUPPORT
        /* check arguments */
        if(!fd || !buffer || buffer_len < 1)
            return -1;
        if(fd->pos > fd->dir_entry.file_size)
            return -1;
    
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint16_t cluster_num = fd->pos_cluster;
        uint16_t buffer_left = buffer_len;
        uint16_t first_cluster_offset = fd->pos % cluster_size;
    
        /* find cluster in which to start writing */
        if(!cluster_num)
        {
            cluster_num = fd->dir_entry.cluster;
    
            if(!cluster_num)
            {
                if(!fd->pos)
                {
                    /* empty file */
                    fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
                    if(!cluster_num)
                        return -1;
                }
                else
                {
                    return -1;
                }
            }
    
            if(fd->pos)
            {
                uint32_t pos = fd->pos;
                uint16_t cluster_num_next;
                while(pos >= cluster_size)
                {
                    pos -= cluster_size;
                    cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                    if(!cluster_num_next && pos == 0)
        /* the file exactly ends on a cluster boundary, and we append to it */
                        cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                    if(!cluster_num_next)
                        return -1;
    
                    cluster_num = cluster_num_next;
                }
            }
        }
    
        /* write data */
        do
        {
            /* calculate data size to write to cluster */
            uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
            (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
            uint16_t write_length = cluster_size - first_cluster_offset;
            if(write_length > buffer_left)
                write_length = buffer_left;
    
            /* write data which fits into the current cluster */
            if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
                break;
    
            /* calculate new file position */
            buffer += write_length;
            buffer_left -= write_length;
            fd->pos += write_length;
    
            if(first_cluster_offset + write_length >= cluster_size)
            {
                /* we are on a cluster boundary, so get the next cluster */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(!cluster_num_next && buffer_left > 0)
        /* we reached the last cluster, append a new one */
                    cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
                if(!cluster_num_next)
                {
                    fd->pos_cluster = 0;
                    break;
                }
    
                cluster_num = cluster_num_next;
                first_cluster_offset = 0;
            }
    
            fd->pos_cluster = cluster_num;
    
        }
        while(buffer_left > 0); /* check if we are done */
    
        /* update directory entry */
        if(fd->pos > fd->dir_entry.file_size)
        {
            uint32_t size_old = fd->dir_entry.file_size;
    
            /* update file size */
            fd->dir_entry.file_size = fd->pos;
            /* write directory entry */
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
            {
                /* We do not return an error here since we actually wrote
                                                             * some data to disk. So we calculate the amount of data
                                                             * we wrote to disk and which lies within the old file size.
                                                             */
                buffer_left = fd->pos - size_old;
                fd->pos = size_old;
            }
        }
    
        return buffer_len - buffer_left;
    
    #else
        return -1;
    #endif
}

/**
 * \ingroup fat16_file
 * Repositions the read/write file offset.
 *
 * Changes the file offset where the next call to fat16_read_file()
 * or fat16_write_file() starts reading/writing.
 *
 * If the new offset is beyond the end of the file, fat16_resize_file()
 * is implicitly called, i.e. the file is expanded.
 *
 * The new offset can be given in different ways determined by
 * the \c whence parameter:
 * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
 * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
 * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
 *
 * The resulting absolute offset is written to the location the \c offset
 * parameter points to.
 *
 * \param[in] fd The file decriptor of the file on which to seek.
 * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
 *                   parameter. The function writes the new absolute offset
 *                   to this location before it returns.
 * \param[in] whence Affects the way \c offset is interpreted, see above.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
{
    if(!fd || !offset)
        return 0;

    uint32_t new_pos = fd->pos;
    switch(whence)
    {
        case FAT16_SEEK_SET:
            new_pos = *offset;
            break;
        case FAT16_SEEK_CUR:
            new_pos += *offset;
            break;
        case FAT16_SEEK_END:
            new_pos = fd->dir_entry.file_size + *offset;
            break;
        default:
            return 0;
    }

    if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
        return 0;

    fd->pos = new_pos;
    fd->pos_cluster = 0;

    *offset = new_pos;
    return 1;
}

/**
 * \ingroup fat16_file
 * Resizes a file to have a specific size.
 *
 * Enlarges or shrinks the file pointed to by the file descriptor to have
 * exactly the specified size.
 *
 * If the file is truncated, all bytes having an equal or larger offset
 * than the given size are lost. If the file is expanded, the additional
 * bytes are allocated.
 *
 * \note Please be aware that this function just allocates or deallocates disk
 * space, it does not explicitely clear it. To avoid data leakage, this
 * must be done manually.
 *
 * \param[in] fd The file decriptor of the file which to resize.
 * \param[in] size The new size of the file.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
{
    #if FAT16_WRITE_SUPPORT
        if(!fd)
            return 0;
    
        uint16_t cluster_num = fd->dir_entry.cluster;
        uint16_t cluster_size = fd->fs->header.cluster_size;
        uint32_t size_new = size;
    
        do
        {
            if(cluster_num == 0 && size_new == 0)
        /* the file stays empty */
                break;
    
            /* seek to the next cluster as long as we need the space */
            while(size_new > cluster_size)
            {
                /* get next cluster of file */
                uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
                if(cluster_num_next)
                {
                    cluster_num = cluster_num_next;
                    size_new -= cluster_size;
                }
                else
                {
                    break;
                }
            }
    
            if(size_new > cluster_size || cluster_num == 0)
            {
                /* Allocate new cluster chain and append
                                                             * it to the existing one, if available.
                                                             */
                uint16_t cluster_count = size_new / cluster_size;
                if((uint32_t) cluster_count * cluster_size < size_new)
                    ++cluster_count;
                uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_count);
                if(!cluster_new_chain)
                    return 0;
    
                if(!cluster_num)
                {
                    cluster_num = cluster_new_chain;
                    fd->dir_entry.cluster = cluster_num;
                }
            }
    
            /* write new directory entry */
            fd->dir_entry.file_size = size;
            if(size == 0)
                fd->dir_entry.cluster = 0;
            if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
                return 0;
    
            if(size == 0)
            {
                /* free all clusters of file */
                fat16_free_clusters(fd->fs, cluster_num);
            }
            else if(size_new <= cluster_size)
            {
                /* free all clusters no longer needed */
                fat16_terminate_clusters(fd->fs, cluster_num);
            }
    
        }
        while(0);
    
        /* correct file position */
        if(size < fd->pos)
        {
            fd->pos = size;
            fd->pos_cluster = 0;
        }
    
        return 1;
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_dir
 * Opens a directory.
 *
 * \param[in] fs The filesystem on which the directory to open resides.
 * \param[in] dir_entry The directory entry which stands for the directory to open.
 * \returns An opaque directory descriptor on success, 0 on failure.
 * \see fat16_close_dir
 */
struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
        return 0;

    struct fat16_dir_struct* dd = malloc(sizeof(*dd));
    if(!dd)
        return 0;

    memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
    dd->fs = fs;
    dd->entry_next = 0;

    return dd;
}

/**
 * \ingroup fat16_dir
 * Closes a directory descriptor.
 *
 * This function destroys a directory descriptor which was
 * previously obtained by calling fat16_open_dir(). When this
 * function returns, the given descriptor will be invalid.
 *
 * \param[in] dd The directory descriptor to close.
 * \see fat16_open_dir
 */
void fat16_close_dir(struct fat16_dir_struct* dd)
{
    if(dd)
        free(dd);
}

/**
 * \ingroup fat16_dir
 * Reads the next directory entry contained within a parent directory.
 *
 * \param[in] dd The descriptor of the parent directory from which to read the entry.
 * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
 * \returns 0 on failure, 1 on success.
 * \see fat16_reset_dir
 */
uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
{
    if(!dd || !dir_entry)
        return 0;

    if(dd->dir_entry.cluster == 0)
    {
        /* read entry from root directory */
        if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }
    else
    {
        /* read entry from a subdirectory */
        if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
        {
            ++dd->entry_next;
            return 1;
        }
    }

    /* restart reading */
    dd->entry_next = 0;

    return 0;
}

/**
 * \ingroup fat16_dir
 * Resets a directory handle.
 *
 * Resets the directory handle such that reading restarts
 * with the first directory entry.
 *
 * \param[in] dd The directory handle to reset.
 * \returns 0 on failure, 1 on success.
 * \see fat16_read_dir
 */
uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
{
    if(!dd)
   14044:	e3500000 	cmp	r0, #0	; 0x0
   14048:	e1a03000 	mov	r3, r0
        return 0;

    dd->entry_next = 0;
   1404c:	13a03000 	movne	r3, #0	; 0x0
   14050:	11c033b0 	strneh	r3, [r0, #48]
   14054:	13a03001 	movne	r3, #1	; 0x1
    return 1;
}
   14058:	e1a00003 	mov	r0, r3
   1405c:	e12fff1e 	bx	lr

00014060 <fat16_set_dir>:

uint8_t fat16_set_dir(struct fat16_dir_struct* dd, uint16_t offset)
{
    if(!dd)
   14060:	e3500000 	cmp	r0, #0	; 0x0
   14064:	e1a01801 	mov	r1, r1, lsl #16
   14068:	e1a03000 	mov	r3, r0
   1406c:	e1a01821 	mov	r1, r1, lsr #16
        return 0;

    dd->entry_next = offset;
   14070:	13a03001 	movne	r3, #1	; 0x1
   14074:	11c013b0 	strneh	r1, [r0, #48]
    return 1;
}
   14078:	e1a00003 	mov	r0, r3
   1407c:	e12fff1e 	bx	lr

00014080 <fat16_delete_file>:

/**
 * \ingroup fat16_fs
 * Writes a directory entry to disk.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry to write.
 * \returns 0 on failure, 1 on success.
 */
uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
            return 0;
    
        device_write_t device_write = fs->partition->device_write;
        uint32_t offset = dir_entry->entry_offset;
        uint8_t name_len = strlen(dir_entry->long_name);
        uint8_t lfn_entry_count = (name_len + 12) / 13;
        uint8_t buffer[32];
    
        /* write 8.3 entry */
    
        /* generate 8.3 file name */
        memset(&buffer[0], ' ', 11);
        char* name_ext = strrchr(dir_entry->long_name, '.');
        if(name_ext)
        {
            ++name_ext;
    
            uint8_t name_ext_len = strlen(name_ext);
            name_len -= name_ext_len + 1;
    
            if(name_ext_len > 3)
                name_ext_len = 3;
    
            memcpy(&buffer[8], name_ext, name_ext_len);
        }
    
        if(name_len <= 8)
        {
            memcpy(buffer, dir_entry->long_name, name_len);
        }
        else
        {
            memcpy(buffer, dir_entry->long_name, 8);
    
            /* Minimize 8.3 name clashes by appending
                                             * the lower byte of the cluster number.
                                             */
            uint8_t num = dir_entry->cluster & 0xff;
    
            buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
            num &= 0x0f;
            buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
        }
    
        /* fill directory entry buffer */
        memset(&buffer[11], 0, sizeof(buffer) - 11);
        buffer[0x0b] = dir_entry->attributes;

        //Not used in bootloader
		#ifdef MAIN_FIRMWARE
			//Added modified date/time 12-26-07
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			char * current_time;
/*			current_time = GPS_get_time();
			char * current_date;
			current_date = GPS_get_date();
			
			uint16_t modified_time, modified_date;
			uint8_t c_hour, c_minute, c_second;
			uint8_t c_year, c_month, c_day;
			
			c_hour = (current_time[0] - '0') * 10;
			c_hour += (current_time[1] - '0');
			c_minute = (current_time[3] - '0') * 10;
			c_minute += (current_time[4] - '0');
			c_second = (current_time[6] - '0') * 10;
			c_second += (current_time[7] - '0');
			
			c_day = (current_date[0] - '0') * 10;
			c_day += (current_date[1] - '0');
			c_month = (current_date[3] - '0') * 10;
			c_month += (current_date[4] - '0');
			c_year = (current_date[6] - '0') * 10;
			c_year += (current_date[7] - '0');
			
			//Correct for 1980 = 0, 2000 = 20, year code
			c_year += 20;
			
			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);

			//Do a little error correction
			if (c_year < 26) //26 = 2006
			{
				modified_time = 0;
				modified_date = 0;
			}

			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
			//rprintf("mod_time=%x\n", modified_time);
			//rprintf("mod_date=%x\n", modified_date);
			
			buffer[0x16] = (modified_time >> 0) & 0xFF;
			buffer[0x17] = (modified_time >> 8) & 0xFF;
			buffer[0x18] = (modified_date >> 0) & 0xFF;
			buffer[0x19] = (modified_date >> 8) & 0xFF;
			*/
			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
		#endif

        buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
        buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
        buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
        buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
        buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
        buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
    
        /* write to disk */
        if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
            return 0;
    
        /* calculate checksum of 8.3 name */
        uint8_t checksum = buffer[0];
        uint8_t i;
        for(i = 1; i < 11; ++i)
            checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
    
        /* write lfn entries */
        uint8_t lfn_entry;
        for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
        {
            memset(buffer, 0, sizeof(buffer));
            memset(&buffer[0x01], 0xff, 10);
            memset(&buffer[0x0e], 0xff, 12);
            memset(&buffer[0x1c], 0xff, 4);
    
            buffer[0x00] = lfn_entry;
            if(lfn_entry == lfn_entry_count)
                buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
    
            /* set file name */
            const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
            i = 1;
            while(i < 0x1f)
            {
                buffer[i++] = *long_name_curr;
                buffer[i++] = 0;
    
                switch(i)
                {
                    case 0x0b:
                        i = 0x0e;
                        break;
                    case 0x1a:
                        i = 0x1c;
                        break;
                }
    
                if(!*long_name_curr++)
                    break;
            }
    
            /* mark as lfn entry */
            buffer[0x0b] = 0x0f;
    
            /* set checksum */
            buffer[0x0d] = checksum;
    
            /* write entry */
            device_write(offset, buffer, sizeof(buffer));
    
            offset += sizeof(buffer);
        }
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Creates a file.
 *
 * Creates a file and obtains the directory entry of the
 * new file. If the file to create already exists, the
 * directory entry of the existing file will be returned
 * within the dir_entry parameter.
 *
 * \note The file name is not checked for invalid characters.
 *
 * \note The generation of the short 8.3 file name is quite
 * simple. The first eight characters are used for the filename.
 * The extension, if any, is made up of the first three characters
 * following the last dot within the long filename. If the
 * filename (without the extension) is longer than eight characters,
 * the lower byte of the cluster number replaces the last two
 * characters to avoid name clashes. In any other case, it is your
 * responsibility to avoid name clashes.
 *
 * \param[in] parent The handle of the directory in which to create the file.
 * \param[in] file The name of the file to create.
 * \param[out] dir_entry The directory entry to fill for the new file.
 * \returns 0 on failure, 1 on success.
 * \see fat16_delete_file
 */
uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry_struct* dir_entry)
{
    #if FAT16_WRITE_SUPPORT
        if(!parent || !file || !file[0])
            return 0;
    
        /* check if the file already exists */
        while(1)
        {
            if(!fat16_read_dir(parent, dir_entry))
                break;
    
            if(strcmp(file, dir_entry->long_name) == 0)
            {
                fat16_reset_dir(parent);
                return 1;
            }
        }
    
        memset(dir_entry, 0, sizeof(*dir_entry));
        strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
    
        /* search for a place where to write the directory entry to disk */
        uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
        uint8_t free_dir_entries_found = 0;
        struct fat16_fs_struct* fs = parent->fs;
        uint16_t cluster_num = parent->dir_entry.cluster;
        uint32_t dir_entry_offset = 0;
        uint32_t offset = 0;
        uint32_t offset_to = 0;
    
        if(cluster_num == 0)
        {
            /* we read/write from the root directory entry */
            offset = fs->header.root_dir_offset;
            offset_to = fs->header.cluster_zero_offset;
            dir_entry_offset = offset;
        }
    
        while(1)
        {
            if(offset == offset_to)
            {
                if(cluster_num == 0)
				/* We iterated through the whole root directory entry
                * and could not find enough space for the directory entry.
                */
                return 0;
    
                if(offset)
                {
                    /* We reached a cluster boundary and have to
                    * switch to the next cluster.
                    */
    
                    uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
                    if(!cluster_next)
                    {
                        cluster_next = fat16_append_clusters(fs, cluster_num, 1);
                        if(!cluster_next)
                            return 0;
    
                        /* we appended a new cluster and know it is free */
                        dir_entry_offset = fs->header.cluster_zero_offset +
                        (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
    
                        /* TODO: This cluster has to be zeroed in an efficient way, or at least
                        *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
                        */
                        break;
                    }
                    cluster_num = cluster_next;
                }
    
                offset = fs->header.cluster_zero_offset +
                (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
                offset_to = offset + fs->header.cluster_size;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
    
            /* read next lfn or 8.3 entry */
            uint8_t first_char;
            if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
                return 0;
    
            /* check if we found a free directory entry */
            if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
            {
                /* check if we have the needed number of available entries */
                ++free_dir_entries_found;
                if(free_dir_entries_found >= free_dir_entries_needed)
                    break;
    
                offset += 32;
            }
            else
            {
                offset += 32;
                dir_entry_offset = offset;
                free_dir_entries_found = 0;
            }
        }

        /* write directory entry to disk */
        dir_entry->entry_offset = dir_entry_offset;
        if(!fat16_write_dir_entry(fs, dir_entry))
            return 0;
    
        return 1;
    
    #else
        return 0;
    #endif
}

/**
 * \ingroup fat16_file
 * Deletes a file or directory.
 *
 * It is not checked if the file to delete is a directory.
 * If a directory is deleted without first deleting its
 * subdirectories and files, disk space occupied by these
 * files will get wasted as there is no chance to release
 * it and mark it as free.
 *
 * \param[in] fs The filesystem on which to operate.
 * \param[in] dir_entry The directory entry of the file to delete.
 * \returns 0 on failure, 1 on success.
 * \see fat16_create_file
 */
uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
{
   14080:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    #if FAT16_WRITE_SUPPORT
        if(!fs || !dir_entry)
   14084:	e3510000 	cmp	r1, #0	; 0x0
   14088:	13500000 	cmpne	r0, #0	; 0x0
   1408c:	e24dd00c 	sub	sp, sp, #12	; 0xc
   14090:	e1a06000 	mov	r6, r0
   14094:	e1a07001 	mov	r7, r1
   14098:	0a00001f 	beq	1411c <fat16_delete_file+0x9c>
            return 0;
    
        /* get offset of the file's directory entry */
        uint32_t dir_entry_offset = dir_entry->entry_offset;
   1409c:	e5915028 	ldr	r5, [r1, #40]
        if(!dir_entry_offset)
   140a0:	e3550000 	cmp	r5, #0	; 0x0
   140a4:	0a00001c 	beq	1411c <fat16_delete_file+0x9c>
            return 0;
    
        uint8_t buffer[12];
        while(1)
        {
            /* read directory entry */
            if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
   140a8:	e1a0100d 	mov	r1, sp
   140ac:	e1a00005 	mov	r0, r5
   140b0:	e3a0200c 	mov	r2, #12	; 0xc
   140b4:	e5963000 	ldr	r3, [r6]
   140b8:	e593c000 	ldr	ip, [r3]
   140bc:	e1a0e00f 	mov	lr, pc
   140c0:	e12fff1c 	bx	ip
   140c4:	e3500000 	cmp	r0, #0	; 0x0
   140c8:	e1a0400d 	mov	r4, sp
                return 0;
    
            /* mark the directory entry as deleted */
            buffer[0] = FAT16_DIRENTRY_DELETED;
    
            /* write back entry */
            if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
   140cc:	e1a00005 	mov	r0, r5
   140d0:	e1a0100d 	mov	r1, sp
   140d4:	e3a0200c 	mov	r2, #12	; 0xc
                return 0;
    
            /* check if we deleted the whole entry */
            if(buffer[11] != 0x0f)
                break;
    
            dir_entry_offset += 32;
   140d8:	e2855020 	add	r5, r5, #32	; 0x20
   140dc:	0a00000e 	beq	1411c <fat16_delete_file+0x9c>
   140e0:	e3e0301a 	mvn	r3, #26	; 0x1a
   140e4:	e5cd3000 	strb	r3, [sp]
   140e8:	e5963000 	ldr	r3, [r6]
   140ec:	e593c008 	ldr	ip, [r3, #8]
   140f0:	e1a0e00f 	mov	lr, pc
   140f4:	e12fff1c 	bx	ip
   140f8:	e3500000 	cmp	r0, #0	; 0x0
   140fc:	0a000006 	beq	1411c <fat16_delete_file+0x9c>
   14100:	e5dd300b 	ldrb	r3, [sp, #11]
   14104:	e353000f 	cmp	r3, #15	; 0xf
   14108:	0affffe6 	beq	140a8 <fat16_delete_file+0x28>
        }
    
        /* We deleted the directory entry. The next thing to do is
                             * marking all occupied clusters as free.
                             */
        return fat16_free_clusters(fs, dir_entry->cluster);
   1410c:	e1a00006 	mov	r0, r6
   14110:	e1d712b2 	ldrh	r1, [r7, #34]
   14114:	ebfffed1 	bl	13c60 <fat16_free_clusters>
   14118:	ea000000 	b	14120 <fat16_delete_file+0xa0>
   1411c:	e3a00000 	mov	r0, #0	; 0x0
    #else
        return 0;
    #endif
}
   14120:	e28dd00c 	add	sp, sp, #12	; 0xc
   14124:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   14128:	e12fff1e 	bx	lr

0001412c <fat16_get_fs_size>:

/**
 * \ingroup fat16_fs
 * Returns the amount of total storage capacity of the filesystem in bytes.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the filesystem size in bytes otherwise.
 */
uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
{
    if(!fs)
   1412c:	e3500000 	cmp	r0, #0	; 0x0
        return 0;

    return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
   14130:	1590300c 	ldrne	r3, [r0, #12]
   14134:	e1a02000 	mov	r2, r0
   14138:	11a030a3 	movne	r3, r3, lsr #1
   1413c:	11d021b2 	ldrneh	r2, [r0, #18]
   14140:	12433002 	subne	r3, r3, #2	; 0x2
   14144:	10020293 	mulne	r2, r3, r2
}
   14148:	e1a00002 	mov	r0, r2
   1414c:	e12fff1e 	bx	lr

00014150 <fat16_get_fs_free>:

/**
 * \ingroup fat16_fs
 * Returns the amount of free storage capacity on the filesystem in bytes.
 *
 * \note As the FAT16 filesystem is cluster based, this function does not
 *       return continuous values but multiples of the cluster size.
 *
 * \param[in] fs The filesystem on which to operate.
 * \returns 0 on failure, the free filesystem space in bytes otherwise.
 */
uint32_t fat16_get_fs_free(const struct fat16_fs_struct* fs)
{
   14150:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    if(!fs)
   14154:	e2506000 	subs	r6, r0, #0	; 0x0
   14158:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   1415c:	0a000021 	beq	141e8 <fat16_get_fs_free+0x98>
        return 0;

    uint8_t fat[32];
    struct fat16_usage_count_callback_arg count_arg;
    count_arg.cluster_count = 0;
    count_arg.buffer_size = sizeof(fat);
   14160:	e3a03020 	mov	r3, #32	; 0x20
   14164:	e5cd302a 	strb	r3, [sp, #42]

    uint32_t fat_offset = fs->header.fat_offset;
   14168:	e5967008 	ldr	r7, [r6, #8]
    uint32_t fat_size = fs->header.fat_size;
   1416c:	e596500c 	ldr	r5, [r6, #12]
   14170:	e3a03000 	mov	r3, #0	; 0x0
   14174:	e1cd32b8 	strh	r3, [sp, #40]
   14178:	ea000012 	b	141c8 <fat16_get_fs_free+0x78>
    while(fat_size > 0)
    {
        uint16_t length = UINT16_MAX - 1;
        if(fat_size < length)
   1417c:	e59f3074 	ldr	r3, [pc, #116]	; 141f8 <.text+0x41f8>
   14180:	e1550003 	cmp	r5, r3
            length = fat_size;

        if(!fs->partition->device_read_interval(fat_offset,
   14184:	e59f3070 	ldr	r3, [pc, #112]	; 141fc <.text+0x41fc>
   14188:	91a04822 	movls	r4, r2, lsr #16
   1418c:	e596c000 	ldr	ip, [r6]
   14190:	e58d3000 	str	r3, [sp]
   14194:	e28d3028 	add	r3, sp, #40	; 0x28
   14198:	e58d3004 	str	r3, [sp, #4]
   1419c:	e1a00007 	mov	r0, r7
   141a0:	e28d1008 	add	r1, sp, #8	; 0x8
   141a4:	e3a02020 	mov	r2, #32	; 0x20
   141a8:	e1a03004 	mov	r3, r4
   141ac:	e59cc004 	ldr	ip, [ip, #4]
   141b0:	e1a0e00f 	mov	lr, pc
   141b4:	e12fff1c 	bx	ip
   141b8:	e3500000 	cmp	r0, #0	; 0x0
   141bc:	0a000009 	beq	141e8 <fat16_get_fs_free+0x98>
            fat,
           sizeof(fat),
           length,
           fat16_get_fs_free_callback,
           &count_arg
           )
           )
        return 0;

        fat_offset += length;
        fat_size -= length;
   141c0:	e0645005 	rsb	r5, r4, r5
   141c4:	e0877004 	add	r7, r7, r4
   141c8:	e3550000 	cmp	r5, #0	; 0x0
   141cc:	e59f402c 	ldr	r4, [pc, #44]	; 14200 <.text+0x4200>
   141d0:	e1a02805 	mov	r2, r5, lsl #16
   141d4:	1affffe8 	bne	1417c <fat16_get_fs_free+0x2c>
    }

    return (uint32_t) count_arg.cluster_count * fs->header.cluster_size;
   141d8:	e1d621b2 	ldrh	r2, [r6, #18]
   141dc:	e1dd32b8 	ldrh	r3, [sp, #40]
   141e0:	e0000392 	mul	r0, r2, r3
   141e4:	ea000000 	b	141ec <fat16_get_fs_free+0x9c>
   141e8:	e3a00000 	mov	r0, #0	; 0x0
}
   141ec:	e28dd02c 	add	sp, sp, #44	; 0x2c
   141f0:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   141f4:	e12fff1e 	bx	lr
   141f8:	0000fffd 	streqd	pc, [r0], -sp
   141fc:	00014204 	andeq	r4, r1, r4, lsl #4
   14200:	0000fffe 	streqd	pc, [r0], -lr

00014204 <fat16_get_fs_free_callback>:

/**
 * \ingroup fat16_fs
 * Callback function used for counting free clusters.
 */
uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p)
{
   14204:	e92d4010 	stmdb	sp!, {r4, lr}
    struct fat16_usage_count_callback_arg* count_arg = (struct fat16_usage_count_callback_arg*) p;
    uint8_t buffer_size = count_arg->buffer_size;
   14208:	e5d24002 	ldrb	r4, [r2, #2]
   1420c:	e1a0c002 	mov	ip, r2
   14210:	e1a01000 	mov	r1, r0
   14214:	e3a0e000 	mov	lr, #0	; 0x0
   14218:	ea000007 	b	1423c <fat16_get_fs_free_callback+0x38>
    uint8_t i;
    for(i = 0; i < buffer_size; i += 2)
    {
        if((((uint16_t) buffer[1] << 8) | ((uint16_t) buffer[0] << 0)) == FAT16_CLUSTER_FREE)
   1421c:	e7de3000 	ldrb	r3, [lr, r0]
   14220:	e5d12001 	ldrb	r2, [r1, #1]
   14224:	e1932402 	orrs	r2, r3, r2, lsl #8
            ++(count_arg->cluster_count);
   14228:	01dc30b0 	ldreqh	r3, [ip]
   1422c:	02833001 	addeq	r3, r3, #1	; 0x1
   14230:	01cc30b0 	streqh	r3, [ip]

        buffer += 2;
   14234:	e2811002 	add	r1, r1, #2	; 0x2
   14238:	e28ee002 	add	lr, lr, #2	; 0x2
   1423c:	e20e30ff 	and	r3, lr, #255	; 0xff
   14240:	e1530004 	cmp	r3, r4
   14244:	3afffff4 	bcc	1421c <fat16_get_fs_free_callback+0x18>
    }

    return 1;
}
   14248:	e3a00001 	mov	r0, #1	; 0x1
   1424c:	e8bd4010 	ldmia	sp!, {r4, lr}
   14250:	e12fff1e 	bx	lr

00014254 <fat16_file_size>:

uint8_t find_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name, struct fat16_dir_entry_struct* dir_entry)
{
    while(fat16_read_dir(dd, dir_entry))
    {
        if(strcmp(dir_entry->long_name, name) == 0)
        {
            fat16_reset_dir(dd);
            return 1;
        }
    }

    return 0;
}

struct fat16_file_struct* open_file_in_dir(struct fat16_fs_struct* fs, struct fat16_dir_struct* dd, const char* name)
{
    struct fat16_dir_entry_struct file_entry;
    if(!find_file_in_dir(fs, dd, name, &file_entry))
        return 0;

    return fat16_open_file(fs, &file_entry);
}

int fat16_file_size(struct fat16_file_struct * file)
{
    return(file->dir_entry.file_size);
}
   14254:	e5900028 	ldr	r0, [r0, #40]
   14258:	e12fff1e 	bx	lr

0001425c <fat16_read_dir>:
   1425c:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14260:	e1a0a001 	mov	sl, r1
   14264:	e2711001 	rsbs	r1, r1, #1	; 0x1
   14268:	33a01000 	movcc	r1, #0	; 0x0
   1426c:	e35a0000 	cmp	sl, #0	; 0x0
   14270:	13500000 	cmpne	r0, #0	; 0x0
   14274:	e24dd038 	sub	sp, sp, #56	; 0x38
   14278:	e1a08000 	mov	r8, r0
   1427c:	0a000076 	beq	1445c <fat16_read_dir+0x200>
   14280:	e1d032b6 	ldrh	r3, [r0, #38]
   14284:	e3530000 	cmp	r3, #0	; 0x0
   14288:	e1d093b0 	ldrh	r9, [r0, #48]
   1428c:	e5906000 	ldr	r6, [r0]
   14290:	1a00002c 	bne	14348 <fat16_read_dir+0xec>
   14294:	e3560000 	cmp	r6, #0	; 0x0
   14298:	11a07001 	movne	r7, r1
   1429c:	03817001 	orreq	r7, r1, #1	; 0x1
   142a0:	e3570000 	cmp	r7, #0	; 0x0
   142a4:	1a00006a 	bne	14454 <fat16_read_dir+0x1f8>
   142a8:	e5963000 	ldr	r3, [r6]
   142ac:	e28d502c 	add	r5, sp, #44	; 0x2c
   142b0:	e2864004 	add	r4, r6, #4	; 0x4
   142b4:	e1a01007 	mov	r1, r7
   142b8:	e3a0200c 	mov	r2, #12	; 0xc
   142bc:	e1a00005 	mov	r0, r5
   142c0:	e5936004 	ldr	r6, [r3, #4]
   142c4:	eb000cb3 	bl	17598 <memset>
   142c8:	e2840010 	add	r0, r4, #16	; 0x10
   142cc:	e8900009 	ldmia	r0, {r0, r3}
   142d0:	e59f2194 	ldr	r2, [pc, #404]	; 1446c <.text+0x446c>
   142d4:	e0603003 	rsb	r3, r0, r3
   142d8:	e1a03803 	mov	r3, r3, lsl #16
   142dc:	e28d400c 	add	r4, sp, #12	; 0xc
   142e0:	e58d2000 	str	r2, [sp]
   142e4:	e1cd92be 	strh	r9, [sp, #46]
   142e8:	e58d5004 	str	r5, [sp, #4]
   142ec:	e1a03823 	mov	r3, r3, lsr #16
   142f0:	e1a01004 	mov	r1, r4
   142f4:	e3a02020 	mov	r2, #32	; 0x20
   142f8:	e1a0e00f 	mov	lr, pc
   142fc:	e12fff16 	bx	r6
   14300:	e3500000 	cmp	r0, #0	; 0x0
   14304:	0a000052 	beq	14454 <fat16_read_dir+0x1f8>
   14308:	e59d3030 	ldr	r3, [sp, #48]
   1430c:	e3530000 	cmp	r3, #0	; 0x0
   14310:	0a00004f 	beq	14454 <fat16_read_dir+0x1f8>
   14314:	e1a01007 	mov	r1, r7
   14318:	e3a0202c 	mov	r2, #44	; 0x2c
   1431c:	e1a0000a 	mov	r0, sl
   14320:	eb000c9c 	bl	17598 <memset>
   14324:	e59f2144 	ldr	r2, [pc, #324]	; 14470 <.text+0x4470>
   14328:	e5dd3034 	ldrb	r3, [sp, #52]
   1432c:	e88d0404 	stmia	sp, {r2, sl}
   14330:	e1a01004 	mov	r1, r4
   14334:	e59d0030 	ldr	r0, [sp, #48]
   14338:	e3a02020 	mov	r2, #32	; 0x20
   1433c:	e1a0e00f 	mov	lr, pc
   14340:	e12fff16 	bx	r6
   14344:	ea000039 	b	14430 <fat16_read_dir+0x1d4>
   14348:	e3560000 	cmp	r6, #0	; 0x0
   1434c:	e58d9008 	str	r9, [sp, #8]
   14350:	0a00003f 	beq	14454 <fat16_read_dir+0x1f8>
   14354:	e3510000 	cmp	r1, #0	; 0x0
   14358:	1a00003d 	bne	14454 <fat16_read_dir+0x1f8>
   1435c:	e2800004 	add	r0, r0, #4	; 0x4
   14360:	e5d03020 	ldrb	r3, [r0, #32]
   14364:	e3130010 	tst	r3, #16	; 0x10
   14368:	0a000039 	beq	14454 <fat16_read_dir+0x1f8>
   1436c:	e1d072b2 	ldrh	r7, [r0, #34]
   14370:	e1d691b2 	ldrh	r9, [r6, #18]
   14374:	e5962018 	ldr	r2, [r6, #24]
   14378:	e2473002 	sub	r3, r7, #2	; 0x2
   1437c:	e0252399 	mla	r5, r9, r3, r2
   14380:	e28d402c 	add	r4, sp, #44	; 0x2c
   14384:	e3a01000 	mov	r1, #0	; 0x0
   14388:	e3a0200c 	mov	r2, #12	; 0xc
   1438c:	e1a00004 	mov	r0, r4
   14390:	eb000c80 	bl	17598 <memset>
   14394:	e59d3008 	ldr	r3, [sp, #8]
   14398:	e1cd32be 	strh	r3, [sp, #46]
   1439c:	e59f30c8 	ldr	r3, [pc, #200]	; 1446c <.text+0x446c>
   143a0:	e28db00c 	add	fp, sp, #12	; 0xc
   143a4:	e596c000 	ldr	ip, [r6]
   143a8:	e1a0100b 	mov	r1, fp
   143ac:	e58d3000 	str	r3, [sp]
   143b0:	e1a00005 	mov	r0, r5
   143b4:	e58d4004 	str	r4, [sp, #4]
   143b8:	e3a02020 	mov	r2, #32	; 0x20
   143bc:	e1a03009 	mov	r3, r9
   143c0:	e59cc004 	ldr	ip, [ip, #4]
   143c4:	e1a0e00f 	mov	lr, pc
   143c8:	e12fff1c 	bx	ip
   143cc:	e3500000 	cmp	r0, #0	; 0x0
   143d0:	e1a01007 	mov	r1, r7
   143d4:	e1a00006 	mov	r0, r6
   143d8:	0a00001d 	beq	14454 <fat16_read_dir+0x1f8>
   143dc:	e59d3030 	ldr	r3, [sp, #48]
   143e0:	e3530000 	cmp	r3, #0	; 0x0
   143e4:	1a000003 	bne	143f8 <fat16_read_dir+0x19c>
   143e8:	ebfffdf2 	bl	13bb8 <fat16_get_next_cluster>
   143ec:	e2507000 	subs	r7, r0, #0	; 0x0
   143f0:	0a000017 	beq	14454 <fat16_read_dir+0x1f8>
   143f4:	eaffffde 	b	14374 <fat16_read_dir+0x118>
   143f8:	e3a01000 	mov	r1, #0	; 0x0
   143fc:	e3a0202c 	mov	r2, #44	; 0x2c
   14400:	e1a0000a 	mov	r0, sl
   14404:	eb000c63 	bl	17598 <memset>
   14408:	e59f2060 	ldr	r2, [pc, #96]	; 14470 <.text+0x4470>
   1440c:	e596c000 	ldr	ip, [r6]
   14410:	e5dd3034 	ldrb	r3, [sp, #52]
   14414:	e88d0404 	stmia	sp, {r2, sl}
   14418:	e1a0100b 	mov	r1, fp
   1441c:	e59d0030 	ldr	r0, [sp, #48]
   14420:	e3a02020 	mov	r2, #32	; 0x20
   14424:	e59cc004 	ldr	ip, [ip, #4]
   14428:	e1a0e00f 	mov	lr, pc
   1442c:	e12fff1c 	bx	ip
   14430:	e3500000 	cmp	r0, #0	; 0x0
   14434:	0a000006 	beq	14454 <fat16_read_dir+0x1f8>
   14438:	e5da3000 	ldrb	r3, [sl]
   1443c:	e3530000 	cmp	r3, #0	; 0x0
   14440:	11d833b0 	ldrneh	r3, [r8, #48]
   14444:	13a00001 	movne	r0, #1	; 0x1
   14448:	12833001 	addne	r3, r3, #1	; 0x1
   1444c:	11c833b0 	strneh	r3, [r8, #48]
   14450:	1a000002 	bne	14460 <fat16_read_dir+0x204>
   14454:	e3a03000 	mov	r3, #0	; 0x0
   14458:	e1c833b0 	strh	r3, [r8, #48]
   1445c:	e3a00000 	mov	r0, #0	; 0x0
   14460:	e28dd038 	add	sp, sp, #56	; 0x38
   14464:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14468:	e12fff1e 	bx	lr
   1446c:	00013998 	muleq	r1, r8, r9
   14470:	00013a08 	andeq	r3, r1, r8, lsl #20

00014474 <find_file_in_dir>:
   14474:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   14478:	e1a04001 	mov	r4, r1
   1447c:	e1a06002 	mov	r6, r2
   14480:	e1a05003 	mov	r5, r3
   14484:	ea000007 	b	144a8 <find_file_in_dir+0x34>
   14488:	eb000c57 	bl	175ec <strcmp>
   1448c:	e3500000 	cmp	r0, #0	; 0x0
   14490:	1a000004 	bne	144a8 <find_file_in_dir+0x34>
   14494:	e3540000 	cmp	r4, #0	; 0x0
   14498:	03a03001 	moveq	r3, #1	; 0x1
   1449c:	13a03001 	movne	r3, #1	; 0x1
   144a0:	11c403b0 	strneh	r0, [r4, #48]
   144a4:	ea000006 	b	144c4 <find_file_in_dir+0x50>
   144a8:	e1a01005 	mov	r1, r5
   144ac:	e1a00004 	mov	r0, r4
   144b0:	ebffff69 	bl	1425c <fat16_read_dir>
   144b4:	e2503000 	subs	r3, r0, #0	; 0x0
   144b8:	e1a01006 	mov	r1, r6
   144bc:	e1a00005 	mov	r0, r5
   144c0:	1afffff0 	bne	14488 <find_file_in_dir+0x14>
   144c4:	e1a00003 	mov	r0, r3
   144c8:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   144cc:	e12fff1e 	bx	lr

000144d0 <fat16_write_dir_entry>:
   144d0:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   144d4:	e3510000 	cmp	r1, #0	; 0x0
   144d8:	13500000 	cmpne	r0, #0	; 0x0
   144dc:	e24dd020 	sub	sp, sp, #32	; 0x20
   144e0:	e1a06001 	mov	r6, r1
   144e4:	0a000098 	beq	1474c <fat16_write_dir_entry+0x27c>
   144e8:	e5903000 	ldr	r3, [r0]
   144ec:	e1a00001 	mov	r0, r1
   144f0:	e5939008 	ldr	r9, [r3, #8]
   144f4:	eb000c4e 	bl	17634 <strlen>
   144f8:	e20050ff 	and	r5, r0, #255	; 0xff
   144fc:	e3a0100d 	mov	r1, #13	; 0xd
   14500:	e285000c 	add	r0, r5, #12	; 0xc
   14504:	eb000da8 	bl	17bac <__aeabi_idiv>
   14508:	e3a01020 	mov	r1, #32	; 0x20
   1450c:	e1a03000 	mov	r3, r0
   14510:	e3a0200b 	mov	r2, #11	; 0xb
   14514:	e1a0000d 	mov	r0, sp
   14518:	e203a0ff 	and	sl, r3, #255	; 0xff
   1451c:	e5968028 	ldr	r8, [r6, #40]
   14520:	eb000c1c 	bl	17598 <memset>
   14524:	e1a00006 	mov	r0, r6
   14528:	e3a0102e 	mov	r1, #46	; 0x2e
   1452c:	eb000c6f 	bl	176f0 <strrchr>
   14530:	e3500000 	cmp	r0, #0	; 0x0
   14534:	e1a0700d 	mov	r7, sp
   14538:	0a00000b 	beq	1456c <fat16_write_dir_entry+0x9c>
   1453c:	e2804001 	add	r4, r0, #1	; 0x1
   14540:	e1a00004 	mov	r0, r4
   14544:	eb000c3a 	bl	17634 <strlen>
   14548:	e20020ff 	and	r2, r0, #255	; 0xff
   1454c:	e0623005 	rsb	r3, r2, r5
   14550:	e2433001 	sub	r3, r3, #1	; 0x1
   14554:	e3520003 	cmp	r2, #3	; 0x3
   14558:	23a02003 	movcs	r2, #3	; 0x3
   1455c:	e1a01004 	mov	r1, r4
   14560:	e28d0008 	add	r0, sp, #8	; 0x8
   14564:	e20350ff 	and	r5, r3, #255	; 0xff
   14568:	eb000c02 	bl	17578 <memcpy>
   1456c:	e3550008 	cmp	r5, #8	; 0x8
   14570:	8a000004 	bhi	14588 <fat16_write_dir_entry+0xb8>
   14574:	e1a0000d 	mov	r0, sp
   14578:	e1a02005 	mov	r2, r5
   1457c:	e1a01006 	mov	r1, r6
   14580:	eb000bfc 	bl	17578 <memcpy>
   14584:	ea00000e 	b	145c4 <fat16_write_dir_entry+0xf4>
   14588:	e3a02008 	mov	r2, #8	; 0x8
   1458c:	e1a0000d 	mov	r0, sp
   14590:	e1a01006 	mov	r1, r6
   14594:	eb000bf7 	bl	17578 <memcpy>
   14598:	e5d63022 	ldrb	r3, [r6, #34]
   1459c:	e353009f 	cmp	r3, #159	; 0x9f
   145a0:	e1a02223 	mov	r2, r3, lsr #4
   145a4:	e203300f 	and	r3, r3, #15	; 0xf
   145a8:	92822030 	addls	r2, r2, #48	; 0x30
   145ac:	82822061 	addhi	r2, r2, #97	; 0x61
   145b0:	e3530009 	cmp	r3, #9	; 0x9
   145b4:	92833030 	addls	r3, r3, #48	; 0x30
   145b8:	82833061 	addhi	r3, r3, #97	; 0x61
   145bc:	e5cd2006 	strb	r2, [sp, #6]
   145c0:	e5cd3007 	strb	r3, [sp, #7]
   145c4:	e3a01000 	mov	r1, #0	; 0x0
   145c8:	e3a02015 	mov	r2, #21	; 0x15
   145cc:	e28d000b 	add	r0, sp, #11	; 0xb
   145d0:	eb000bf0 	bl	17598 <memset>
   145d4:	e5d63020 	ldrb	r3, [r6, #32]
   145d8:	e5cd300b 	strb	r3, [sp, #11]
   145dc:	e1d622b2 	ldrh	r2, [r6, #34]
   145e0:	e1a03422 	mov	r3, r2, lsr #8
   145e4:	e5cd201a 	strb	r2, [sp, #26]
   145e8:	e5cd301b 	strb	r3, [sp, #27]
   145ec:	e5963024 	ldr	r3, [r6, #36]
   145f0:	e1a00c23 	mov	r0, r3, lsr #24
   145f4:	e1a02423 	mov	r2, r3, lsr #8
   145f8:	e1a01823 	mov	r1, r3, lsr #16
   145fc:	e5cd201d 	strb	r2, [sp, #29]
   14600:	e5cd101e 	strb	r1, [sp, #30]
   14604:	e5cd001f 	strb	r0, [sp, #31]
   14608:	e5cd301c 	strb	r3, [sp, #28]
   1460c:	e088028a 	add	r0, r8, sl, lsl #5
   14610:	e1a0100d 	mov	r1, sp
   14614:	e3a02020 	mov	r2, #32	; 0x20
   14618:	e1a0e00f 	mov	lr, pc
   1461c:	e12fff19 	bx	r9
   14620:	e3500000 	cmp	r0, #0	; 0x0
   14624:	e1a0400d 	mov	r4, sp
   14628:	0a000047 	beq	1474c <fat16_write_dir_entry+0x27c>
   1462c:	e5dd7000 	ldrb	r7, [sp]
   14630:	e1a0100d 	mov	r1, sp
   14634:	e5f12001 	ldrb	r2, [r1, #1]!
   14638:	e1a03387 	mov	r3, r7, lsl #7
   1463c:	e18330a7 	orr	r3, r3, r7, lsr #1
   14640:	e0833002 	add	r3, r3, r2
   14644:	e28d200a 	add	r2, sp, #10	; 0xa
   14648:	e1510002 	cmp	r1, r2
   1464c:	e20370ff 	and	r7, r3, #255	; 0xff
   14650:	1afffff7 	bne	14634 <fat16_write_dir_entry+0x164>
   14654:	e1a0500a 	mov	r5, sl
   14658:	ea000037 	b	1473c <fat16_write_dir_entry+0x26c>
   1465c:	e3a01000 	mov	r1, #0	; 0x0
   14660:	e3a02020 	mov	r2, #32	; 0x20
   14664:	e1a0000d 	mov	r0, sp
   14668:	eb000bca 	bl	17598 <memset>
   1466c:	e3a010ff 	mov	r1, #255	; 0xff
   14670:	e3a0200a 	mov	r2, #10	; 0xa
   14674:	e28d0001 	add	r0, sp, #1	; 0x1
   14678:	eb000bc6 	bl	17598 <memset>
   1467c:	e3a010ff 	mov	r1, #255	; 0xff
   14680:	e3a0200c 	mov	r2, #12	; 0xc
   14684:	e28d000e 	add	r0, sp, #14	; 0xe
   14688:	eb000bc2 	bl	17598 <memset>
   1468c:	e28d001c 	add	r0, sp, #28	; 0x1c
   14690:	e3a010ff 	mov	r1, #255	; 0xff
   14694:	e3a02004 	mov	r2, #4	; 0x4
   14698:	eb000bbe 	bl	17598 <memset>
   1469c:	e155000a 	cmp	r5, sl
   146a0:	03853040 	orreq	r3, r5, #64	; 0x40
   146a4:	e5cd5000 	strb	r5, [sp]
   146a8:	05cd3000 	streqb	r3, [sp]
   146ac:	e3a0300d 	mov	r3, #13	; 0xd
   146b0:	e02e6395 	mla	lr, r5, r3, r6
   146b4:	e3a0c001 	mov	ip, #1	; 0x1
   146b8:	e28c3001 	add	r3, ip, #1	; 0x1
   146bc:	e20330ff 	and	r3, r3, #255	; 0xff
   146c0:	e2832001 	add	r2, r3, #1	; 0x1
   146c4:	e28d4020 	add	r4, sp, #32	; 0x20
   146c8:	e55e000d 	ldrb	r0, [lr, #-13]
   146cc:	e084100c 	add	r1, r4, ip
   146d0:	e202c0ff 	and	ip, r2, #255	; 0xff
   146d4:	e35c000b 	cmp	ip, #11	; 0xb
   146d8:	e0842003 	add	r2, r4, r3
   146dc:	e3a03000 	mov	r3, #0	; 0x0
   146e0:	e5410020 	strb	r0, [r1, #-32]
   146e4:	03a0c00e 	moveq	ip, #14	; 0xe
   146e8:	e5423020 	strb	r3, [r2, #-32]
   146ec:	0a000001 	beq	146f8 <fat16_write_dir_entry+0x228>
   146f0:	e35c001a 	cmp	ip, #26	; 0x1a
   146f4:	028cc002 	addeq	ip, ip, #2	; 0x2
   146f8:	e55e300d 	ldrb	r3, [lr, #-13]
   146fc:	e3530000 	cmp	r3, #0	; 0x0
   14700:	e28ee001 	add	lr, lr, #1	; 0x1
   14704:	0a000001 	beq	14710 <fat16_write_dir_entry+0x240>
   14708:	e35c001e 	cmp	ip, #30	; 0x1e
   1470c:	9affffe9 	bls	146b8 <fat16_write_dir_entry+0x1e8>
   14710:	e3a0300f 	mov	r3, #15	; 0xf
   14714:	e5cd300b 	strb	r3, [sp, #11]
   14718:	e1a00008 	mov	r0, r8
   1471c:	e5cd700d 	strb	r7, [sp, #13]
   14720:	e1a0100d 	mov	r1, sp
   14724:	e3a02020 	mov	r2, #32	; 0x20
   14728:	e1a0e00f 	mov	lr, pc
   1472c:	e12fff19 	bx	r9
   14730:	e2453001 	sub	r3, r5, #1	; 0x1
   14734:	e2888020 	add	r8, r8, #32	; 0x20
   14738:	e20350ff 	and	r5, r3, #255	; 0xff
   1473c:	e3550000 	cmp	r5, #0	; 0x0
   14740:	1affffc5 	bne	1465c <fat16_write_dir_entry+0x18c>
   14744:	e3a00001 	mov	r0, #1	; 0x1
   14748:	ea000000 	b	14750 <fat16_write_dir_entry+0x280>
   1474c:	e3a00000 	mov	r0, #0	; 0x0
   14750:	e28dd020 	add	sp, sp, #32	; 0x20
   14754:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14758:	e12fff1e 	bx	lr

0001475c <fat16_resize_file>:
   1475c:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14760:	e2506000 	subs	r6, r0, #0	; 0x0
   14764:	e24dd004 	sub	sp, sp, #4	; 0x4
   14768:	e1a0a001 	mov	sl, r1
   1476c:	0a00005b 	beq	148e0 <fat16_resize_file+0x184>
   14770:	e1d642b6 	ldrh	r4, [r6, #38]
   14774:	e5963000 	ldr	r3, [r6]
   14778:	e2719001 	rsbs	r9, r1, #1	; 0x1
   1477c:	33a09000 	movcc	r9, #0	; 0x0
   14780:	e3540000 	cmp	r4, #0	; 0x0
   14784:	03510000 	cmpeq	r1, #0	; 0x0
   14788:	e1d381b2 	ldrh	r8, [r3, #18]
   1478c:	11a07001 	movne	r7, r1
   14790:	1a000006 	bne	147b0 <fat16_resize_file+0x54>
   14794:	ea000049 	b	148c0 <fat16_resize_file+0x164>
   14798:	e5960000 	ldr	r0, [r6]
   1479c:	ebfffd05 	bl	13bb8 <fat16_get_next_cluster>
   147a0:	e3500000 	cmp	r0, #0	; 0x0
   147a4:	0a00004f 	beq	148e8 <fat16_resize_file+0x18c>
   147a8:	e0687007 	rsb	r7, r8, r7
   147ac:	e1a04000 	mov	r4, r0
   147b0:	e1570008 	cmp	r7, r8
   147b4:	e1a01004 	mov	r1, r4
   147b8:	8afffff6 	bhi	14798 <fat16_resize_file+0x3c>
   147bc:	e2745001 	rsbs	r5, r4, #1	; 0x1
   147c0:	33a05000 	movcc	r5, #0	; 0x0
   147c4:	e3550000 	cmp	r5, #0	; 0x0
   147c8:	0a000011 	beq	14814 <fat16_resize_file+0xb8>
   147cc:	e1a01008 	mov	r1, r8
   147d0:	e1a00007 	mov	r0, r7
   147d4:	eb000caf 	bl	17a98 <__aeabi_uidiv>
   147d8:	e1a00800 	mov	r0, r0, lsl #16
   147dc:	e1a02820 	mov	r2, r0, lsr #16
   147e0:	e0030298 	mul	r3, r8, r2
   147e4:	e1530007 	cmp	r3, r7
   147e8:	32823001 	addcc	r3, r2, #1	; 0x1
   147ec:	31a03803 	movcc	r3, r3, lsl #16
   147f0:	31a02823 	movcc	r2, r3, lsr #16
   147f4:	e5960000 	ldr	r0, [r6]
   147f8:	e1a01004 	mov	r1, r4
   147fc:	ebfffd4d 	bl	13d38 <fat16_append_clusters>
   14800:	e3500000 	cmp	r0, #0	; 0x0
   14804:	0a000035 	beq	148e0 <fat16_resize_file+0x184>
   14808:	e3550000 	cmp	r5, #0	; 0x0
   1480c:	11c602b6 	strneh	r0, [r6, #38]
   14810:	11a04000 	movne	r4, r0
   14814:	e3590000 	cmp	r9, #0	; 0x0
   14818:	13a03000 	movne	r3, #0	; 0x0
   1481c:	11c632b6 	strneh	r3, [r6, #38]
   14820:	e586a028 	str	sl, [r6, #40]
   14824:	e5960000 	ldr	r0, [r6]
   14828:	e2861004 	add	r1, r6, #4	; 0x4
   1482c:	ebffff27 	bl	144d0 <fat16_write_dir_entry>
   14830:	e3500000 	cmp	r0, #0	; 0x0
   14834:	0a000029 	beq	148e0 <fat16_resize_file+0x184>
   14838:	e3590000 	cmp	r9, #0	; 0x0
   1483c:	11a01004 	movne	r1, r4
   14840:	15960000 	ldrne	r0, [r6]
   14844:	1a00001c 	bne	148bc <fat16_resize_file+0x160>
   14848:	e1570008 	cmp	r7, r8
   1484c:	8a00001b 	bhi	148c0 <fat16_resize_file+0x164>
   14850:	e1a03804 	mov	r3, r4, lsl #16
   14854:	e5965000 	ldr	r5, [r6]
   14858:	e1a04823 	mov	r4, r3, lsr #16
   1485c:	e3550000 	cmp	r5, #0	; 0x0
   14860:	13540001 	cmpne	r4, #1	; 0x1
   14864:	9a000015 	bls	148c0 <fat16_resize_file+0x164>
   14868:	e1a01004 	mov	r1, r4
   1486c:	e1a00005 	mov	r0, r5
   14870:	ebfffcd0 	bl	13bb8 <fat16_get_next_cluster>
   14874:	e3e03000 	mvn	r3, #0	; 0x0
   14878:	e5cd3003 	strb	r3, [sp, #3]
   1487c:	e5cd3002 	strb	r3, [sp, #2]
   14880:	e1a07000 	mov	r7, r0
   14884:	e5950008 	ldr	r0, [r5, #8]
   14888:	e5953000 	ldr	r3, [r5]
   1488c:	e0800084 	add	r0, r0, r4, lsl #1
   14890:	e28d1002 	add	r1, sp, #2	; 0x2
   14894:	e3a02002 	mov	r2, #2	; 0x2
   14898:	e593c008 	ldr	ip, [r3, #8]
   1489c:	e1a0e00f 	mov	lr, pc
   148a0:	e12fff1c 	bx	ip
   148a4:	e3500000 	cmp	r0, #0	; 0x0
   148a8:	0a000004 	beq	148c0 <fat16_resize_file+0x164>
   148ac:	e3570000 	cmp	r7, #0	; 0x0
   148b0:	0a000002 	beq	148c0 <fat16_resize_file+0x164>
   148b4:	e1a00005 	mov	r0, r5
   148b8:	e1a01007 	mov	r1, r7
   148bc:	ebfffce7 	bl	13c60 <fat16_free_clusters>
   148c0:	e5963030 	ldr	r3, [r6, #48]
   148c4:	e15a0003 	cmp	sl, r3
   148c8:	33a03000 	movcc	r3, #0	; 0x0
   148cc:	23a00001 	movcs	r0, #1	; 0x1
   148d0:	33a00001 	movcc	r0, #1	; 0x1
   148d4:	3586a030 	strcc	sl, [r6, #48]
   148d8:	31c633b4 	strcch	r3, [r6, #52]
   148dc:	ea000004 	b	148f4 <fat16_resize_file+0x198>
   148e0:	e3a00000 	mov	r0, #0	; 0x0
   148e4:	ea000002 	b	148f4 <fat16_resize_file+0x198>
   148e8:	e2745001 	rsbs	r5, r4, #1	; 0x1
   148ec:	33a05000 	movcc	r5, #0	; 0x0
   148f0:	eaffffb5 	b	147cc <fat16_resize_file+0x70>
   148f4:	e28dd004 	add	sp, sp, #4	; 0x4
   148f8:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   148fc:	e12fff1e 	bx	lr

00014900 <fat16_seek_file>:
   14900:	e3510000 	cmp	r1, #0	; 0x0
   14904:	13500000 	cmpne	r0, #0	; 0x0
   14908:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   1490c:	e20220ff 	and	r2, r2, #255	; 0xff
   14910:	e1a05000 	mov	r5, r0
   14914:	e1a06001 	mov	r6, r1
   14918:	0a00001b 	beq	1498c <fat16_seek_file+0x8c>
   1491c:	e3520001 	cmp	r2, #1	; 0x1
   14920:	e5901030 	ldr	r1, [r0, #48]
   14924:	0a000004 	beq	1493c <fat16_seek_file+0x3c>
   14928:	35964000 	ldrcc	r4, [r6]
   1492c:	3a000008 	bcc	14954 <fat16_seek_file+0x54>
   14930:	e3520002 	cmp	r2, #2	; 0x2
   14934:	1a000014 	bne	1498c <fat16_seek_file+0x8c>
   14938:	ea000002 	b	14948 <fat16_seek_file+0x48>
   1493c:	e5963000 	ldr	r3, [r6]
   14940:	e0814003 	add	r4, r1, r3
   14944:	ea000002 	b	14954 <fat16_seek_file+0x54>
   14948:	e5902028 	ldr	r2, [r0, #40]
   1494c:	e5963000 	ldr	r3, [r6]
   14950:	e0824003 	add	r4, r2, r3
   14954:	e5953028 	ldr	r3, [r5, #40]
   14958:	e1540003 	cmp	r4, r3
   1495c:	9a000004 	bls	14974 <fat16_seek_file+0x74>
   14960:	e1a00005 	mov	r0, r5
   14964:	e1a01004 	mov	r1, r4
   14968:	ebffff7b 	bl	1475c <fat16_resize_file>
   1496c:	e3500000 	cmp	r0, #0	; 0x0
   14970:	0a000005 	beq	1498c <fat16_seek_file+0x8c>
   14974:	e3a03000 	mov	r3, #0	; 0x0
   14978:	e3a00001 	mov	r0, #1	; 0x1
   1497c:	e5854030 	str	r4, [r5, #48]
   14980:	e1c533b4 	strh	r3, [r5, #52]
   14984:	e5864000 	str	r4, [r6]
   14988:	ea000000 	b	14990 <fat16_seek_file+0x90>
   1498c:	e3a00000 	mov	r0, #0	; 0x0
   14990:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   14994:	e12fff1e 	bx	lr

00014998 <fat16_write_file>:
   14998:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1499c:	e1a02802 	mov	r2, r2, lsl #16
   149a0:	e24dd004 	sub	sp, sp, #4	; 0x4
   149a4:	e1a02822 	mov	r2, r2, lsr #16
   149a8:	e3510000 	cmp	r1, #0	; 0x0
   149ac:	13500000 	cmpne	r0, #0	; 0x0
   149b0:	e1a04000 	mov	r4, r0
   149b4:	e1a0b001 	mov	fp, r1
   149b8:	e58d2000 	str	r2, [sp]
   149bc:	0a000077 	beq	14ba0 <fat16_write_file+0x208>
   149c0:	e3520000 	cmp	r2, #0	; 0x0
   149c4:	0a000075 	beq	14ba0 <fat16_write_file+0x208>
   149c8:	e590a030 	ldr	sl, [r0, #48]
   149cc:	e5903028 	ldr	r3, [r0, #40]
   149d0:	e15a0003 	cmp	sl, r3
   149d4:	8a000071 	bhi	14ba0 <fat16_write_file+0x208>
   149d8:	e1d053b4 	ldrh	r5, [r0, #52]
   149dc:	e5900000 	ldr	r0, [r0]
   149e0:	e3550000 	cmp	r5, #0	; 0x0
   149e4:	e1d081b2 	ldrh	r8, [r0, #18]
   149e8:	1a000020 	bne	14a70 <fat16_write_file+0xd8>
   149ec:	e1d452b6 	ldrh	r5, [r4, #38]
   149f0:	e3550000 	cmp	r5, #0	; 0x0
   149f4:	1a000008 	bne	14a1c <fat16_write_file+0x84>
   149f8:	e35a0000 	cmp	sl, #0	; 0x0
   149fc:	1a000067 	bne	14ba0 <fat16_write_file+0x208>
   14a00:	e1a01005 	mov	r1, r5
   14a04:	e3a02001 	mov	r2, #1	; 0x1
   14a08:	ebfffcca 	bl	13d38 <fat16_append_clusters>
   14a0c:	e3500000 	cmp	r0, #0	; 0x0
   14a10:	e1a05000 	mov	r5, r0
   14a14:	e1c402b6 	strh	r0, [r4, #38]
   14a18:	0a000060 	beq	14ba0 <fat16_write_file+0x208>
   14a1c:	e5946030 	ldr	r6, [r4, #48]
   14a20:	e3560000 	cmp	r6, #0	; 0x0
   14a24:	12689000 	rsbne	r9, r8, #0	; 0x0
   14a28:	10687006 	rsbne	r7, r8, r6
   14a2c:	1a00000c 	bne	14a64 <fat16_write_file+0xcc>
   14a30:	ea00000e 	b	14a70 <fat16_write_file+0xd8>
   14a34:	e5940000 	ldr	r0, [r4]
   14a38:	ebfffc5e 	bl	13bb8 <fat16_get_next_cluster>
   14a3c:	e3500000 	cmp	r0, #0	; 0x0
   14a40:	03570000 	cmpeq	r7, #0	; 0x0
   14a44:	e0866009 	add	r6, r6, r9
   14a48:	e0877009 	add	r7, r7, r9
   14a4c:	e1a01005 	mov	r1, r5
   14a50:	e3a02001 	mov	r2, #1	; 0x1
   14a54:	05940000 	ldreq	r0, [r4]
   14a58:	0bfffcb6 	bleq	13d38 <fat16_append_clusters>
   14a5c:	e2505000 	subs	r5, r0, #0	; 0x0
   14a60:	0a00004e 	beq	14ba0 <fat16_write_file+0x208>
   14a64:	e1560008 	cmp	r6, r8
   14a68:	e1a01005 	mov	r1, r5
   14a6c:	2afffff0 	bcs	14a34 <fat16_write_file+0x9c>
   14a70:	e1a0000a 	mov	r0, sl
   14a74:	e1a01008 	mov	r1, r8
   14a78:	eb000c9c 	bl	17cf0 <__umodsi3>
   14a7c:	e59d7000 	ldr	r7, [sp]
   14a80:	e1a00800 	mov	r0, r0, lsl #16
   14a84:	e1a0a820 	mov	sl, r0, lsr #16
   14a88:	e594c000 	ldr	ip, [r4]
   14a8c:	e06a3008 	rsb	r3, sl, r8
   14a90:	e59c2018 	ldr	r2, [ip, #24]
   14a94:	e1a03803 	mov	r3, r3, lsl #16
   14a98:	e1a03823 	mov	r3, r3, lsr #16
   14a9c:	e1570003 	cmp	r7, r3
   14aa0:	31a06007 	movcc	r6, r7
   14aa4:	21a06003 	movcs	r6, r3
   14aa8:	e08a2002 	add	r2, sl, r2
   14aac:	e2453002 	sub	r3, r5, #2	; 0x2
   14ab0:	e0202398 	mla	r0, r8, r3, r2
   14ab4:	e1a0100b 	mov	r1, fp
   14ab8:	e1a02006 	mov	r2, r6
   14abc:	e59c3000 	ldr	r3, [ip]
   14ac0:	e593c008 	ldr	ip, [r3, #8]
   14ac4:	e1a0e00f 	mov	lr, pc
   14ac8:	e12fff1c 	bx	ip
   14acc:	e0663007 	rsb	r3, r6, r7
   14ad0:	e3500000 	cmp	r0, #0	; 0x0
   14ad4:	e1a01005 	mov	r1, r5
   14ad8:	e08bb006 	add	fp, fp, r6
   14adc:	e08a2006 	add	r2, sl, r6
   14ae0:	e1a00803 	mov	r0, r3, lsl #16
   14ae4:	0a000018 	beq	14b4c <fat16_write_file+0x1b4>
   14ae8:	e5943030 	ldr	r3, [r4, #48]
   14aec:	e1520008 	cmp	r2, r8
   14af0:	e0833006 	add	r3, r3, r6
   14af4:	e5843030 	str	r3, [r4, #48]
   14af8:	e1a07820 	mov	r7, r0, lsr #16
   14afc:	ba00000f 	blt	14b40 <fat16_write_file+0x1a8>
   14b00:	e5940000 	ldr	r0, [r4]
   14b04:	ebfffc2b 	bl	13bb8 <fat16_get_next_cluster>
   14b08:	e3a0a000 	mov	sl, #0	; 0x0
   14b0c:	e150000a 	cmp	r0, sl
   14b10:	13a03000 	movne	r3, #0	; 0x0
   14b14:	03a03001 	moveq	r3, #1	; 0x1
   14b18:	e157000a 	cmp	r7, sl
   14b1c:	03a03000 	moveq	r3, #0	; 0x0
   14b20:	e153000a 	cmp	r3, sl
   14b24:	e1a01005 	mov	r1, r5
   14b28:	e3a02001 	mov	r2, #1	; 0x1
   14b2c:	15940000 	ldrne	r0, [r4]
   14b30:	1bfffc80 	blne	13d38 <fat16_append_clusters>
   14b34:	e3500000 	cmp	r0, #0	; 0x0
   14b38:	e1a05000 	mov	r5, r0
   14b3c:	0a000015 	beq	14b98 <fat16_write_file+0x200>
   14b40:	e3570000 	cmp	r7, #0	; 0x0
   14b44:	e1c453b4 	strh	r5, [r4, #52]
   14b48:	1affffce 	bne	14a88 <fat16_write_file+0xf0>
   14b4c:	e5943030 	ldr	r3, [r4, #48]
   14b50:	e5945028 	ldr	r5, [r4, #40]
   14b54:	e1530005 	cmp	r3, r5
   14b58:	9a000009 	bls	14b84 <fat16_write_file+0x1ec>
   14b5c:	e5843028 	str	r3, [r4, #40]
   14b60:	e5940000 	ldr	r0, [r4]
   14b64:	e2841004 	add	r1, r4, #4	; 0x4
   14b68:	ebfffe58 	bl	144d0 <fat16_write_dir_entry>
   14b6c:	e3500000 	cmp	r0, #0	; 0x0
   14b70:	05943030 	ldreq	r3, [r4, #48]
   14b74:	00653003 	rsbeq	r3, r5, r3
   14b78:	01a03803 	moveq	r3, r3, lsl #16
   14b7c:	05845030 	streq	r5, [r4, #48]
   14b80:	01a07823 	moveq	r7, r3, lsr #16
   14b84:	e59d2000 	ldr	r2, [sp]
   14b88:	e0673002 	rsb	r3, r7, r2
   14b8c:	e1a03803 	mov	r3, r3, lsl #16
   14b90:	e1a00843 	mov	r0, r3, asr #16
   14b94:	ea000002 	b	14ba4 <fat16_write_file+0x20c>
   14b98:	e1c403b4 	strh	r0, [r4, #52]
   14b9c:	eaffffea 	b	14b4c <fat16_write_file+0x1b4>
   14ba0:	e3e00000 	mvn	r0, #0	; 0x0
   14ba4:	e28dd004 	add	sp, sp, #4	; 0x4
   14ba8:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14bac:	e12fff1e 	bx	lr

00014bb0 <fat16_close_dir>:
   14bb0:	e3500000 	cmp	r0, #0	; 0x0
   14bb4:	e52de004 	str	lr, [sp, #-4]!
   14bb8:	1b0008bc 	blne	16eb0 <free>
   14bbc:	e49de004 	ldr	lr, [sp], #4
   14bc0:	e12fff1e 	bx	lr

00014bc4 <fat16_close_file>:
   14bc4:	e3500000 	cmp	r0, #0	; 0x0
   14bc8:	e52de004 	str	lr, [sp, #-4]!
   14bcc:	1b0008b7 	blne	16eb0 <free>
   14bd0:	e49de004 	ldr	lr, [sp], #4
   14bd4:	e12fff1e 	bx	lr

00014bd8 <fat16_close>:
   14bd8:	e3500000 	cmp	r0, #0	; 0x0
   14bdc:	e52de004 	str	lr, [sp, #-4]!
   14be0:	1b0008b2 	blne	16eb0 <free>
   14be4:	e49de004 	ldr	lr, [sp], #4
   14be8:	e12fff1e 	bx	lr

00014bec <fat16_open_dir>:
   14bec:	e3510000 	cmp	r1, #0	; 0x0
   14bf0:	13500000 	cmpne	r0, #0	; 0x0
   14bf4:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14bf8:	e1a07000 	mov	r7, r0
   14bfc:	e1a05001 	mov	r5, r1
   14c00:	13a08000 	movne	r8, #0	; 0x0
   14c04:	03a08001 	moveq	r8, #1	; 0x1
   14c08:	0a000013 	beq	14c5c <fat16_open_dir+0x70>
   14c0c:	e5d13020 	ldrb	r3, [r1, #32]
   14c10:	e3130010 	tst	r3, #16	; 0x10
   14c14:	e3a00034 	mov	r0, #52	; 0x34
   14c18:	0a00000f 	beq	14c5c <fat16_open_dir+0x70>
   14c1c:	eb0008ab 	bl	16ed0 <malloc>
   14c20:	e3500000 	cmp	r0, #0	; 0x0
   14c24:	e1a06000 	mov	r6, r0
   14c28:	e2804004 	add	r4, r0, #4	; 0x4
   14c2c:	0a00000a 	beq	14c5c <fat16_open_dir+0x70>
   14c30:	e1a0c005 	mov	ip, r5
   14c34:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   14c38:	e1a0e004 	mov	lr, r4
   14c3c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   14c40:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   14c44:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   14c48:	e89c0007 	ldmia	ip, {r0, r1, r2}
   14c4c:	e5867000 	str	r7, [r6]
   14c50:	e88e0007 	stmia	lr, {r0, r1, r2}
   14c54:	e1c683b0 	strh	r8, [r6, #48]
   14c58:	ea000000 	b	14c60 <fat16_open_dir+0x74>
   14c5c:	e3a06000 	mov	r6, #0	; 0x0
   14c60:	e1a00006 	mov	r0, r6
   14c64:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   14c68:	e12fff1e 	bx	lr

00014c6c <fat16_open_file>:
   14c6c:	e3510000 	cmp	r1, #0	; 0x0
   14c70:	13500000 	cmpne	r0, #0	; 0x0
   14c74:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14c78:	e1a05001 	mov	r5, r1
   14c7c:	e1a07000 	mov	r7, r0
   14c80:	0a000015 	beq	14cdc <fat16_open_file+0x70>
   14c84:	e5d13020 	ldrb	r3, [r1, #32]
   14c88:	e2138010 	ands	r8, r3, #16	; 0x10
   14c8c:	e3a00038 	mov	r0, #56	; 0x38
   14c90:	1a000011 	bne	14cdc <fat16_open_file+0x70>
   14c94:	eb00088d 	bl	16ed0 <malloc>
   14c98:	e3500000 	cmp	r0, #0	; 0x0
   14c9c:	e1a06000 	mov	r6, r0
   14ca0:	e2804004 	add	r4, r0, #4	; 0x4
   14ca4:	0a00000c 	beq	14cdc <fat16_open_file+0x70>
   14ca8:	e1a0c005 	mov	ip, r5
   14cac:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   14cb0:	e1a0e004 	mov	lr, r4
   14cb4:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   14cb8:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
   14cbc:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
   14cc0:	e89c0007 	ldmia	ip, {r0, r1, r2}
   14cc4:	e88e0007 	stmia	lr, {r0, r1, r2}
   14cc8:	e1d552b2 	ldrh	r5, [r5, #34]
   14ccc:	e5867000 	str	r7, [r6]
   14cd0:	e5868030 	str	r8, [r6, #48]
   14cd4:	e1c653b4 	strh	r5, [r6, #52]
   14cd8:	ea000000 	b	14ce0 <fat16_open_file+0x74>
   14cdc:	e3a06000 	mov	r6, #0	; 0x0
   14ce0:	e1a00006 	mov	r0, r6
   14ce4:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   14ce8:	e12fff1e 	bx	lr

00014cec <open_file_in_dir>:
   14cec:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   14cf0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   14cf4:	e1a0300d 	mov	r3, sp
   14cf8:	e1a04000 	mov	r4, r0
   14cfc:	ebfffddc 	bl	14474 <find_file_in_dir>
   14d00:	e3500000 	cmp	r0, #0	; 0x0
   14d04:	e1a03000 	mov	r3, r0
   14d08:	e1a0500d 	mov	r5, sp
   14d0c:	e1a00004 	mov	r0, r4
   14d10:	e1a0100d 	mov	r1, sp
   14d14:	0a000001 	beq	14d20 <open_file_in_dir+0x34>
   14d18:	ebffffd3 	bl	14c6c <fat16_open_file>
   14d1c:	e1a03000 	mov	r3, r0
   14d20:	e1a00003 	mov	r0, r3
   14d24:	e28dd02c 	add	sp, sp, #44	; 0x2c
   14d28:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   14d2c:	e12fff1e 	bx	lr

00014d30 <fat16_get_dir_entry_of_path>:
   14d30:	e3510000 	cmp	r1, #0	; 0x0
   14d34:	13500000 	cmpne	r0, #0	; 0x0
   14d38:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14d3c:	e1a09000 	mov	r9, r0
   14d40:	e1a04001 	mov	r4, r1
   14d44:	e1a05002 	mov	r5, r2
   14d48:	0a00003c 	beq	14e40 <fat16_get_dir_entry_of_path+0x110>
   14d4c:	e5d13000 	ldrb	r3, [r1]
   14d50:	e3520000 	cmp	r2, #0	; 0x0
   14d54:	13530000 	cmpne	r3, #0	; 0x0
   14d58:	13a01000 	movne	r1, #0	; 0x0
   14d5c:	03a01001 	moveq	r1, #1	; 0x1
   14d60:	0a000036 	beq	14e40 <fat16_get_dir_entry_of_path+0x110>
   14d64:	e353002f 	cmp	r3, #47	; 0x2f
   14d68:	e1a00002 	mov	r0, r2
   14d6c:	e3a0202c 	mov	r2, #44	; 0x2c
   14d70:	02844001 	addeq	r4, r4, #1	; 0x1
   14d74:	eb000a07 	bl	17598 <memset>
   14d78:	e3a03010 	mov	r3, #16	; 0x10
   14d7c:	e5c53020 	strb	r3, [r5, #32]
   14d80:	e5d43000 	ldrb	r3, [r4]
   14d84:	e3530000 	cmp	r3, #0	; 0x0
   14d88:	0a00002e 	beq	14e48 <fat16_get_dir_entry_of_path+0x118>
   14d8c:	e1a00009 	mov	r0, r9
   14d90:	e1a01005 	mov	r1, r5
   14d94:	ebffff94 	bl	14bec <fat16_open_dir>
   14d98:	e2507000 	subs	r7, r0, #0	; 0x0
   14d9c:	0a000027 	beq	14e40 <fat16_get_dir_entry_of_path+0x110>
   14da0:	e1a00004 	mov	r0, r4
   14da4:	e3a0102f 	mov	r1, #47	; 0x2f
   14da8:	eb000a03 	bl	175bc <strchr>
   14dac:	e2508000 	subs	r8, r0, #0	; 0x0
   14db0:	1a000002 	bne	14dc0 <fat16_get_dir_entry_of_path+0x90>
   14db4:	e1a00004 	mov	r0, r4
   14db8:	eb000a1d 	bl	17634 <strlen>
   14dbc:	e0848000 	add	r8, r4, r0
   14dc0:	e0643008 	rsb	r3, r4, r8
   14dc4:	e20360ff 	and	r6, r3, #255	; 0xff
   14dc8:	ea000013 	b	14e1c <fat16_get_dir_entry_of_path+0xec>
   14dcc:	eb000a18 	bl	17634 <strlen>
   14dd0:	e1500006 	cmp	r0, r6
   14dd4:	e1a01005 	mov	r1, r5
   14dd8:	e1a02006 	mov	r2, r6
   14ddc:	e1a00004 	mov	r0, r4
   14de0:	1a00000d 	bne	14e1c <fat16_get_dir_entry_of_path+0xec>
   14de4:	eb000a1a 	bl	17654 <strncmp>
   14de8:	e250a000 	subs	sl, r0, #0	; 0x0
   14dec:	1a00000a 	bne	14e1c <fat16_get_dir_entry_of_path+0xec>
   14df0:	e1a00007 	mov	r0, r7
   14df4:	ebffff6d 	bl	14bb0 <fat16_close_dir>
   14df8:	e7d43006 	ldrb	r3, [r4, r6]
   14dfc:	e3530000 	cmp	r3, #0	; 0x0
   14e00:	0a000010 	beq	14e48 <fat16_get_dir_entry_of_path+0x118>
   14e04:	e5d53020 	ldrb	r3, [r5, #32]
   14e08:	e3130010 	tst	r3, #16	; 0x10
   14e0c:	0a00000b 	beq	14e40 <fat16_get_dir_entry_of_path+0x110>
   14e10:	e2884001 	add	r4, r8, #1	; 0x1
   14e14:	e1a0700a 	mov	r7, sl
   14e18:	ea000005 	b	14e34 <fat16_get_dir_entry_of_path+0x104>
   14e1c:	e1a01005 	mov	r1, r5
   14e20:	e1a00007 	mov	r0, r7
   14e24:	ebfffd0c 	bl	1425c <fat16_read_dir>
   14e28:	e3500000 	cmp	r0, #0	; 0x0
   14e2c:	e1a00005 	mov	r0, r5
   14e30:	1affffe5 	bne	14dcc <fat16_get_dir_entry_of_path+0x9c>
   14e34:	e1a00007 	mov	r0, r7
   14e38:	ebffff5c 	bl	14bb0 <fat16_close_dir>
   14e3c:	eaffffd2 	b	14d8c <fat16_get_dir_entry_of_path+0x5c>
   14e40:	e3a00000 	mov	r0, #0	; 0x0
   14e44:	ea000000 	b	14e4c <fat16_get_dir_entry_of_path+0x11c>
   14e48:	e3a00001 	mov	r0, #1	; 0x1
   14e4c:	e8bd47f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14e50:	e12fff1e 	bx	lr

00014e54 <fat16_open>:
   14e54:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14e58:	e2508000 	subs	r8, r0, #0	; 0x0
   14e5c:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   14e60:	0a000071 	beq	1502c <fat16_open+0x1d8>
   14e64:	e5983008 	ldr	r3, [r8, #8]
   14e68:	e3530000 	cmp	r3, #0	; 0x0
   14e6c:	0a00006e 	beq	1502c <fat16_open+0x1d8>
   14e70:	e3a0001c 	mov	r0, #28	; 0x1c
   14e74:	eb000815 	bl	16ed0 <malloc>
   14e78:	e250b000 	subs	fp, r0, #0	; 0x0
   14e7c:	1a000003 	bne	14e90 <fat16_open+0x3c>
   14e80:	e59f01b8 	ldr	r0, [pc, #440]	; 15040 <.text+0x5040>
   14e84:	ebfff4ac 	bl	1213c <rprintf>
   14e88:	e1a0a00b 	mov	sl, fp
   14e8c:	ea000067 	b	15030 <fat16_open+0x1dc>
   14e90:	e3a01000 	mov	r1, #0	; 0x0
   14e94:	e3a0201c 	mov	r2, #28	; 0x1c
   14e98:	eb0009be 	bl	17598 <memset>
   14e9c:	e5983010 	ldr	r3, [r8, #16]
   14ea0:	e1a03483 	mov	r3, r3, lsl #9
   14ea4:	e58d3008 	str	r3, [sp, #8]
   14ea8:	e58b8000 	str	r8, [fp]
   14eac:	e283000b 	add	r0, r3, #11	; 0xb
   14eb0:	e28d1023 	add	r1, sp, #35	; 0x23
   14eb4:	e3a02019 	mov	r2, #25	; 0x19
   14eb8:	e598c000 	ldr	ip, [r8]
   14ebc:	e1a0e00f 	mov	lr, pc
   14ec0:	e12fff1c 	bx	ip
   14ec4:	e3500000 	cmp	r0, #0	; 0x0
   14ec8:	e1a0a00b 	mov	sl, fp
   14ecc:	0a000052 	beq	1501c <fat16_open+0x1c8>
   14ed0:	e5dd202e 	ldrb	r2, [sp, #46]
   14ed4:	e5dd302f 	ldrb	r3, [sp, #47]
   14ed8:	e1923403 	orrs	r3, r2, r3, lsl #8
   14edc:	e5dd0023 	ldrb	r0, [sp, #35]
   14ee0:	e5dd2024 	ldrb	r2, [sp, #36]
   14ee4:	e58d3010 	str	r3, [sp, #16]
   14ee8:	e5dd6026 	ldrb	r6, [sp, #38]
   14eec:	e5dd3025 	ldrb	r3, [sp, #37]
   14ef0:	e58d001c 	str	r0, [sp, #28]
   14ef4:	e58d2018 	str	r2, [sp, #24]
   14ef8:	e58d3004 	str	r3, [sp, #4]
   14efc:	e58d6014 	str	r6, [sp, #20]
   14f00:	e5dd1027 	ldrb	r1, [sp, #39]
   14f04:	e5dd9028 	ldrb	r9, [sp, #40]
   14f08:	e5dd7029 	ldrb	r7, [sp, #41]
   14f0c:	e5dd502a 	ldrb	r5, [sp, #42]
   14f10:	e5dd402b 	ldrb	r4, [sp, #43]
   14f14:	e5dde02c 	ldrb	lr, [sp, #44]
   14f18:	e5ddc038 	ldrb	ip, [sp, #56]
   14f1c:	e5dd2039 	ldrb	r2, [sp, #57]
   14f20:	e5dd303a 	ldrb	r3, [sp, #58]
   14f24:	e5dd003b 	ldrb	r0, [sp, #59]
   14f28:	0a00003b 	beq	1501c <fat16_open+0x1c8>
   14f2c:	e1a03803 	mov	r3, r3, lsl #16
   14f30:	e18c2402 	orr	r2, ip, r2, lsl #8
   14f34:	e1833c00 	orr	r3, r3, r0, lsl #24
   14f38:	e1926003 	orrs	r6, r2, r3
   14f3c:	1a000002 	bne	14f4c <fat16_open+0xf8>
   14f40:	e194240e 	orrs	r2, r4, lr, lsl #8
   14f44:	0a000034 	beq	1501c <fat16_open+0x1c8>
   14f48:	e1a06002 	mov	r6, r2
   14f4c:	e59d0010 	ldr	r0, [sp, #16]
   14f50:	e0000099 	mul	r0, r9, r0
   14f54:	e59d201c 	ldr	r2, [sp, #28]
   14f58:	e58d000c 	str	r0, [sp, #12]
   14f5c:	e59d0018 	ldr	r0, [sp, #24]
   14f60:	e1873405 	orr	r3, r7, r5, lsl #8
   14f64:	e1825400 	orr	r5, r2, r0, lsl #8
   14f68:	e59d2014 	ldr	r2, [sp, #20]
   14f6c:	e1a03283 	mov	r3, r3, lsl #5
   14f70:	e1829401 	orr	r9, r2, r1, lsl #8
   14f74:	e58d3000 	str	r3, [sp]
   14f78:	e0830005 	add	r0, r3, r5
   14f7c:	e59d300c 	ldr	r3, [sp, #12]
   14f80:	e1a01005 	mov	r1, r5
   14f84:	e2400001 	sub	r0, r0, #1	; 0x1
   14f88:	e0694006 	rsb	r4, r9, r6
   14f8c:	e0634004 	rsb	r4, r3, r4
   14f90:	eb000b05 	bl	17bac <__aeabi_idiv>
   14f94:	e59d1004 	ldr	r1, [sp, #4]
   14f98:	e0600004 	rsb	r0, r0, r4
   14f9c:	eb000abd 	bl	17a98 <__aeabi_uidiv>
   14fa0:	e2403eff 	sub	r3, r0, #4080	; 0xff0
   14fa4:	e2433005 	sub	r3, r3, #5	; 0x5
   14fa8:	e3530a0f 	cmp	r3, #61440	; 0xf000
   14fac:	e1a07000 	mov	r7, r0
   14fb0:	2a000019 	bcs	1501c <fat16_open+0x1c8>
   14fb4:	e28a4004 	add	r4, sl, #4	; 0x4
   14fb8:	e3a03006 	mov	r3, #6	; 0x6
   14fbc:	e5c8300c 	strb	r3, [r8, #12]
   14fc0:	e3a01000 	mov	r1, #0	; 0x0
   14fc4:	e3a02018 	mov	r2, #24	; 0x18
   14fc8:	e1a00004 	mov	r0, r4
   14fcc:	eb000971 	bl	17598 <memset>
   14fd0:	e59dc008 	ldr	ip, [sp, #8]
   14fd4:	e02cc995 	mla	ip, r5, r9, ip
   14fd8:	e59de00c 	ldr	lr, [sp, #12]
   14fdc:	e59d0004 	ldr	r0, [sp, #4]
   14fe0:	e02ece95 	mla	lr, r5, lr, ip
   14fe4:	e0010695 	mul	r1, r5, r6
   14fe8:	e0000095 	mul	r0, r5, r0
   14fec:	e59d6000 	ldr	r6, [sp]
   14ff0:	e1a03087 	mov	r3, r7, lsl #1
   14ff4:	e08e2006 	add	r2, lr, r6
   14ff8:	e2833004 	add	r3, r3, #4	; 0x4
   14ffc:	e5842014 	str	r2, [r4, #20]
   15000:	e58a1004 	str	r1, [sl, #4]
   15004:	e5843008 	str	r3, [r4, #8]
   15008:	e1c400be 	strh	r0, [r4, #14]
   1500c:	e584c004 	str	ip, [r4, #4]
   15010:	e1c450bc 	strh	r5, [r4, #12]
   15014:	e584e010 	str	lr, [r4, #16]
   15018:	ea000004 	b	15030 <fat16_open+0x1dc>
   1501c:	e59f0020 	ldr	r0, [pc, #32]	; 15044 <.text+0x5044>
   15020:	ebfff445 	bl	1213c <rprintf>
   15024:	e1a0000b 	mov	r0, fp
   15028:	eb0007a0 	bl	16eb0 <free>
   1502c:	e3a0a000 	mov	sl, #0	; 0x0
   15030:	e1a0000a 	mov	r0, sl
   15034:	e28dd03c 	add	sp, sp, #60	; 0x3c
   15038:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1503c:	e12fff1e 	bx	lr
   15040:	00018368 	andeq	r8, r1, r8, ror #6
   15044:	00018378 	andeq	r8, r1, r8, ror r3

00015048 <fat16_create_file>:
   15048:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1504c:	e2706001 	rsbs	r6, r0, #1	; 0x1
   15050:	33a06000 	movcc	r6, #0	; 0x0
   15054:	e3500000 	cmp	r0, #0	; 0x0
   15058:	13510000 	cmpne	r1, #0	; 0x0
   1505c:	e24dd004 	sub	sp, sp, #4	; 0x4
   15060:	e1a05000 	mov	r5, r0
   15064:	e1a04001 	mov	r4, r1
   15068:	e1a08002 	mov	r8, r2
   1506c:	0a000065 	beq	15208 <fat16_create_file+0x1c0>
   15070:	e5d13000 	ldrb	r3, [r1]
   15074:	e3530000 	cmp	r3, #0	; 0x0
   15078:	0a000062 	beq	15208 <fat16_create_file+0x1c0>
   1507c:	e1a01008 	mov	r1, r8
   15080:	e1a00005 	mov	r0, r5
   15084:	ebfffc74 	bl	1425c <fat16_read_dir>
   15088:	e250a000 	subs	sl, r0, #0	; 0x0
   1508c:	e1a01008 	mov	r1, r8
   15090:	e1a00004 	mov	r0, r4
   15094:	0a000007 	beq	150b8 <fat16_create_file+0x70>
   15098:	eb000953 	bl	175ec <strcmp>
   1509c:	e3500000 	cmp	r0, #0	; 0x0
   150a0:	1afffff5 	bne	1507c <fat16_create_file+0x34>
   150a4:	e3560000 	cmp	r6, #0	; 0x0
   150a8:	12800001 	addne	r0, r0, #1	; 0x1
   150ac:	03a00001 	moveq	r0, #1	; 0x1
   150b0:	01c563b0 	streqh	r6, [r5, #48]
   150b4:	ea000054 	b	1520c <fat16_create_file+0x1c4>
   150b8:	e1a0100a 	mov	r1, sl
   150bc:	e3a0202c 	mov	r2, #44	; 0x2c
   150c0:	e1a00008 	mov	r0, r8
   150c4:	eb000933 	bl	17598 <memset>
   150c8:	e1a01004 	mov	r1, r4
   150cc:	e3a0201f 	mov	r2, #31	; 0x1f
   150d0:	e1a00008 	mov	r0, r8
   150d4:	eb000972 	bl	176a4 <strncpy>
   150d8:	e1a00004 	mov	r0, r4
   150dc:	eb000954 	bl	17634 <strlen>
   150e0:	e3a0100d 	mov	r1, #13	; 0xd
   150e4:	eb000a6b 	bl	17a98 <__aeabi_uidiv>
   150e8:	e1d572b6 	ldrh	r7, [r5, #38]
   150ec:	e5955000 	ldr	r5, [r5]
   150f0:	e3570000 	cmp	r7, #0	; 0x0
   150f4:	05954014 	ldreq	r4, [r5, #20]
   150f8:	11a0600a 	movne	r6, sl
   150fc:	e2800002 	add	r0, r0, #2	; 0x2
   15100:	0595a018 	ldreq	sl, [r5, #24]
   15104:	e200b0ff 	and	fp, r0, #255	; 0xff
   15108:	11a04006 	movne	r4, r6
   1510c:	11a0a006 	movne	sl, r6
   15110:	01a06004 	moveq	r6, r4
   15114:	e3a09000 	mov	r9, #0	; 0x0
   15118:	e154000a 	cmp	r4, sl
   1511c:	1a00001b 	bne	15190 <fat16_create_file+0x148>
   15120:	e3570000 	cmp	r7, #0	; 0x0
   15124:	0a000037 	beq	15208 <fat16_create_file+0x1c0>
   15128:	e3540000 	cmp	r4, #0	; 0x0
   1512c:	0a000010 	beq	15174 <fat16_create_file+0x12c>
   15130:	e1a00005 	mov	r0, r5
   15134:	e1a01007 	mov	r1, r7
   15138:	ebfffa9e 	bl	13bb8 <fat16_get_next_cluster>
   1513c:	e3500000 	cmp	r0, #0	; 0x0
   15140:	1a00000a 	bne	15170 <fat16_create_file+0x128>
   15144:	e1a01007 	mov	r1, r7
   15148:	e1a00005 	mov	r0, r5
   1514c:	e3a02001 	mov	r2, #1	; 0x1
   15150:	ebfffaf8 	bl	13d38 <fat16_append_clusters>
   15154:	e3500000 	cmp	r0, #0	; 0x0
   15158:	0a00002a 	beq	15208 <fat16_create_file+0x1c0>
   1515c:	e1d511b2 	ldrh	r1, [r5, #18]
   15160:	e5952018 	ldr	r2, [r5, #24]
   15164:	e2403002 	sub	r3, r0, #2	; 0x2
   15168:	e0262391 	mla	r6, r1, r3, r2
   1516c:	ea00001e 	b	151ec <fat16_create_file+0x1a4>
   15170:	e1a07000 	mov	r7, r0
   15174:	e1d511b2 	ldrh	r1, [r5, #18]
   15178:	e5952018 	ldr	r2, [r5, #24]
   1517c:	e2473002 	sub	r3, r7, #2	; 0x2
   15180:	e0242391 	mla	r4, r1, r3, r2
   15184:	e3a09000 	mov	r9, #0	; 0x0
   15188:	e084a001 	add	sl, r4, r1
   1518c:	e1a06004 	mov	r6, r4
   15190:	e5953000 	ldr	r3, [r5]
   15194:	e1a00004 	mov	r0, r4
   15198:	e28d1003 	add	r1, sp, #3	; 0x3
   1519c:	e3a02001 	mov	r2, #1	; 0x1
   151a0:	e593c000 	ldr	ip, [r3]
   151a4:	e1a0e00f 	mov	lr, pc
   151a8:	e12fff1c 	bx	ip
   151ac:	e3500000 	cmp	r0, #0	; 0x0
   151b0:	0a000014 	beq	15208 <fat16_create_file+0x1c0>
   151b4:	e5dd3003 	ldrb	r3, [sp, #3]
   151b8:	e3530000 	cmp	r3, #0	; 0x0
   151bc:	135300e5 	cmpne	r3, #229	; 0xe5
   151c0:	13a03000 	movne	r3, #0	; 0x0
   151c4:	03a03001 	moveq	r3, #1	; 0x1
   151c8:	12846020 	addne	r6, r4, #32	; 0x20
   151cc:	11a09003 	movne	r9, r3
   151d0:	11a04006 	movne	r4, r6
   151d4:	1affffcf 	bne	15118 <fat16_create_file+0xd0>
   151d8:	e2893001 	add	r3, r9, #1	; 0x1
   151dc:	e20390ff 	and	r9, r3, #255	; 0xff
   151e0:	e159000b 	cmp	r9, fp
   151e4:	32844020 	addcc	r4, r4, #32	; 0x20
   151e8:	3affffca 	bcc	15118 <fat16_create_file+0xd0>
   151ec:	e5886028 	str	r6, [r8, #40]
   151f0:	e1a00005 	mov	r0, r5
   151f4:	e1a01008 	mov	r1, r8
   151f8:	ebfffcb4 	bl	144d0 <fat16_write_dir_entry>
   151fc:	e2500000 	subs	r0, r0, #0	; 0x0
   15200:	13a00001 	movne	r0, #1	; 0x1
   15204:	ea000000 	b	1520c <fat16_create_file+0x1c4>
   15208:	e3a00000 	mov	r0, #0	; 0x0
   1520c:	e28dd004 	add	sp, sp, #4	; 0x4
   15210:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15214:	e12fff1e 	bx	lr

00015218 <partition_close>:
 * \see partition_open
 */
uint8_t partition_close(struct partition_struct* partition)
{
    if(!partition)
   15218:	e2503000 	subs	r3, r0, #0	; 0x0
   1521c:	e52de004 	str	lr, [sp, #-4]!
   15220:	0a000001 	beq	1522c <partition_close+0x14>
        return 0;

    /* destroy partition descriptor */
    free(partition);
   15224:	eb000721 	bl	16eb0 <free>
   15228:	e3a03001 	mov	r3, #1	; 0x1

    return 1;
}
   1522c:	e1a00003 	mov	r0, r3
   15230:	e49de004 	ldr	lr, [sp], #4
   15234:	e12fff1e 	bx	lr

00015238 <partition_open>:
   15238:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1523c:	e3510000 	cmp	r1, #0	; 0x0
   15240:	13500000 	cmpne	r0, #0	; 0x0
   15244:	e24dd010 	sub	sp, sp, #16	; 0x10
   15248:	e1a06000 	mov	r6, r0
   1524c:	e1a07001 	mov	r7, r1
   15250:	13a04000 	movne	r4, #0	; 0x0
   15254:	03a04001 	moveq	r4, #1	; 0x1
   15258:	e1a08002 	mov	r8, r2
   1525c:	e20330ff 	and	r3, r3, #255	; 0xff
   15260:	0a000033 	beq	15334 <partition_open+0xfc>
   15264:	e1a03c03 	mov	r3, r3, lsl #24
   15268:	e1a05c43 	mov	r5, r3, asr #24
   1526c:	e3550003 	cmp	r5, #3	; 0x3
   15270:	ca00002f 	bgt	15334 <partition_open+0xfc>
   15274:	e3550000 	cmp	r5, #0	; 0x0
   15278:	ba00000b 	blt	152ac <partition_open+0x74>
   1527c:	e1a00205 	mov	r0, r5, lsl #4
   15280:	e2800f6f 	add	r0, r0, #444	; 0x1bc
   15284:	e2800002 	add	r0, r0, #2	; 0x2
   15288:	e1a0100d 	mov	r1, sp
   1528c:	e3a02010 	mov	r2, #16	; 0x10
   15290:	e1a0e00f 	mov	lr, pc
   15294:	e12fff16 	bx	r6
   15298:	e3500000 	cmp	r0, #0	; 0x0
   1529c:	0a000024 	beq	15334 <partition_open+0xfc>
   152a0:	e5dd3004 	ldrb	r3, [sp, #4]
   152a4:	e3530000 	cmp	r3, #0	; 0x0
   152a8:	0a000021 	beq	15334 <partition_open+0xfc>
   152ac:	e3a00018 	mov	r0, #24	; 0x18
   152b0:	eb000706 	bl	16ed0 <malloc>
   152b4:	e2503000 	subs	r3, r0, #0	; 0x0
   152b8:	0a00001d 	beq	15334 <partition_open+0xfc>
   152bc:	e1a01004 	mov	r1, r4
   152c0:	e3a02018 	mov	r2, #24	; 0x18
   152c4:	e1a04003 	mov	r4, r3
   152c8:	eb0008b2 	bl	17598 <memset>
   152cc:	e3550000 	cmp	r5, #0	; 0x0
   152d0:	b3e03000 	mvnlt	r3, #0	; 0x0
   152d4:	e88401c0 	stmia	r4, {r6, r7, r8}
   152d8:	b5c4300c 	strltb	r3, [r4, #12]
   152dc:	ba000015 	blt	15338 <partition_open+0x100>
   152e0:	e5dd3004 	ldrb	r3, [sp, #4]
   152e4:	e5c4300c 	strb	r3, [r4, #12]
   152e8:	e5dd300a 	ldrb	r3, [sp, #10]
   152ec:	e5dd1009 	ldrb	r1, [sp, #9]
   152f0:	e5dd000b 	ldrb	r0, [sp, #11]
   152f4:	e5dd2008 	ldrb	r2, [sp, #8]
   152f8:	e1a03803 	mov	r3, r3, lsl #16
   152fc:	e1833c00 	orr	r3, r3, r0, lsl #24
   15300:	e1822401 	orr	r2, r2, r1, lsl #8
   15304:	e1822003 	orr	r2, r2, r3
   15308:	e5842010 	str	r2, [r4, #16]
   1530c:	e5dd300e 	ldrb	r3, [sp, #14]
   15310:	e5dd200c 	ldrb	r2, [sp, #12]
   15314:	e5dd100d 	ldrb	r1, [sp, #13]
   15318:	e5dd000f 	ldrb	r0, [sp, #15]
   1531c:	e1a03803 	mov	r3, r3, lsl #16
   15320:	e1822401 	orr	r2, r2, r1, lsl #8
   15324:	e1833c00 	orr	r3, r3, r0, lsl #24
   15328:	e1822003 	orr	r2, r2, r3
   1532c:	e5842014 	str	r2, [r4, #20]
   15330:	ea000000 	b	15338 <partition_open+0x100>
   15334:	e3a04000 	mov	r4, #0	; 0x0
   15338:	e1a00004 	mov	r0, r4
   1533c:	e28dd010 	add	sp, sp, #16	; 0x10
   15340:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   15344:	e12fff1e 	bx	lr

00015348 <convert>:
*/
//#include <stdio.h>
//#include <stdlib.h>

int convert(int n, int b, char str[], int i) {
   15348:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   1534c:	e1a04003 	mov	r4, r3
   15350:	e1a07002 	mov	r7, r2
   15354:	e1a05001 	mov	r5, r1
   15358:	e1a06000 	mov	r6, r0
	if (n/b > 0)
   1535c:	eb000a12 	bl	17bac <__aeabi_idiv>
   15360:	e3500000 	cmp	r0, #0	; 0x0
		i = convert(n/b, b, str, i);
   15364:	e1a03004 	mov	r3, r4
   15368:	e1a01005 	mov	r1, r5
   1536c:	e1a02007 	mov	r2, r7
   15370:	da000001 	ble	1537c <convert+0x34>
   15374:	ebfffff3 	bl	15348 <convert>
   15378:	e1a04000 	mov	r4, r0
	str[i++] = "0123456789ABCDEF"[n%b];
   1537c:	e1a00006 	mov	r0, r6
   15380:	e1a01005 	mov	r1, r5
   15384:	eb000a8d 	bl	17dc0 <__modsi3>
   15388:	e59f3010 	ldr	r3, [pc, #16]	; 153a0 <.text+0x53a0>
   1538c:	e7d33000 	ldrb	r3, [r3, r0]
	return i;
}
   15390:	e2840001 	add	r0, r4, #1	; 0x1
   15394:	e7c73004 	strb	r3, [r7, r4]
   15398:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   1539c:	e12fff1e 	bx	lr
   153a0:	00018390 	muleq	r1, r0, r3

000153a4 <itoa>:

int itoa(int n, int b, char str[]) {
   153a4:	e92d4010 	stmdb	sp!, {r4, lr}
	int i = convert(n, b, str, 0);
   153a8:	e3a03000 	mov	r3, #0	; 0x0
   153ac:	e1a04002 	mov	r4, r2
   153b0:	ebffffe4 	bl	15348 <convert>
	str[i] = '\0';
   153b4:	e3a03000 	mov	r3, #0	; 0x0
   153b8:	e7c43000 	strb	r3, [r4, r0]
	return i;
}
   153bc:	e8bd4010 	ldmia	sp!, {r4, lr}
   153c0:	e12fff1e 	bx	lr

000153c4 <main_msc>:
    msc_main
    ====
**************************************************************************/
int main_msc(void)
{
   153c4:	e52de004 	str	lr, [sp, #-4]!
    // initialise the SD card
    BlockDevInit();
   153c8:	eb0002e9 	bl	15f74 <BlockDevInit>

    rprintf("Initialising USB stack\n");
   153cc:	e59f006c 	ldr	r0, [pc, #108]	; 15440 <.text+0x5440>
   153d0:	ebfff359 	bl	1213c <rprintf>

    // initialise stack
    USBInit();
   153d4:	eb0003da 	bl	16344 <USBInit>

    // enable bulk-in interrupts on NAKs
    // these are required to get the BOT protocol going again after a STALL
    USBHwNakIntEnable(INACK_BI);
   153d8:	e3a00020 	mov	r0, #32	; 0x20
   153dc:	eb00046c 	bl	16594 <USBHwNakIntEnable>

    // register descriptors
    USBRegisterDescriptors(abDescriptors);
   153e0:	e59f005c 	ldr	r0, [pc, #92]	; 15444 <.text+0x5444>
   153e4:	eb0005cc 	bl	16b1c <USBRegisterDescriptors>

    // register class request handler
    USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);
   153e8:	e59f2058 	ldr	r2, [pc, #88]	; 15448 <.text+0x5448>
   153ec:	e3a00001 	mov	r0, #1	; 0x1
   153f0:	e59f1054 	ldr	r1, [pc, #84]	; 1544c <.text+0x544c>
   153f4:	eb000554 	bl	1694c <USBRegisterRequestHandler>

    // register endpoint handlers
    USBHwRegisterEPIntHandler(MSC_BULK_IN_EP, MSCBotBulkIn);
   153f8:	e3a00085 	mov	r0, #133	; 0x85
   153fc:	e59f104c 	ldr	r1, [pc, #76]	; 15450 <.text+0x5450>
   15400:	eb000436 	bl	164e0 <USBHwRegisterEPIntHandler>
    USBHwRegisterEPIntHandler(MSC_BULK_OUT_EP, MSCBotBulkOut);
   15404:	e59f1048 	ldr	r1, [pc, #72]	; 15454 <.text+0x5454>
   15408:	e3a00002 	mov	r0, #2	; 0x2
   1540c:	eb000433 	bl	164e0 <USBHwRegisterEPIntHandler>

    rprintf("Starting USB communication\n");
   15410:	e59f0040 	ldr	r0, [pc, #64]	; 15458 <.text+0x5458>
   15414:	ebfff348 	bl	1213c <rprintf>
	
    // connect to bus
    USBHwConnect(TRUE);
   15418:	e3a00001 	mov	r0, #1	; 0x1
   1541c:	eb000458 	bl	16584 <USBHwConnect>
   15420:	ea000000 	b	15428 <main_msc+0x64>

    // call USB interrupt handler continuously
    while (IOPIN0 & (1<<23))
	{
		USBHwISR();
   15424:	eb0004bd 	bl	16720 <USBHwISR>
   15428:	e59f302c 	ldr	r3, [pc, #44]	; 1545c <.text+0x545c>
   1542c:	e5933000 	ldr	r3, [r3]
   15430:	e2130502 	ands	r0, r3, #8388608	; 0x800000
   15434:	1afffffa 	bne	15424 <main_msc+0x60>
    }

    return 0;
}
   15438:	e49de004 	ldr	lr, [sp], #4
   1543c:	e12fff1e 	bx	lr
   15440:	000183a4 	andeq	r8, r1, r4, lsr #7
   15444:	40000018 	andmi	r0, r0, r8, lsl r0
   15448:	40000ac4 	andmi	r0, r0, r4, asr #21
   1544c:	00015460 	andeq	r5, r1, r0, ror #8
   15450:	00015620 	andeq	r5, r1, r0, lsr #12
   15454:	00015684 	andeq	r5, r1, r4, lsl #13
   15458:	000183bc 	streqh	r8, [r1], -ip
   1545c:	e0028000 	and	r8, r2, r0

00015460 <HandleClassRequest>:
   15460:	e1d030b4 	ldrh	r3, [r0, #4]
   15464:	e3530000 	cmp	r3, #0	; 0x0
   15468:	e92d4010 	stmdb	sp!, {r4, lr}
   1546c:	e1a03002 	mov	r3, r2
   15470:	e1a04001 	mov	r4, r1
   15474:	1a000012 	bne	154c4 <HandleClassRequest+0x64>
   15478:	e1d0e0b2 	ldrh	lr, [r0, #2]
   1547c:	e35e0000 	cmp	lr, #0	; 0x0
   15480:	1a00000f 	bne	154c4 <HandleClassRequest+0x64>
   15484:	e5d0c001 	ldrb	ip, [r0, #1]
   15488:	e35c00fe 	cmp	ip, #254	; 0xfe
   1548c:	05933000 	ldreq	r3, [r3]
   15490:	e3a02001 	mov	r2, #1	; 0x1
   15494:	05c3e000 	streqb	lr, [r3]
   15498:	e1a01002 	mov	r1, r2
   1549c:	05842000 	streq	r2, [r4]
   154a0:	0a000008 	beq	154c8 <HandleClassRequest+0x68>
   154a4:	e35c00ff 	cmp	ip, #255	; 0xff
   154a8:	1a000005 	bne	154c4 <HandleClassRequest+0x64>
   154ac:	e1d030b6 	ldrh	r3, [r0, #6]
   154b0:	e3530000 	cmp	r3, #0	; 0x0
   154b4:	1a000002 	bne	154c4 <HandleClassRequest+0x64>
   154b8:	eb000103 	bl	158cc <MSCBotReset>
   154bc:	e3a01001 	mov	r1, #1	; 0x1
   154c0:	ea000000 	b	154c8 <HandleClassRequest+0x68>
   154c4:	e3a01000 	mov	r1, #0	; 0x0
   154c8:	e1a00001 	mov	r0, r1
   154cc:	e8bd4010 	ldmia	sp!, {r4, lr}
   154d0:	e12fff1e 	bx	lr

000154d4 <SendCSW>:
static void SendCSW(U8 bStatus)
{
    int iResidue;

    iResidue = CBW.dwCBWDataTransferLength - dwTransferSize;
   154d4:	e59f203c 	ldr	r2, [pc, #60]	; 15518 <.text+0x5518>
   154d8:	e59f303c 	ldr	r3, [pc, #60]	; 1551c <.text+0x551c>
   154dc:	e5921008 	ldr	r1, [r2, #8]
   154e0:	e5933000 	ldr	r3, [r3]

    // construct CSW
    CSW.dwCSWSignature      = CSW_SIGNATURE;
    CSW.dwCSWTag            = CBW.dwCBWTag;
   154e4:	e592c004 	ldr	ip, [r2, #4]
   154e8:	e59f2030 	ldr	r2, [pc, #48]	; 15520 <.text+0x5520>
   154ec:	e0631001 	rsb	r1, r3, r1
    CSW.dwCSWDataResidue    = MAX(iResidue, 0);
    CSW.bmCSWStatus         = bStatus;

    DBG("CSW: status=%x, residue=%d\n", bStatus, CSW.dwCSWDataResidue);

    // next state
    eState = eCSW;
   154f0:	e59f302c 	ldr	r3, [pc, #44]	; 15524 <.text+0x5524>
   154f4:	e5c2000c 	strb	r0, [r2, #12]
   154f8:	e3a00003 	mov	r0, #3	; 0x3
   154fc:	e5830000 	str	r0, [r3]
   15500:	e59f3020 	ldr	r3, [pc, #32]	; 15528 <.text+0x5528>
   15504:	e3510000 	cmp	r1, #0	; 0x0
   15508:	b3a01000 	movlt	r1, #0	; 0x0
   1550c:	e8821008 	stmia	r2, {r3, ip}
   15510:	e5821008 	str	r1, [r2, #8]
}
   15514:	e12fff1e 	bx	lr
   15518:	40000ad0 	ldrmid	r0, [r0], -r0
   1551c:	40000ac8 	andmi	r0, r0, r8, asr #21
   15520:	40000af0 	strmid	r0, [r0], -r0
   15524:	40000b00 	andmi	r0, r0, r0, lsl #22
   15528:	53425355 	movtpl	r5, #9045	; 0x2355

0001552c <BOTStall>:


/*************************************************************************
    CheckCBW
    ========
        Checks if CBW is valid and meaningful

    IN      pCBW    Command block wrapper
            iLen    Length of CBW

    Returns TRUE if valid and meaningful
**************************************************************************/
static BOOL CheckCBW(TCBW *pCBW, int iLen)
{
    // CBW valid?
    if (iLen != 31)
    {
        DBG("Invalid length (%d)\n", iLen);
        return FALSE;
    }
    if (pCBW->dwCBWSignature != CBW_SIGNATURE)
    {
        DBG("Invalid signature %x\n", pCBW->dwCBWSignature);
        return FALSE;
    }

    // CBW meaningful?
    if (pCBW->bCBWLun != 0)
    {
        DBG("Invalid LUN %d\n", pCBW->bCBWLun);
        return FALSE;
    }
    if ((pCBW->bCBWCBLength < 1) || (pCBW->bCBWCBLength > 16))
    {
        DBG("Invalid CB len %d\n", pCBW->bCBWCBLength);
        return FALSE;
    }
    return TRUE;
}


/*************************************************************************
    BOTStall
    ========
        Local function to stall ongoing transfer

    Which endpoint to stall is determined by looking at the transfer
    direction intended by the host.

**************************************************************************/
static void BOTStall(void)
{
   1552c:	e52de004 	str	lr, [sp, #-4]!
    if ((CBW.bmCBWFlags & 0x80) || (CBW.dwCBWDataTransferLength == 0))
   15530:	e59f202c 	ldr	r2, [pc, #44]	; 15564 <.text+0x5564>
   15534:	e1d230dc 	ldrsb	r3, [r2, #12]
   15538:	e3530000 	cmp	r3, #0	; 0x0
    {
        // stall data-in or CSW
        USBHwEPStall(MSC_BULK_IN_EP, TRUE);
   1553c:	e3a00085 	mov	r0, #133	; 0x85
   15540:	e3a01001 	mov	r1, #1	; 0x1
   15544:	ba000003 	blt	15558 <BOTStall+0x2c>
   15548:	e5923008 	ldr	r3, [r2, #8]
   1554c:	e3530000 	cmp	r3, #0	; 0x0
    }
    else
    {
        // stall data-out
        USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
   15550:	13a00002 	movne	r0, #2	; 0x2
   15554:	13a01001 	movne	r1, #1	; 0x1
   15558:	eb000419 	bl	165c4 <USBHwEPStall>
    }
}
   1555c:	e49de004 	ldr	lr, [sp], #4
   15560:	e12fff1e 	bx	lr
   15564:	40000ad0 	ldrmid	r0, [r0], -r0

00015568 <HandleDataIn>:


/*************************************************************************
    HandleDataIn
    ============
        Handles data from device-to-host

**************************************************************************/
static void HandleDataIn(void)
{
   15568:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
    int iChunk;

    // process data for host in SCSI layer
    pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
   1556c:	e59f609c 	ldr	r6, [pc, #156]	; 15610 <.text+0x5610>
   15570:	e59f409c 	ldr	r4, [pc, #156]	; 15614 <.text+0x5614>
   15574:	e59f509c 	ldr	r5, [pc, #156]	; 15618 <.text+0x5618>
   15578:	e5d6100e 	ldrb	r1, [r6, #14]
   1557c:	e5942000 	ldr	r2, [r4]
   15580:	e5953000 	ldr	r3, [r5]
   15584:	e286000f 	add	r0, r6, #15	; 0xf
   15588:	eb000129 	bl	15a34 <SCSIHandleData>
    if (pbData == NULL)
   1558c:	e3500000 	cmp	r0, #0	; 0x0
    {
        BOTStall();
        SendCSW(STATUS_FAILED);
        return;
    }

    // send data to host?
    if (dwOffset < dwTransferSize)
   15590:	e59f7084 	ldr	r7, [pc, #132]	; 1561c <.text+0x561c>
   15594:	e5840000 	str	r0, [r4]
   15598:	1a000002 	bne	155a8 <HandleDataIn+0x40>
   1559c:	ebffffe2 	bl	1552c <BOTStall>
   155a0:	e3a00001 	mov	r0, #1	; 0x1
   155a4:	ea000015 	b	15600 <HandleDataIn+0x98>
   155a8:	e5952000 	ldr	r2, [r5]
   155ac:	e5973000 	ldr	r3, [r7]
   155b0:	e1520003 	cmp	r2, r3
    {
        iChunk = MIN(64, dwTransferSize - dwOffset);
        USBHwEPWrite(MSC_BULK_IN_EP, pbData, iChunk);
   155b4:	e1a01000 	mov	r1, r0
   155b8:	e0624003 	rsb	r4, r2, r3
   155bc:	e3a00085 	mov	r0, #133	; 0x85
   155c0:	2a000006 	bcs	155e0 <HandleDataIn+0x78>
   155c4:	e3540040 	cmp	r4, #64	; 0x40
   155c8:	23a04040 	movcs	r4, #64	; 0x40
   155cc:	e1a02004 	mov	r2, r4
   155d0:	eb000403 	bl	165e4 <USBHwEPWrite>
        dwOffset += iChunk;
   155d4:	e5953000 	ldr	r3, [r5]
   155d8:	e0833004 	add	r3, r3, r4
   155dc:	e5853000 	str	r3, [r5]
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
   155e0:	e5952000 	ldr	r2, [r5]
   155e4:	e5973000 	ldr	r3, [r7]
   155e8:	e1520003 	cmp	r2, r3
   155ec:	1a000005 	bne	15608 <HandleDataIn+0xa0>
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
   155f0:	e5963008 	ldr	r3, [r6, #8]
   155f4:	e1520003 	cmp	r2, r3
        {
            // stall pipe
            DBG("stalling DIN");
            BOTStall();
   155f8:	1bffffcb 	blne	1552c <BOTStall>
        }
        // done
        SendCSW(STATUS_PASSED);
   155fc:	e3a00000 	mov	r0, #0	; 0x0
    }
}
   15600:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   15604:	eaffffb2 	b	154d4 <SendCSW>
   15608:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   1560c:	e12fff1e 	bx	lr
   15610:	40000ad0 	ldrmid	r0, [r0], -r0
   15614:	40000b04 	andmi	r0, r0, r4, lsl #22
   15618:	40000acc 	andmi	r0, r0, ip, asr #21
   1561c:	40000ac8 	andmi	r0, r0, r8, asr #21

00015620 <MSCBotBulkIn>:


/*************************************************************************
    HandleDataOut
    =============
        Handles data from host-to-device

**************************************************************************/
static void HandleDataOut(void)
{
    int iChunk;

    if (dwOffset < dwTransferSize)
    {
        // get data from host
        iChunk = USBHwEPRead(MSC_BULK_OUT_EP, pbData, dwTransferSize - dwOffset);
        // process data in SCSI layer
        pbData = SCSIHandleData(CBW.CBWCB, CBW.bCBWCBLength, pbData, dwOffset);
        if (pbData == NULL)
        {
            BOTStall();
            SendCSW(STATUS_FAILED);
            return;
        }
        dwOffset += iChunk;
    }

    // are we done now?
    if (dwOffset == dwTransferSize)
    {
        if (dwOffset != CBW.dwCBWDataTransferLength)
        {
            // stall pipe
            DBG("stalling DOUT");
            BOTStall();
        }
        SendCSW(STATUS_PASSED);
    }
}


/*************************************************************************
    MSCBotBulkOut
    ===============
        Handles the BOT bulk OUT endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkOut(U8 bEP, U8 bEPStatus)
{
    int     iLen, iChunk;
    BOOL    fHostIn, fDevIn;

    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
    {
        return;
    }

    switch (eState)
    {

        case eCBW:
            iLen = USBHwEPRead(bEP, (U8 *)&CBW, sizeof(CBW));

            // check if we got a good CBW
            if (!CheckCBW(&CBW, iLen))
            {
                // see 6.6.1
                USBHwEPStall(MSC_BULK_IN_EP, TRUE);
                USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
                eState = eStalled;
                break;
            }

            DBG("CBW: len=%d, flags=%x, cmd=%x, cmdlen=%d\n",
                    CBW.dwCBWDataTransferLength, CBW.bmCBWFlags, CBW.CBWCB[0], CBW.bCBWCBLength);

            dwOffset = 0;
            dwTransferSize = 0;
            fHostIn = ((CBW.bmCBWFlags & 0x80) != 0);

            // verify request
            pbData = SCSIHandleCmd(CBW.CBWCB, CBW.bCBWCBLength, &iLen, &fDevIn);
            if (pbData == NULL)
            {
                // unknown command
                BOTStall();
                SendCSW(STATUS_FAILED);
                break;
            }

            // rule: if device and host disagree on direction, send CSW with status 2
            if ((iLen > 0) &&
                ((fHostIn && !fDevIn) ||
                (!fHostIn && fDevIn)))
            {
                DBG("Host and device disagree on direction\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            // rule: if D > H, send CSW with status 2
            if (iLen > CBW.dwCBWDataTransferLength)
            {
                DBG("Negative residue\n");
                BOTStall();
                SendCSW(STATUS_PHASE_ERR);
                break;
            }

            dwTransferSize = iLen;
            if ((dwTransferSize == 0) || fDevIn)
            {
                // data from device-to-host
                eState = eDataIn;
                HandleDataIn();
            }
            else
            {
                // data from host-to-device
                eState = eDataOut;
            }
            break;

        case eDataOut:
            HandleDataOut();
            break;

        case eDataIn:
        case eCSW:
            iChunk = USBHwEPRead(bEP, NULL, 0);
            DBG("Phase error in state %d, %d bytes\n", eState, iChunk);
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_OUT_EP, TRUE);
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}


/*************************************************************************
    MSCBotBulkIn
    ============
        Handles the BOT bulk IN endpoint

    IN      bEP         Endpoint number
            bEPStatus   Endpoint status (indicates NAK, STALL, etc)

**************************************************************************/
void MSCBotBulkIn(U8 bEP, U8 bEPStatus)
{
   15620:	e92d4030 	stmdb	sp!, {r4, r5, lr}
    // ignore events on stalled EP
    if (bEPStatus & EP_STATUS_STALLED)
   15624:	e2114002 	ands	r4, r1, #2	; 0x2
    {
        return;
    }

    switch (eState)
   15628:	e59f504c 	ldr	r5, [pc, #76]	; 1567c <.text+0x567c>
   1562c:	1a000010 	bne	15674 <MSCBotBulkIn+0x54>
   15630:	e5953000 	ldr	r3, [r5]
   15634:	e3530003 	cmp	r3, #3	; 0x3
    {

        case eCBW:
        case eDataOut:
        // ignore possibly old ACKs
            break;

        case eDataIn:
            HandleDataIn();
            break;

        case eCSW:
        // wait for an IN token, then send the CSW
            USBHwEPWrite(MSC_BULK_IN_EP, (U8 *)&CSW, 13);
   15638:	e3a00085 	mov	r0, #133	; 0x85
   1563c:	e59f103c 	ldr	r1, [pc, #60]	; 15680 <.text+0x5680>
   15640:	e3a0200d 	mov	r2, #13	; 0xd
   15644:	0a000006 	beq	15664 <MSCBotBulkIn+0x44>
   15648:	e3530004 	cmp	r3, #4	; 0x4
            eState = eCBW;
            break;

        case eStalled:
        // keep stalling
            USBHwEPStall(MSC_BULK_IN_EP, TRUE);
   1564c:	e3a01001 	mov	r1, #1	; 0x1
   15650:	0a000006 	beq	15670 <MSCBotBulkIn+0x50>
   15654:	e3530002 	cmp	r3, #2	; 0x2
   15658:	1a000005 	bne	15674 <MSCBotBulkIn+0x54>
            break;

        default:
            DBG("Invalid state %d\n", eState);
//            ASSERT(FALSE);
            break;
    }
}
   1565c:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15660:	eaffffc0 	b	15568 <HandleDataIn>
   15664:	eb0003de 	bl	165e4 <USBHwEPWrite>
   15668:	e5854000 	str	r4, [r5]
   1566c:	ea000000 	b	15674 <MSCBotBulkIn+0x54>
   15670:	eb0003d3 	bl	165c4 <USBHwEPStall>
   15674:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15678:	e12fff1e 	bx	lr
   1567c:	40000b00 	andmi	r0, r0, r0, lsl #22
   15680:	40000af0 	strmid	r0, [r0], -r0

00015684 <MSCBotBulkOut>:
   15684:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15688:	e3110002 	tst	r1, #2	; 0x2
   1568c:	e24dd008 	sub	sp, sp, #8	; 0x8
   15690:	e20000ff 	and	r0, r0, #255	; 0xff
   15694:	1a000083 	bne	158a8 <.text+0x58a8>
   15698:	e59f3214 	ldr	r3, [pc, #532]	; 158b4 <.text+0x58b4>
   1569c:	e5933000 	ldr	r3, [r3]
   156a0:	e3530004 	cmp	r3, #4	; 0x4
   156a4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   156a8:	ea00007e 	b	158a8 <.text+0x58a8>
   156ac:	000156c0 	andeq	r5, r1, r0, asr #13
   156b0:	000157a8 	andeq	r5, r1, r8, lsr #15
   156b4:	00015844 	andeq	r5, r1, r4, asr #16
   156b8:	00015844 	andeq	r5, r1, r4, asr #16
   156bc:	00015860 	andeq	r5, r1, r0, ror #16
   156c0:	e59f41f0 	ldr	r4, [pc, #496]	; 158b8 <.text+0x58b8>
   156c4:	e3a02020 	mov	r2, #32	; 0x20
   156c8:	e1a01004 	mov	r1, r4
   156cc:	eb0003e6 	bl	1666c <USBHwEPRead>
   156d0:	e350001f 	cmp	r0, #31	; 0x1f
   156d4:	e58d0000 	str	r0, [sp]
   156d8:	1a00000a 	bne	15708 <.text+0x5708>
   156dc:	e5942000 	ldr	r2, [r4]
   156e0:	e59f31d4 	ldr	r3, [pc, #468]	; 158bc <.text+0x58bc>
   156e4:	e1520003 	cmp	r2, r3
   156e8:	1a000006 	bne	15708 <.text+0x5708>
   156ec:	e5d4e00d 	ldrb	lr, [r4, #13]
   156f0:	e35e0000 	cmp	lr, #0	; 0x0
   156f4:	1a000003 	bne	15708 <.text+0x5708>
   156f8:	e5d4100e 	ldrb	r1, [r4, #14]
   156fc:	e2413001 	sub	r3, r1, #1	; 0x1
   15700:	e353000f 	cmp	r3, #15	; 0xf
   15704:	9a000059 	bls	15870 <.text+0x5870>
   15708:	e3a00085 	mov	r0, #133	; 0x85
   1570c:	e3a01001 	mov	r1, #1	; 0x1
   15710:	eb0003ab 	bl	165c4 <USBHwEPStall>
   15714:	e3a00002 	mov	r0, #2	; 0x2
   15718:	e3a01001 	mov	r1, #1	; 0x1
   1571c:	eb0003a8 	bl	165c4 <USBHwEPStall>
   15720:	e3a02004 	mov	r2, #4	; 0x4
   15724:	ea00004a 	b	15854 <.text+0x5854>
   15728:	e59d2000 	ldr	r2, [sp]
   1572c:	e3520000 	cmp	r2, #0	; 0x0
   15730:	da00000b 	ble	15764 <.text+0x5764>
   15734:	e3140080 	tst	r4, #128	; 0x80
   15738:	e59d3004 	ldr	r3, [sp, #4]
   1573c:	0a000002 	beq	1574c <.text+0x574c>
   15740:	e3530000 	cmp	r3, #0	; 0x0
   15744:	0a000002 	beq	15754 <.text+0x5754>
   15748:	ea000005 	b	15764 <.text+0x5764>
   1574c:	e3530000 	cmp	r3, #0	; 0x0
   15750:	0a000003 	beq	15764 <.text+0x5764>
   15754:	ebffff74 	bl	1552c <BOTStall>
   15758:	e3a00002 	mov	r0, #2	; 0x2
   1575c:	ebffff5c 	bl	154d4 <SendCSW>
   15760:	ea000050 	b	158a8 <.text+0x58a8>
   15764:	e59f314c 	ldr	r3, [pc, #332]	; 158b8 <.text+0x58b8>
   15768:	e5933008 	ldr	r3, [r3, #8]
   1576c:	e1520003 	cmp	r2, r3
   15770:	8afffff7 	bhi	15754 <.text+0x5754>
   15774:	e59f3144 	ldr	r3, [pc, #324]	; 158c0 <.text+0x58c0>
   15778:	e3520000 	cmp	r2, #0	; 0x0
   1577c:	e5832000 	str	r2, [r3]
   15780:	0a000003 	beq	15794 <.text+0x5794>
   15784:	e59d3004 	ldr	r3, [sp, #4]
   15788:	e3530000 	cmp	r3, #0	; 0x0
   1578c:	03a02001 	moveq	r2, #1	; 0x1
   15790:	0a00002f 	beq	15854 <.text+0x5854>
   15794:	e59f3118 	ldr	r3, [pc, #280]	; 158b4 <.text+0x58b4>
   15798:	e3a02002 	mov	r2, #2	; 0x2
   1579c:	e5832000 	str	r2, [r3]
   157a0:	ebffff70 	bl	15568 <HandleDataIn>
   157a4:	ea00003f 	b	158a8 <.text+0x58a8>
   157a8:	e59f5114 	ldr	r5, [pc, #276]	; 158c4 <.text+0x58c4>
   157ac:	e59f310c 	ldr	r3, [pc, #268]	; 158c0 <.text+0x58c0>
   157b0:	e5951000 	ldr	r1, [r5]
   157b4:	e5932000 	ldr	r2, [r3]
   157b8:	e1510002 	cmp	r1, r2
   157bc:	2a000014 	bcs	15814 <.text+0x5814>
   157c0:	e59f4100 	ldr	r4, [pc, #256]	; 158c8 <.text+0x58c8>
   157c4:	e0612002 	rsb	r2, r1, r2
   157c8:	e3a00002 	mov	r0, #2	; 0x2
   157cc:	e5941000 	ldr	r1, [r4]
   157d0:	eb0003a5 	bl	1666c <USBHwEPRead>
   157d4:	e1a06000 	mov	r6, r0
   157d8:	e59f00d8 	ldr	r0, [pc, #216]	; 158b8 <.text+0x58b8>
   157dc:	e5953000 	ldr	r3, [r5]
   157e0:	e5d0100e 	ldrb	r1, [r0, #14]
   157e4:	e5942000 	ldr	r2, [r4]
   157e8:	e280000f 	add	r0, r0, #15	; 0xf
   157ec:	eb000090 	bl	15a34 <SCSIHandleData>
   157f0:	e3500000 	cmp	r0, #0	; 0x0
   157f4:	15953000 	ldrne	r3, [r5]
   157f8:	10833006 	addne	r3, r3, r6
   157fc:	e5840000 	str	r0, [r4]
   15800:	15853000 	strne	r3, [r5]
   15804:	1a000002 	bne	15814 <.text+0x5814>
   15808:	ebffff47 	bl	1552c <BOTStall>
   1580c:	e3a00001 	mov	r0, #1	; 0x1
   15810:	eaffffd1 	b	1575c <.text+0x575c>
   15814:	e59f30a8 	ldr	r3, [pc, #168]	; 158c4 <.text+0x58c4>
   15818:	e5932000 	ldr	r2, [r3]
   1581c:	e59f309c 	ldr	r3, [pc, #156]	; 158c0 <.text+0x58c0>
   15820:	e5933000 	ldr	r3, [r3]
   15824:	e1520003 	cmp	r2, r3
   15828:	1a00001e 	bne	158a8 <.text+0x58a8>
   1582c:	e59f3084 	ldr	r3, [pc, #132]	; 158b8 <.text+0x58b8>
   15830:	e5933008 	ldr	r3, [r3, #8]
   15834:	e1520003 	cmp	r2, r3
   15838:	1bffff3b 	blne	1552c <BOTStall>
   1583c:	e3a00000 	mov	r0, #0	; 0x0
   15840:	eaffffc5 	b	1575c <.text+0x575c>
   15844:	e3a01000 	mov	r1, #0	; 0x0
   15848:	e1a02001 	mov	r2, r1
   1584c:	eb000386 	bl	1666c <USBHwEPRead>
   15850:	e3a02000 	mov	r2, #0	; 0x0
   15854:	e59f3058 	ldr	r3, [pc, #88]	; 158b4 <.text+0x58b4>
   15858:	e5832000 	str	r2, [r3]
   1585c:	ea000011 	b	158a8 <.text+0x58a8>
   15860:	e3a00002 	mov	r0, #2	; 0x2
   15864:	e3a01001 	mov	r1, #1	; 0x1
   15868:	eb000355 	bl	165c4 <USBHwEPStall>
   1586c:	ea00000d 	b	158a8 <.text+0x58a8>
   15870:	e59fc048 	ldr	ip, [pc, #72]	; 158c0 <.text+0x58c0>
   15874:	e58ce000 	str	lr, [ip]
   15878:	e59fc044 	ldr	ip, [pc, #68]	; 158c4 <.text+0x58c4>
   1587c:	e284000f 	add	r0, r4, #15	; 0xf
   15880:	e28d3004 	add	r3, sp, #4	; 0x4
   15884:	e1a0200d 	mov	r2, sp
   15888:	e58ce000 	str	lr, [ip]
   1588c:	e5d4400c 	ldrb	r4, [r4, #12]
   15890:	eb00001a 	bl	15900 <SCSIHandleCmd>
   15894:	e59f302c 	ldr	r3, [pc, #44]	; 158c8 <.text+0x58c8>
   15898:	e3500000 	cmp	r0, #0	; 0x0
   1589c:	e5830000 	str	r0, [r3]
   158a0:	1affffa0 	bne	15728 <.text+0x5728>
   158a4:	eaffffd7 	b	15808 <.text+0x5808>
   158a8:	e28dd008 	add	sp, sp, #8	; 0x8
   158ac:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   158b0:	e12fff1e 	bx	lr
   158b4:	40000b00 	andmi	r0, r0, r0, lsl #22
   158b8:	40000ad0 	ldrmid	r0, [r0], -r0
   158bc:	43425355 	movtmi	r5, #9045	; 0x2355
   158c0:	40000ac8 	andmi	r0, r0, r8, asr #21
   158c4:	40000acc 	andmi	r0, r0, ip, asr #21
   158c8:	40000b04 	andmi	r0, r0, r4, lsl #22

000158cc <MSCBotReset>:
   158cc:	e59f3014 	ldr	r3, [pc, #20]	; 158e8 <.text+0x58e8>
   158d0:	e3a02000 	mov	r2, #0	; 0x0
   158d4:	e52de004 	str	lr, [sp, #-4]!
   158d8:	e5832000 	str	r2, [r3]
   158dc:	eb000002 	bl	158ec <SCSIReset>
   158e0:	e49de004 	ldr	lr, [sp], #4
   158e4:	e12fff1e 	bx	lr
   158e8:	40000b00 	andmi	r0, r0, r0, lsl #22

000158ec <SCSIReset>:

**************************************************************************/
void SCSIReset(void)
{
    dwSense = 0;
   158ec:	e59f3008 	ldr	r3, [pc, #8]	; 158fc <.text+0x58fc>
   158f0:	e3a02000 	mov	r2, #0	; 0x0
   158f4:	e5832000 	str	r2, [r3]
}
   158f8:	e12fff1e 	bx	lr
   158fc:	40000b08 	andmi	r0, r0, r8, lsl #22

00015900 <SCSIHandleCmd>:


/*************************************************************************
    SCSIHandleCmd
    =============
        Verifies a SCSI CDB and indicates the direction and amount of data
        that the device wants to transfer.

    If this call fails, a sense code is set in dwSense.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    OUT     *piRspLen   Length of intended response data:
            *pfDevIn    TRUE if data is transferred from device-to-host

    Returns a pointer to the data exchange buffer if successful,
    return NULL otherwise.
**************************************************************************/
U8 * SCSIHandleCmd(U8 *pbCDB, int iCDBLen, int *piRspLen, BOOL *pfDevIn)
{
   15900:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15904:	e1a04000 	mov	r4, r0
   15908:	e24dd008 	sub	sp, sp, #8	; 0x8
    int     i;
    TCDB6   *pCDB;
    U32     dwLen, dwLBA;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
   1590c:	e3a08008 	mov	r8, #8	; 0x8
   15910:	e1a06001 	mov	r6, r1
   15914:	e1a05002 	mov	r5, r2
   15918:	e1a0000d 	mov	r0, sp
   1591c:	e1a02008 	mov	r2, r8
   15920:	e1a01004 	mov	r1, r4
   15924:	e1a07003 	mov	r7, r3
   15928:	eb000712 	bl	17578 <memcpy>
	
    // default direction is from device to host
    *pfDevIn = TRUE;

    switch (pCDB->bOperationCode)
   1592c:	e5dd2000 	ldrb	r2, [sp]
   15930:	e3a03001 	mov	r3, #1	; 0x1
   15934:	e3520012 	cmp	r2, #18	; 0x12
   15938:	e5873000 	str	r3, [r7]
   1593c:	0a000013 	beq	15990 <SCSIHandleCmd+0x90>
   15940:	8a000006 	bhi	15960 <SCSIHandleCmd+0x60>
   15944:	e3520000 	cmp	r2, #0	; 0x0
    {

        // test unit ready (6)
        case SCSI_CMD_TEST_UNIT_READY:
            DBG("TEST UNIT READY\n");
            *piRspLen = 0;
   15948:	059f00dc 	ldreq	r0, [pc, #220]	; 15a2c <.text+0x5a2c>
   1594c:	05852000 	streq	r2, [r5]
   15950:	0a000032 	beq	15a20 <SCSIHandleCmd+0x120>
   15954:	e3520003 	cmp	r2, #3	; 0x3
   15958:	1a000028 	bne	15a00 <SCSIHandleCmd+0x100>
   1595c:	ea000006 	b	1597c <SCSIHandleCmd+0x7c>
   15960:	e3520028 	cmp	r2, #40	; 0x28
   15964:	0a000012 	beq	159b4 <SCSIHandleCmd+0xb4>
   15968:	e352002a 	cmp	r2, #42	; 0x2a
   1596c:	0a000018 	beq	159d4 <SCSIHandleCmd+0xd4>
   15970:	e3520025 	cmp	r2, #37	; 0x25
   15974:	1a000021 	bne	15a00 <SCSIHandleCmd+0x100>
   15978:	ea00000a 	b	159a8 <SCSIHandleCmd+0xa8>
            break;

        // request sense (6)
        case SCSI_CMD_REQUEST_SENSE:
            DBG("REQUEST SENSE (%06X)\n", dwSense);
            // check params
            *piRspLen = MIN(18, pCDB->bLength);
   1597c:	e5dd3004 	ldrb	r3, [sp, #4]
   15980:	e59f00a4 	ldr	r0, [pc, #164]	; 15a2c <.text+0x5a2c>
   15984:	e3530012 	cmp	r3, #18	; 0x12
   15988:	23a03012 	movcs	r3, #18	; 0x12
   1598c:	ea000003 	b	159a0 <SCSIHandleCmd+0xa0>
            break;

        // inquiry (6)
        case SCSI_CMD_INQUIRY:
            DBG("INQUIRY\n");
            // see SPC20r20, 4.3.4.6
            *piRspLen = MIN(36, pCDB->bLength);
   15990:	e5dd3004 	ldrb	r3, [sp, #4]
   15994:	e59f0090 	ldr	r0, [pc, #144]	; 15a2c <.text+0x5a2c>
   15998:	e3530024 	cmp	r3, #36	; 0x24
   1599c:	23a03024 	movcs	r3, #36	; 0x24
   159a0:	e5853000 	str	r3, [r5]
   159a4:	ea00001d 	b	15a20 <SCSIHandleCmd+0x120>
            break;

        // read capacity (10)
        case SCSI_CMD_READ_CAPACITY:
            DBG("READ CAPACITY\n");
            *piRspLen = 8;
   159a8:	e59f007c 	ldr	r0, [pc, #124]	; 15a2c <.text+0x5a2c>
   159ac:	e5858000 	str	r8, [r5]
   159b0:	ea00001a 	b	15a20 <SCSIHandleCmd+0x120>
            break;

        // read (10)
        case SCSI_CMD_READ_10:
            if (iCDBLen != 10)
   159b4:	e356000a 	cmp	r6, #10	; 0xa
   159b8:	1a000017 	bne	15a1c <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("READ10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
   159bc:	e5d43008 	ldrb	r3, [r4, #8]
   159c0:	e5d42007 	ldrb	r2, [r4, #7]
   159c4:	e59f0060 	ldr	r0, [pc, #96]	; 15a2c <.text+0x5a2c>
   159c8:	e1833402 	orr	r3, r3, r2, lsl #8
   159cc:	e1a03483 	mov	r3, r3, lsl #9
   159d0:	eafffff2 	b	159a0 <SCSIHandleCmd+0xa0>
            break;

        // write (10)
        case SCSI_CMD_WRITE_10:
            if (iCDBLen != 10)
   159d4:	e356000a 	cmp	r6, #10	; 0xa
   159d8:	1a00000f 	bne	15a1c <SCSIHandleCmd+0x11c>
            {
                return NULL;
            }
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);
            dwLen = (pbCDB[7] << 8) | pbCDB[8];
            DBG("WRITE10, LBA=%d, len=%d\n", dwLBA, dwLen);
            *piRspLen = dwLen * BLOCKSIZE;
   159dc:	e5d43008 	ldrb	r3, [r4, #8]
   159e0:	e5d42007 	ldrb	r2, [r4, #7]
   159e4:	e1833402 	orr	r3, r3, r2, lsl #8
   159e8:	e1a03483 	mov	r3, r3, lsl #9
            *pfDevIn = FALSE;
   159ec:	e59f0038 	ldr	r0, [pc, #56]	; 15a2c <.text+0x5a2c>
   159f0:	e5853000 	str	r3, [r5]
   159f4:	e3a03000 	mov	r3, #0	; 0x0
   159f8:	e5873000 	str	r3, [r7]
   159fc:	ea000007 	b	15a20 <SCSIHandleCmd+0x120>
            break;

        default:
            DBG("Unhandled SCSI: ");
            for (i = 0; i < iCDBLen; i++)
            {
                DBG(" %02X", pbCDB[i]);
            }
            DBG("\n");
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
            *piRspLen = 0;
   15a00:	e3a01000 	mov	r1, #0	; 0x0
   15a04:	e59f3024 	ldr	r3, [pc, #36]	; 15a30 <.text+0x5a30>
   15a08:	e3a02a52 	mov	r2, #335872	; 0x52000
   15a0c:	e1a00001 	mov	r0, r1
   15a10:	e5832000 	str	r2, [r3]
   15a14:	e5851000 	str	r1, [r5]
   15a18:	ea000000 	b	15a20 <SCSIHandleCmd+0x120>
            return NULL;
   15a1c:	e3a00000 	mov	r0, #0	; 0x0
        }


    return abBlockBuf;
}
   15a20:	e28dd008 	add	sp, sp, #8	; 0x8
   15a24:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   15a28:	e12fff1e 	bx	lr
   15a2c:	40000b0c 	andmi	r0, r0, ip, lsl #22
   15a30:	40000b08 	andmi	r0, r0, r8, lsl #22

00015a34 <SCSIHandleData>:


/*************************************************************************
    SCSIHandleData
    ==============
        Handles a block of SCSI data.

    IN      pbCDB       Command data block
            iCDBLen     Command data block len
    IN/OUT  pbData      Data buffer
    IN      dwOffset    Offset in data

    Returns a pointer to the next data to be exchanged if successful,
    returns NULL otherwise.
**************************************************************************/
U8 * SCSIHandleData(U8 *pbCDB, int iCDBLen, U8 *pbData, U32 dwOffset)
{
   15a34:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15a38:	e1a04000 	mov	r4, r0
   15a3c:	e24dd00c 	sub	sp, sp, #12	; 0xc
   15a40:	e1a05002 	mov	r5, r2
    TCDB6   *pCDB;
    U32     dwLBA;
    U32     dwBufPos, dwBlockNr;
    U32     dwNumBlocks, dwMaxBlock;

	//pCDB = (TCDB6 *)pbCDB;
	//Compiler warning fix
    TCDB6 cdb;
	pCDB = &cdb;
	memcpy(pCDB, pbCDB, sizeof(TCDB6));
   15a44:	e1a0000d 	mov	r0, sp
   15a48:	e1a01004 	mov	r1, r4
   15a4c:	e3a02008 	mov	r2, #8	; 0x8
   15a50:	e1a06003 	mov	r6, r3
   15a54:	eb0006c7 	bl	17578 <memcpy>
	
    switch (pCDB->bOperationCode)
   15a58:	e5dd3000 	ldrb	r3, [sp]
   15a5c:	e3530012 	cmp	r3, #18	; 0x12
   15a60:	0a000022 	beq	15af0 <SCSIHandleData+0xbc>
   15a64:	8a000004 	bhi	15a7c <SCSIHandleData+0x48>
   15a68:	e3530000 	cmp	r3, #0	; 0x0
   15a6c:	0a000009 	beq	15a98 <SCSIHandleData+0x64>
   15a70:	e3530003 	cmp	r3, #3	; 0x3
   15a74:	1a000065 	bne	15c10 <SCSIHandleData+0x1dc>
   15a78:	ea00000d 	b	15ab4 <SCSIHandleData+0x80>
   15a7c:	e3530028 	cmp	r3, #40	; 0x28
   15a80:	0a000034 	beq	15b58 <SCSIHandleData+0x124>
   15a84:	e353002a 	cmp	r3, #42	; 0x2a
   15a88:	0a000046 	beq	15ba8 <SCSIHandleData+0x174>
   15a8c:	e3530025 	cmp	r3, #37	; 0x25
   15a90:	1a00005e 	bne	15c10 <SCSIHandleData+0x1dc>
   15a94:	ea00001b 	b	15b08 <SCSIHandleData+0xd4>
    {

        // test unit ready
        case 0x00:
            if (dwSense != 0)
   15a98:	e59f3190 	ldr	r3, [pc, #400]	; 15c30 <.text+0x5c30>
   15a9c:	e5932000 	ldr	r2, [r3]
   15aa0:	e59f318c 	ldr	r3, [pc, #396]	; 15c34 <.text+0x5c34>
   15aa4:	e3520000 	cmp	r2, #0	; 0x0
   15aa8:	01a0e003 	moveq	lr, r3
   15aac:	13a0e000 	movne	lr, #0	; 0x0
   15ab0:	ea00005a 	b	15c20 <SCSIHandleData+0x1ec>
            {
                return NULL;
            }
            break;

        // request sense
        case SCSI_CMD_REQUEST_SENSE:
            memcpy(pbData, abSense, 18);
   15ab4:	e59f117c 	ldr	r1, [pc, #380]	; 15c38 <.text+0x5c38>
   15ab8:	e3a02012 	mov	r2, #18	; 0x12
   15abc:	e1a00005 	mov	r0, r5
   15ac0:	eb0006ac 	bl	17578 <memcpy>
            // fill in KEY/ASC/ASCQ
            pbData[2] = (dwSense >> 16) & 0xFF;
   15ac4:	e59f0164 	ldr	r0, [pc, #356]	; 15c30 <.text+0x5c30>
   15ac8:	e5903000 	ldr	r3, [r0]
            pbData[12] = (dwSense >> 8) & 0xFF;
            pbData[13] = (dwSense >> 0) & 0xFF;
            // reset sense data
            dwSense = 0;
   15acc:	e59fe160 	ldr	lr, [pc, #352]	; 15c34 <.text+0x5c34>
   15ad0:	e1a02823 	mov	r2, r3, lsr #16
   15ad4:	e1a01423 	mov	r1, r3, lsr #8
   15ad8:	e5c5300d 	strb	r3, [r5, #13]
   15adc:	e3a03000 	mov	r3, #0	; 0x0
   15ae0:	e5c52002 	strb	r2, [r5, #2]
   15ae4:	e5c5100c 	strb	r1, [r5, #12]
   15ae8:	e5803000 	str	r3, [r0]
   15aec:	ea00004b 	b	15c20 <SCSIHandleData+0x1ec>
            break;

        // inquiry
        case SCSI_CMD_INQUIRY:
            memcpy(pbData, abInquiry, sizeof(abInquiry));
   15af0:	e1a00005 	mov	r0, r5
   15af4:	e59f1140 	ldr	r1, [pc, #320]	; 15c3c <.text+0x5c3c>
   15af8:	e3a02024 	mov	r2, #36	; 0x24
   15afc:	eb00069d 	bl	17578 <memcpy>
   15b00:	e59fe12c 	ldr	lr, [pc, #300]	; 15c34 <.text+0x5c34>
   15b04:	ea000045 	b	15c20 <SCSIHandleData+0x1ec>
            break;

        // read capacity
        case SCSI_CMD_READ_CAPACITY:
        // get size of drive (bytes)
            BlockDevGetSize(&dwNumBlocks);
   15b08:	e28d0008 	add	r0, sp, #8	; 0x8
   15b0c:	eb000088 	bl	15d34 <BlockDevGetSize>
            // calculate highest LBA
            dwMaxBlock = (dwNumBlocks - 1) / 512;
   15b10:	e59d3008 	ldr	r3, [sp, #8]
   15b14:	e2433001 	sub	r3, r3, #1	; 0x1
   15b18:	e1a004a3 	mov	r0, r3, lsr #9

            pbData[0] = (dwMaxBlock >> 24) & 0xFF;
            pbData[1] = (dwMaxBlock >> 16) & 0xFF;
            pbData[2] = (dwMaxBlock >> 8) & 0xFF;
   15b1c:	e1a0c8a3 	mov	ip, r3, lsr #17
            pbData[3] = (dwMaxBlock >> 0) & 0xFF;
            pbData[4] = (BLOCKSIZE >> 24) & 0xFF;
            pbData[5] = (BLOCKSIZE >> 16) & 0xFF;
            pbData[6] = (BLOCKSIZE >> 8) & 0xFF;
            pbData[7] = (BLOCKSIZE >> 0) & 0xFF;
   15b20:	e59fe10c 	ldr	lr, [pc, #268]	; 15c34 <.text+0x5c34>
   15b24:	e1a03ca3 	mov	r3, r3, lsr #25
   15b28:	e3a02000 	mov	r2, #0	; 0x0
   15b2c:	e1a01c20 	mov	r1, r0, lsr #24
   15b30:	e5c53001 	strb	r3, [r5, #1]
   15b34:	e3a03002 	mov	r3, #2	; 0x2
   15b38:	e5c52007 	strb	r2, [r5, #7]
   15b3c:	e5c51000 	strb	r1, [r5]
   15b40:	e5c5c002 	strb	ip, [r5, #2]
   15b44:	e5c50003 	strb	r0, [r5, #3]
   15b48:	e5c53006 	strb	r3, [r5, #6]
   15b4c:	e5c52004 	strb	r2, [r5, #4]
   15b50:	e5c52005 	strb	r2, [r5, #5]
   15b54:	ea000031 	b	15c20 <SCSIHandleData+0x1ec>
            break;

        // read10
        case SCSI_CMD_READ_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data from block buffer
            dwBufPos = (dwOffset & (BLOCKSIZE - 1));
   15b58:	e1a05b86 	mov	r5, r6, lsl #23
   15b5c:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
   15b60:	e3550000 	cmp	r5, #0	; 0x0
   15b64:	e5d42005 	ldrb	r2, [r4, #5]
   15b68:	e5d43002 	ldrb	r3, [r4, #2]
   15b6c:	e5d40003 	ldrb	r0, [r4, #3]
   15b70:	e5d41004 	ldrb	r1, [r4, #4]
   15b74:	1a000022 	bne	15c04 <SCSIHandleData+0x1d0>
            {
                // read new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("R");
                if (BlockDevRead(dwBlockNr, abBlockBuf) < 0)
   15b78:	e1a00800 	mov	r0, r0, lsl #16
   15b7c:	e1800c03 	orr	r0, r0, r3, lsl #24
   15b80:	e1800002 	orr	r0, r0, r2
   15b84:	e1800401 	orr	r0, r0, r1, lsl #8
   15b88:	e08004a6 	add	r0, r0, r6, lsr #9
   15b8c:	e59f10a0 	ldr	r1, [pc, #160]	; 15c34 <.text+0x5c34>
   15b90:	eb0000d2 	bl	15ee0 <BlockDevRead>
   15b94:	e3500000 	cmp	r0, #0	; 0x0
                {
                    dwSense = READ_ERROR;
   15b98:	b1a0e005 	movlt	lr, r5
   15b9c:	b59f209c 	ldrlt	r2, [pc, #156]	; 15c40 <.text+0x5c40>
   15ba0:	ba000014 	blt	15bf8 <SCSIHandleData+0x1c4>
   15ba4:	ea000016 	b	15c04 <SCSIHandleData+0x1d0>
                    DBG("BlockDevRead failed\n");
                    return NULL;
                }
            }
            // return pointer to data
            return abBlockBuf + dwBufPos;

            // write10
            case SCSI_CMD_WRITE_10:
            dwLBA = (pbCDB[2] << 24) | (pbCDB[3] << 16) | (pbCDB[4] << 8) | (pbCDB[5]);

            // copy data to block buffer
            dwBufPos = ((dwOffset + 64) & (BLOCKSIZE - 1));
   15ba8:	e2863040 	add	r3, r6, #64	; 0x40
   15bac:	e1a05b83 	mov	r5, r3, lsl #23
   15bb0:	e1a05ba5 	mov	r5, r5, lsr #23
            if (dwBufPos == 0)
   15bb4:	e3550000 	cmp	r5, #0	; 0x0
   15bb8:	e5d42005 	ldrb	r2, [r4, #5]
   15bbc:	e5d43002 	ldrb	r3, [r4, #2]
   15bc0:	e5d40003 	ldrb	r0, [r4, #3]
   15bc4:	e5d41004 	ldrb	r1, [r4, #4]
   15bc8:	1a00000d 	bne	15c04 <SCSIHandleData+0x1d0>
            {
                // write new block
                dwBlockNr = dwLBA + (dwOffset / BLOCKSIZE);
                DBG("W");
                if (BlockDevWrite(dwBlockNr, abBlockBuf) < 0)
   15bcc:	e1a00800 	mov	r0, r0, lsl #16
   15bd0:	e1800c03 	orr	r0, r0, r3, lsl #24
   15bd4:	e1800002 	orr	r0, r0, r2
   15bd8:	e1800401 	orr	r0, r0, r1, lsl #8
   15bdc:	e08004a6 	add	r0, r0, r6, lsr #9
   15be0:	e59f104c 	ldr	r1, [pc, #76]	; 15c34 <.text+0x5c34>
   15be4:	eb000039 	bl	15cd0 <BlockDevWrite>
   15be8:	e3500000 	cmp	r0, #0	; 0x0
   15bec:	aa000004 	bge	15c04 <SCSIHandleData+0x1d0>
                {
                    dwSense = WRITE_ERROR;
   15bf0:	e1a0e005 	mov	lr, r5
   15bf4:	e3a02bc3 	mov	r2, #199680	; 0x30c00
   15bf8:	e59f3030 	ldr	r3, [pc, #48]	; 15c30 <.text+0x5c30>
   15bfc:	e5832000 	str	r2, [r3]
   15c00:	ea000006 	b	15c20 <SCSIHandleData+0x1ec>
                    DBG("BlockDevWrite failed\n");
                    return NULL;
                }
            }
            // return pointer to next data
            return abBlockBuf + dwBufPos;
   15c04:	e59f3028 	ldr	r3, [pc, #40]	; 15c34 <.text+0x5c34>
   15c08:	e085e003 	add	lr, r5, r3
   15c0c:	ea000003 	b	15c20 <SCSIHandleData+0x1ec>

            default:
            // unsupported command
            dwSense = INVALID_CMD_OPCODE;
   15c10:	e59f3018 	ldr	r3, [pc, #24]	; 15c30 <.text+0x5c30>
   15c14:	e3a02a52 	mov	r2, #335872	; 0x52000
   15c18:	e5832000 	str	r2, [r3]
   15c1c:	e3a0e000 	mov	lr, #0	; 0x0
            return NULL;
        }

    // default: return pointer to start of block buffer
    return abBlockBuf;
}
   15c20:	e1a0000e 	mov	r0, lr
   15c24:	e28dd00c 	add	sp, sp, #12	; 0xc
   15c28:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   15c2c:	e12fff1e 	bx	lr
   15c30:	40000b08 	andmi	r0, r0, r8, lsl #22
   15c34:	40000b0c 	andmi	r0, r0, ip, lsl #22
   15c38:	00017eac 	andeq	r7, r1, ip, lsr #29
   15c3c:	00017ebe 	streqh	r7, [r1], -lr
   15c40:	00031100 	andeq	r1, r3, r0, lsl #2

00015c44 <Resp8b>:

/*****************************************************************************/

static U8 Resp8b(void)
{
   15c44:	e92d4010 	stmdb	sp!, {r4, lr}
   15c48:	e3a04000 	mov	r4, #0	; 0x0
    U8 i;
    U8 resp;

    /* Respone will come after 1 - 8 pings */
    for (i = 0; i < 8; i++)
    {
        resp = SPISend(0xff);
   15c4c:	e3a000ff 	mov	r0, #255	; 0xff
   15c50:	eb000146 	bl	16170 <SPISend>
   15c54:	e2843001 	add	r3, r4, #1	; 0x1
        if (resp != 0xff)
   15c58:	e35000ff 	cmp	r0, #255	; 0xff
   15c5c:	e20340ff 	and	r4, r3, #255	; 0xff
   15c60:	1a000001 	bne	15c6c <Resp8b+0x28>
   15c64:	e3540008 	cmp	r4, #8	; 0x8
   15c68:	1afffff7 	bne	15c4c <Resp8b+0x8>
        {
            return resp;
        }
    }

    return resp;
}
   15c6c:	e8bd4010 	ldmia	sp!, {r4, lr}
   15c70:	e12fff1e 	bx	lr

00015c74 <Command>:
   15c74:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   15c78:	e1a03001 	mov	r3, r1
   15c7c:	e24dd008 	sub	sp, sp, #8	; 0x8
   15c80:	e3804040 	orr	r4, r0, #64	; 0x40
   15c84:	e3e05000 	mvn	r5, #0	; 0x0
   15c88:	e1a02c21 	mov	r2, r1, lsr #24
   15c8c:	e1a0c821 	mov	ip, r1, lsr #16
   15c90:	e1a0e421 	mov	lr, r1, lsr #8
   15c94:	e5cd3005 	strb	r3, [sp, #5]
   15c98:	e1a0000d 	mov	r0, sp
   15c9c:	e3e0306a 	mvn	r3, #106	; 0x6a
   15ca0:	e3a01008 	mov	r1, #8	; 0x8
   15ca4:	e5cd4001 	strb	r4, [sp, #1]
   15ca8:	e5cd2002 	strb	r2, [sp, #2]
   15cac:	e5cdc003 	strb	ip, [sp, #3]
   15cb0:	e5cde004 	strb	lr, [sp, #4]
   15cb4:	e5cd3006 	strb	r3, [sp, #6]
   15cb8:	e5cd5007 	strb	r5, [sp, #7]
   15cbc:	e5cd5000 	strb	r5, [sp]
   15cc0:	eb00013e 	bl	161c0 <SPISendN>
   15cc4:	e28dd008 	add	sp, sp, #8	; 0x8
   15cc8:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15ccc:	e12fff1e 	bx	lr

00015cd0 <BlockDevWrite>:

/*****************************************************************************/

static void Resp8bError(U8 value)
{
    switch (value)
    {
        case 0x40:  rprintf("Argument out of bounds.\n");               break;
        case 0x20:  rprintf("Address out of bounds.\n");                break;
        case 0x10:  rprintf("Error during erase sequence.\n");          break;
        case 0x08:  rprintf("CRC failed.\n");                           break;
        case 0x04:  rprintf("Illegal command.\n");                      break;
        case 0x02:  rprintf("Erase reset (see SanDisk docs p5-13).\n"); break;
//        case 0x01:  rprintf("Card is initialising.\n");                 break;
        case 0x01:  rprintf(".");                 break;
            default:
            rprintf("Unknown error 0x%x (see SanDisk docs p5-13).\n", value);
            break;
    }
}


/* ****************************************************************************
 calculates size of card from CSD
 (extension by Martin Thomas, inspired by code from Holger Klabunde)
 */
int BlockDevGetSize(U32 *pdwDriveSize)
{
    U8 cardresp, i, by;
    U8 iob[16];
    U16 c_size, c_size_mult, read_bl_len;

    Command(CMD_READCSD, 0);
    do
    {
        cardresp = Resp8b();
    }
    while (cardresp != 0xFE);

    rprintf("CSD:");
    for (i = 0; i < 16; i++)
    {
        iob[i] = SPISend(0xFF);
        rprintf(" %02x", iob[i]);
    }
    rprintf("\n");

    SPISend(0xff);
    SPISend(0xff);

    c_size = iob[6] & 0x03;     // bits 1..0
    c_size <<= 10;
    c_size += (U16) iob[7] << 2;
    c_size += iob[8] >> 6;

    by = iob[5] & 0x0F;
    read_bl_len = 1 << by;

    by = iob[9] & 0x03;
    by <<= 1;
    by += iob[10] >> 7;

    c_size_mult = 1 << (2 + by);

    *pdwDriveSize = (U32) (c_size + 1) * (U32) c_size_mult *(U32) read_bl_len;

    return 0;
}

/*****************************************************************************/

static U16 Resp16b(void)
{
    U16 resp;

    resp = (Resp8b() << 8) & 0xff00;
    resp |= SPISend(0xff);

    return resp;
}

/*****************************************************************************/

static int State(void)
{
    U16 value;

    Command(CMD_SENDSTATUS, 0);
    value = Resp16b();

    switch (value)
    {
        case 0x0000: return 1;
        case 0x0001: rprintf("Card is Locked.\n");                                                  break;
        case 0x0002: rprintf("WP Erase Skip, Lock/Unlock Cmd Failed.\n");                           break;
        case 0x0004: rprintf("General / Unknown error -- card broken?.\n");                         break;
        case 0x0008: rprintf("Internal card controller error.\n");                                  break;
        case 0x0010: rprintf("Card internal ECC was applied, but failed to correct the data.\n");   break;
        case 0x0020: rprintf("Write protect violation.\n");                                         break;
        case 0x0040: rprintf("An invalid selection, sectors for erase.\n");                         break;
        case 0x0080: rprintf("Out of Range, CSD_Overwrite.\n");                                     break;
            default:
            if (value > 0x00FF)
            {
                Resp8bError((U8) (value >> 8));
            }
            else
            {
                rprintf("Unknown error: 0x%x (see SanDisk docs p5-14).\n", value);
            }
            break;
    }
    return -1;
}

/*****************************************************************************/


int BlockDevInit(void)
{
    int i;
    U8 resp;

    SPIInit();              /* init at low speed */

    /* Try to send reset command up to 100 times */
    i = 100;
    do
    {
        Command(CMD_GOIDLESTATE, 0);
        resp = Resp8b();
    }
    while (resp != 1 && i--);

    if (resp != 1)
    {
        if (resp == 0xff)
        {
            rprintf("resp=0xff\n");
            return -1;
        }
        else
        {
            Resp8bError(resp);
            rprintf("resp!=0xff\n");
            return -2;
        }
    }

    /* Wait till card is ready initialising (returns 0 on CMD_1) */
    /* Try up to 32000 times. */
    i = 32000;
    do
    {
        Command(CMD_SENDOPCOND, 0);

        resp = Resp8b();
        if (resp != 0)
        {
            Resp8bError(resp);
        }
    }
    while (resp == 1 && i--);

    if (resp != 0)
    {
        Resp8bError(resp);
        return -3;
    }

    /* increase speed after init */
    SPISetSpeed(SPI_PRESCALE_MIN);

    if (State() < 0)
    {
        rprintf("Card didn't return the ready state, breaking up...\n");
        return -2;
    }

    rprintf("SD Init done...\n");

    return 0;
}

/*****************************************************************************/



/*****************************************************************************/


/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_WRITE
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK OUT
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 * BUSY...
 */

int BlockDevWrite(U32 dwAddress, U8 * pbBuf)
{
    U32 place;
    U16 t = 0;

    place = 512 * dwAddress;
    Command(CMD_WRITE, place);
   15cd0:	e1a00480 	mov	r0, r0, lsl #9
   15cd4:	e92d4010 	stmdb	sp!, {r4, lr}
   15cd8:	e1a04001 	mov	r4, r1
   15cdc:	e1a01000 	mov	r1, r0
   15ce0:	e3a00018 	mov	r0, #24	; 0x18
   15ce4:	ebffffe2 	bl	15c74 <Command>

    Resp8b();               /* Card response */
   15ce8:	ebffffd5 	bl	15c44 <Resp8b>

    SPISend(0xfe);          /* Start block */
   15cec:	e3a000fe 	mov	r0, #254	; 0xfe
   15cf0:	eb00011e 	bl	16170 <SPISend>
    SPISendN(pbBuf, 512);
   15cf4:	e3a01c02 	mov	r1, #512	; 0x200
   15cf8:	e1a00004 	mov	r0, r4
   15cfc:	eb00012f 	bl	161c0 <SPISendN>
    SPISend(0xff);          /* Checksum part 1 */
   15d00:	e3a000ff 	mov	r0, #255	; 0xff
   15d04:	eb000119 	bl	16170 <SPISend>
    SPISend(0xff);          /* Checksum part 2 */
   15d08:	e3a000ff 	mov	r0, #255	; 0xff
   15d0c:	eb000117 	bl	16170 <SPISend>

    SPISend(0xff);
   15d10:	e3a000ff 	mov	r0, #255	; 0xff
   15d14:	eb000115 	bl	16170 <SPISend>

    while (SPISend(0xff) != 0xff)
   15d18:	e3a000ff 	mov	r0, #255	; 0xff
   15d1c:	eb000113 	bl	16170 <SPISend>
   15d20:	e35000ff 	cmp	r0, #255	; 0xff
   15d24:	1afffffb 	bne	15d18 <BlockDevWrite+0x48>
    {
        t++;
    }

    return 0;
}
   15d28:	e3a00000 	mov	r0, #0	; 0x0
   15d2c:	e8bd4010 	ldmia	sp!, {r4, lr}
   15d30:	e12fff1e 	bx	lr

00015d34 <BlockDevGetSize>:
   15d34:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   15d38:	e3a01000 	mov	r1, #0	; 0x0
   15d3c:	e1a05000 	mov	r5, r0
   15d40:	e24dd010 	sub	sp, sp, #16	; 0x10
   15d44:	e3a00009 	mov	r0, #9	; 0x9
   15d48:	ebffffc9 	bl	15c74 <Command>
   15d4c:	ebffffbc 	bl	15c44 <Resp8b>
   15d50:	e35000fe 	cmp	r0, #254	; 0xfe
   15d54:	1afffffc 	bne	15d4c <BlockDevGetSize+0x18>
   15d58:	e59f00bc 	ldr	r0, [pc, #188]	; 15e1c <.text+0x5e1c>
   15d5c:	ebfff0f6 	bl	1213c <rprintf>
   15d60:	e3a04000 	mov	r4, #0	; 0x0
   15d64:	e3a000ff 	mov	r0, #255	; 0xff
   15d68:	eb000100 	bl	16170 <SPISend>
   15d6c:	e1a0300d 	mov	r3, sp
   15d70:	e7c40003 	strb	r0, [r4, r3]
   15d74:	e1a01000 	mov	r1, r0
   15d78:	e2844001 	add	r4, r4, #1	; 0x1
   15d7c:	e59f009c 	ldr	r0, [pc, #156]	; 15e20 <.text+0x5e20>
   15d80:	ebfff0ed 	bl	1213c <rprintf>
   15d84:	e3540010 	cmp	r4, #16	; 0x10
   15d88:	1afffff5 	bne	15d64 <BlockDevGetSize+0x30>
   15d8c:	e59f0090 	ldr	r0, [pc, #144]	; 15e24 <.text+0x5e24>
   15d90:	ebfff0e9 	bl	1213c <rprintf>
   15d94:	e3a000ff 	mov	r0, #255	; 0xff
   15d98:	eb0000f4 	bl	16170 <SPISend>
   15d9c:	e3a000ff 	mov	r0, #255	; 0xff
   15da0:	eb0000f2 	bl	16170 <SPISend>
   15da4:	e5dd1005 	ldrb	r1, [sp, #5]
   15da8:	e3a00001 	mov	r0, #1	; 0x1
   15dac:	e201100f 	and	r1, r1, #15	; 0xf
   15db0:	e1a01110 	mov	r1, r0, lsl r1
   15db4:	e5dd2009 	ldrb	r2, [sp, #9]
   15db8:	e5dd300a 	ldrb	r3, [sp, #10]
   15dbc:	e2022003 	and	r2, r2, #3	; 0x3
   15dc0:	e1a033a3 	mov	r3, r3, lsr #7
   15dc4:	e0833082 	add	r3, r3, r2, lsl #1
   15dc8:	e2833002 	add	r3, r3, #2	; 0x2
   15dcc:	e1a00310 	mov	r0, r0, lsl r3
   15dd0:	e5dd3007 	ldrb	r3, [sp, #7]
   15dd4:	e5dd2006 	ldrb	r2, [sp, #6]
   15dd8:	e5ddc008 	ldrb	ip, [sp, #8]
   15ddc:	e1a03103 	mov	r3, r3, lsl #2
   15de0:	e083332c 	add	r3, r3, ip, lsr #6
   15de4:	e2022003 	and	r2, r2, #3	; 0x3
   15de8:	e0833502 	add	r3, r3, r2, lsl #10
   15dec:	e1a01801 	mov	r1, r1, lsl #16
   15df0:	e1a01821 	mov	r1, r1, lsr #16
   15df4:	e2833001 	add	r3, r3, #1	; 0x1
   15df8:	e0030391 	mul	r3, r1, r3
   15dfc:	e1a00800 	mov	r0, r0, lsl #16
   15e00:	e1a00820 	mov	r0, r0, lsr #16
   15e04:	e0030390 	mul	r3, r0, r3
   15e08:	e3a00000 	mov	r0, #0	; 0x0
   15e0c:	e5853000 	str	r3, [r5]
   15e10:	e28dd010 	add	sp, sp, #16	; 0x10
   15e14:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   15e18:	e12fff1e 	bx	lr
   15e1c:	000183d8 	ldreqd	r8, [r1], -r8
   15e20:	000183e0 	andeq	r8, r1, r0, ror #7
   15e24:	000184b8 	streqh	r8, [r1], -r8

00015e28 <Resp8bError>:
   15e28:	e20010ff 	and	r1, r0, #255	; 0xff
   15e2c:	e3510008 	cmp	r1, #8	; 0x8
   15e30:	e52de004 	str	lr, [sp, #-4]!
   15e34:	0a000015 	beq	15e90 <Resp8bError+0x68>
   15e38:	8a000006 	bhi	15e58 <Resp8bError+0x30>
   15e3c:	e3510002 	cmp	r1, #2	; 0x2
   15e40:	0a000016 	beq	15ea0 <Resp8bError+0x78>
   15e44:	e3510004 	cmp	r1, #4	; 0x4
   15e48:	0a000012 	beq	15e98 <Resp8bError+0x70>
   15e4c:	e3510001 	cmp	r1, #1	; 0x1
   15e50:	1a000016 	bne	15eb0 <Resp8bError+0x88>
   15e54:	ea000013 	b	15ea8 <Resp8bError+0x80>
   15e58:	e3510020 	cmp	r1, #32	; 0x20
   15e5c:	0a000006 	beq	15e7c <Resp8bError+0x54>
   15e60:	e3510040 	cmp	r1, #64	; 0x40
   15e64:	0a000002 	beq	15e74 <Resp8bError+0x4c>
   15e68:	e3510010 	cmp	r1, #16	; 0x10
   15e6c:	1a00000f 	bne	15eb0 <Resp8bError+0x88>
   15e70:	ea000004 	b	15e88 <Resp8bError+0x60>
   15e74:	e59f0044 	ldr	r0, [pc, #68]	; 15ec0 <.text+0x5ec0>
   15e78:	ea000000 	b	15e80 <Resp8bError+0x58>
   15e7c:	e59f0040 	ldr	r0, [pc, #64]	; 15ec4 <.text+0x5ec4>
   15e80:	ebfff0ad 	bl	1213c <rprintf>
   15e84:	ea00000b 	b	15eb8 <Resp8bError+0x90>
   15e88:	e59f0038 	ldr	r0, [pc, #56]	; 15ec8 <.text+0x5ec8>
   15e8c:	eafffffb 	b	15e80 <Resp8bError+0x58>
   15e90:	e59f0034 	ldr	r0, [pc, #52]	; 15ecc <.text+0x5ecc>
   15e94:	eafffff9 	b	15e80 <Resp8bError+0x58>
   15e98:	e59f0030 	ldr	r0, [pc, #48]	; 15ed0 <.text+0x5ed0>
   15e9c:	eafffff7 	b	15e80 <Resp8bError+0x58>
   15ea0:	e59f002c 	ldr	r0, [pc, #44]	; 15ed4 <.text+0x5ed4>
   15ea4:	eafffff5 	b	15e80 <Resp8bError+0x58>
   15ea8:	e59f0028 	ldr	r0, [pc, #40]	; 15ed8 <.text+0x5ed8>
   15eac:	eafffff3 	b	15e80 <Resp8bError+0x58>
   15eb0:	e59f0024 	ldr	r0, [pc, #36]	; 15edc <.text+0x5edc>
   15eb4:	ebfff0a0 	bl	1213c <rprintf>
   15eb8:	e49de004 	ldr	lr, [sp], #4
   15ebc:	e12fff1e 	bx	lr
   15ec0:	000183e8 	andeq	r8, r1, r8, ror #7
   15ec4:	00018404 	andeq	r8, r1, r4, lsl #8
   15ec8:	0001841c 	andeq	r8, r1, ip, lsl r4
   15ecc:	0001843c 	andeq	r8, r1, ip, lsr r4
   15ed0:	0001844c 	andeq	r8, r1, ip, asr #8
   15ed4:	00018460 	andeq	r8, r1, r0, ror #8
   15ed8:	00018488 	andeq	r8, r1, r8, lsl #9
   15edc:	0001848c 	andeq	r8, r1, ip, lsl #9

00015ee0 <BlockDevRead>:

/*****************************************************************************/

/* ****************************************************************************
 * WAIT ?? -- FIXME
 * CMD_CMD_
 * WAIT
 * CARD RESP
 * WAIT
 * DATA BLOCK IN
 *      START BLOCK
 *      DATA
 *      CHKS (2B)
 */

int BlockDevRead(U32 dwAddress, U8 * pbBuf)
{
    U8 cardresp;
    U8 firstblock;
    U16 fb_timeout = 0xffff;
    U32 place;

    place = 512 * dwAddress;
    Command(CMD_READSINGLEBLOCK, place);
   15ee0:	e1a00480 	mov	r0, r0, lsl #9
   15ee4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   15ee8:	e1a06001 	mov	r6, r1
   15eec:	e1a01000 	mov	r1, r0
   15ef0:	e3a00011 	mov	r0, #17	; 0x11
   15ef4:	ebffff5e 	bl	15c74 <Command>

    cardresp = Resp8b();        /* Card response */
   15ef8:	ebffff51 	bl	15c44 <Resp8b>
   15efc:	e59f506c 	ldr	r5, [pc, #108]	; 15f70 <.text+0x5f70>
   15f00:	e1a04000 	mov	r4, r0

    /* Wait for startblock */
    do
    {
        firstblock = Resp8b();
   15f04:	ebffff4e 	bl	15c44 <Resp8b>
    }
    while (firstblock == 0xff && fb_timeout--);
   15f08:	e2453001 	sub	r3, r5, #1	; 0x1
   15f0c:	e35000ff 	cmp	r0, #255	; 0xff
   15f10:	e1a03803 	mov	r3, r3, lsl #16
   15f14:	1a000003 	bne	15f28 <BlockDevRead+0x48>
   15f18:	e3730801 	cmn	r3, #65536	; 0x10000
   15f1c:	e1a05823 	mov	r5, r3, lsr #16
   15f20:	0a000005 	beq	15f3c <BlockDevRead+0x5c>
   15f24:	eafffff6 	b	15f04 <BlockDevRead+0x24>

    if (cardresp != 0x00 || firstblock != 0xfe)
   15f28:	e35000fe 	cmp	r0, #254	; 0xfe
   15f2c:	03540000 	cmpeq	r4, #0	; 0x0
   15f30:	03a04000 	moveq	r4, #0	; 0x0
   15f34:	13a04001 	movne	r4, #1	; 0x1
   15f38:	0a000002 	beq	15f48 <BlockDevRead+0x68>
    {
        Resp8bError(firstblock);
   15f3c:	ebffffb9 	bl	15e28 <Resp8bError>
   15f40:	e3e00000 	mvn	r0, #0	; 0x0
   15f44:	ea000007 	b	15f68 <BlockDevRead+0x88>
        return -1;
    }

    SPIRecvN(pbBuf, 512);
   15f48:	e3a01c02 	mov	r1, #512	; 0x200
   15f4c:	e1a00006 	mov	r0, r6
   15f50:	eb0000b1 	bl	1621c <SPIRecvN>

    /* Checksum (2 byte) - ignore for now */
    SPISend(0xff);
   15f54:	e3a000ff 	mov	r0, #255	; 0xff
   15f58:	eb000084 	bl	16170 <SPISend>
    SPISend(0xff);
   15f5c:	e3a000ff 	mov	r0, #255	; 0xff
   15f60:	eb000082 	bl	16170 <SPISend>
   15f64:	e1a00004 	mov	r0, r4

    return 0;
}
   15f68:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   15f6c:	e12fff1e 	bx	lr
   15f70:	0000ffff 	streqd	pc, [r0], -pc

00015f74 <BlockDevInit>:
   15f74:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   15f78:	eb0000c0 	bl	16280 <SPIInit>
   15f7c:	e3a04064 	mov	r4, #100	; 0x64
   15f80:	e3a00000 	mov	r0, #0	; 0x0
   15f84:	e1a01000 	mov	r1, r0
   15f88:	ebffff39 	bl	15c74 <Command>
   15f8c:	ebffff2c 	bl	15c44 <Resp8b>
   15f90:	e3500001 	cmp	r0, #1	; 0x1
   15f94:	e2444001 	sub	r4, r4, #1	; 0x1
   15f98:	0a00000a 	beq	15fc8 <BlockDevInit+0x54>
   15f9c:	e3740001 	cmn	r4, #1	; 0x1
   15fa0:	1afffff6 	bne	15f80 <BlockDevInit+0xc>
   15fa4:	e35000ff 	cmp	r0, #255	; 0xff
   15fa8:	1a000003 	bne	15fbc <BlockDevInit+0x48>
   15fac:	e59f016c 	ldr	r0, [pc, #364]	; 16120 <.text+0x6120>
   15fb0:	ebfff061 	bl	1213c <rprintf>
   15fb4:	e1a00004 	mov	r0, r4
   15fb8:	ea000056 	b	16118 <BlockDevInit+0x1a4>
   15fbc:	ebffff99 	bl	15e28 <Resp8bError>
   15fc0:	e59f015c 	ldr	r0, [pc, #348]	; 16124 <.text+0x6124>
   15fc4:	ea000051 	b	16110 <BlockDevInit+0x19c>
   15fc8:	e3a04c7d 	mov	r4, #32000	; 0x7d00
   15fcc:	e3a01000 	mov	r1, #0	; 0x0
   15fd0:	e3a00001 	mov	r0, #1	; 0x1
   15fd4:	ebffff26 	bl	15c74 <Command>
   15fd8:	ebffff19 	bl	15c44 <Resp8b>
   15fdc:	e2505000 	subs	r5, r0, #0	; 0x0
   15fe0:	e2444001 	sub	r4, r4, #1	; 0x1
   15fe4:	0a000008 	beq	1600c <BlockDevInit+0x98>
   15fe8:	ebffff8e 	bl	15e28 <Resp8bError>
   15fec:	e3550001 	cmp	r5, #1	; 0x1
   15ff0:	1a000001 	bne	15ffc <BlockDevInit+0x88>
   15ff4:	e3740001 	cmn	r4, #1	; 0x1
   15ff8:	1afffff3 	bne	15fcc <BlockDevInit+0x58>
   15ffc:	e1a00005 	mov	r0, r5
   16000:	ebffff88 	bl	15e28 <Resp8bError>
   16004:	e3e00002 	mvn	r0, #2	; 0x2
   16008:	ea000042 	b	16118 <BlockDevInit+0x1a4>
   1600c:	e3a00008 	mov	r0, #8	; 0x8
   16010:	eb00004f 	bl	16154 <SPISetSpeed>
   16014:	e1a01005 	mov	r1, r5
   16018:	e3a0000d 	mov	r0, #13	; 0xd
   1601c:	ebffff14 	bl	15c74 <Command>
   16020:	ebffff07 	bl	15c44 <Resp8b>
   16024:	e1a04c00 	mov	r4, r0, lsl #24
   16028:	e3a000ff 	mov	r0, #255	; 0xff
   1602c:	eb00004f 	bl	16170 <SPISend>
   16030:	e1a04824 	mov	r4, r4, lsr #16
   16034:	e1844000 	orr	r4, r4, r0
   16038:	e1a04804 	mov	r4, r4, lsl #16
   1603c:	e1a01824 	mov	r1, r4, lsr #16
   16040:	e3510008 	cmp	r1, #8	; 0x8
   16044:	0a00001a 	beq	160b4 <BlockDevInit+0x140>
   16048:	8a000007 	bhi	1606c <BlockDevInit+0xf8>
   1604c:	e3510001 	cmp	r1, #1	; 0x1
   16050:	0a000010 	beq	16098 <BlockDevInit+0x124>
   16054:	3a000028 	bcc	160fc <BlockDevInit+0x188>
   16058:	e3510002 	cmp	r1, #2	; 0x2
   1605c:	0a00000f 	beq	160a0 <BlockDevInit+0x12c>
   16060:	e3510004 	cmp	r1, #4	; 0x4
   16064:	1a00001c 	bne	160dc <BlockDevInit+0x168>
   16068:	ea00000f 	b	160ac <BlockDevInit+0x138>
   1606c:	e3510020 	cmp	r1, #32	; 0x20
   16070:	0a000013 	beq	160c4 <BlockDevInit+0x150>
   16074:	8a000002 	bhi	16084 <BlockDevInit+0x110>
   16078:	e3510010 	cmp	r1, #16	; 0x10
   1607c:	1a000016 	bne	160dc <BlockDevInit+0x168>
   16080:	ea00000d 	b	160bc <BlockDevInit+0x148>
   16084:	e3510040 	cmp	r1, #64	; 0x40
   16088:	0a00000f 	beq	160cc <BlockDevInit+0x158>
   1608c:	e3510080 	cmp	r1, #128	; 0x80
   16090:	1a000011 	bne	160dc <BlockDevInit+0x168>
   16094:	ea00000e 	b	160d4 <BlockDevInit+0x160>
   16098:	e59f0088 	ldr	r0, [pc, #136]	; 16128 <.text+0x6128>
   1609c:	ea000000 	b	160a4 <BlockDevInit+0x130>
   160a0:	e59f0084 	ldr	r0, [pc, #132]	; 1612c <.text+0x612c>
   160a4:	ebfff024 	bl	1213c <rprintf>
   160a8:	ea000017 	b	1610c <BlockDevInit+0x198>
   160ac:	e59f007c 	ldr	r0, [pc, #124]	; 16130 <.text+0x6130>
   160b0:	eafffffb 	b	160a4 <BlockDevInit+0x130>
   160b4:	e59f0078 	ldr	r0, [pc, #120]	; 16134 <.text+0x6134>
   160b8:	eafffff9 	b	160a4 <BlockDevInit+0x130>
   160bc:	e59f0074 	ldr	r0, [pc, #116]	; 16138 <.text+0x6138>
   160c0:	eafffff7 	b	160a4 <BlockDevInit+0x130>
   160c4:	e59f0070 	ldr	r0, [pc, #112]	; 1613c <.text+0x613c>
   160c8:	eafffff5 	b	160a4 <BlockDevInit+0x130>
   160cc:	e59f006c 	ldr	r0, [pc, #108]	; 16140 <.text+0x6140>
   160d0:	eafffff3 	b	160a4 <BlockDevInit+0x130>
   160d4:	e59f0068 	ldr	r0, [pc, #104]	; 16144 <.text+0x6144>
   160d8:	eafffff1 	b	160a4 <BlockDevInit+0x130>
   160dc:	e35100ff 	cmp	r1, #255	; 0xff
   160e0:	9a000002 	bls	160f0 <BlockDevInit+0x17c>
   160e4:	e1a00421 	mov	r0, r1, lsr #8
   160e8:	ebffff4e 	bl	15e28 <Resp8bError>
   160ec:	ea000006 	b	1610c <BlockDevInit+0x198>
   160f0:	e59f0050 	ldr	r0, [pc, #80]	; 16148 <.text+0x6148>
   160f4:	ebfff010 	bl	1213c <rprintf>
   160f8:	ea000003 	b	1610c <BlockDevInit+0x198>
   160fc:	e59f0048 	ldr	r0, [pc, #72]	; 1614c <.text+0x614c>
   16100:	ebfff00d 	bl	1213c <rprintf>
   16104:	e1a00005 	mov	r0, r5
   16108:	ea000002 	b	16118 <BlockDevInit+0x1a4>
   1610c:	e59f003c 	ldr	r0, [pc, #60]	; 16150 <.text+0x6150>
   16110:	ebfff009 	bl	1213c <rprintf>
   16114:	e3e00001 	mvn	r0, #1	; 0x1
   16118:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   1611c:	e12fff1e 	bx	lr
   16120:	000184bc 	streqh	r8, [r1], -ip
   16124:	000184c8 	andeq	r8, r1, r8, asr #9
   16128:	000184d4 	ldreqd	r8, [r1], -r4
   1612c:	000184e8 	andeq	r8, r1, r8, ror #9
   16130:	00018510 	andeq	r8, r1, r0, lsl r5
   16134:	0001853c 	andeq	r8, r1, ip, lsr r5
   16138:	00018560 	andeq	r8, r1, r0, ror #10
   1613c:	000185a0 	andeq	r8, r1, r0, lsr #11
   16140:	000185bc 	streqh	r8, [r1], -ip
   16144:	000185e8 	andeq	r8, r1, r8, ror #11
   16148:	00018608 	andeq	r8, r1, r8, lsl #12
   1614c:	00018638 	andeq	r8, r1, r8, lsr r6
   16150:	0001864c 	andeq	r8, r1, ip, asr #12

00016154 <SPISetSpeed>:
/*****************************************************************************/

void SPISetSpeed(U8 speed)
{
    speed &= 0xFE;
   16154:	e20000fe 	and	r0, r0, #254	; 0xfe
    if (speed < SPI_PRESCALE_MIN)
   16158:	e3500007 	cmp	r0, #7	; 0x7
    {
        speed = SPI_PRESCALE_MIN;
    }
    SPI_PRESCALE_REG = speed;
   1615c:	e59f3008 	ldr	r3, [pc, #8]	; 1616c <.text+0x616c>
   16160:	93a00008 	movls	r0, #8	; 0x8
   16164:	e583000c 	str	r0, [r3, #12]
}
   16168:	e12fff1e 	bx	lr
   1616c:	e0020000 	and	r0, r2, r0

00016170 <SPISend>:


void SPIInit(void)
{
    U8 i;
    //U32 j;

    rprintf("spiInit for SPI(0)\n");

    // setup GPIO
    PINSEL2 = 0;

	SPI_IODIR |= (1 << SPI_SCK_PIN) | (1 << SPI_MOSI_PIN);
    SPI_SS_IODIR |= (1 << SPI_SS_PIN);
    SPI_IODIR &= ~(1 << SPI_MISO_PIN);

    // reset Pin-Functions
    SPI_PINSEL &= ~((3 << SPI_SCK_FUNCBIT) | (3 << SPI_MISO_FUNCBIT) | (3 << SPI_MOSI_FUNCBIT));
    SPI_PINSEL |= ((1 << SPI_SCK_FUNCBIT) | (1 << SPI_MISO_FUNCBIT) | (1 << SPI_MOSI_FUNCBIT));

    // set Chip-Select high - unselect card
    UNSELECT_CARD();

    // enable SPI-Master
    S0SPCR = (1 << MSTR) | (0 << CPOL);   // TODO: check CPOL

    // low speed during init
    SPISetSpeed(254);

    /* Send 20 spi commands with card not selected */
    for (i = 0; i < 21; i++)
    {
        my_SPISend(0xff);
    }
}

/*****************************************************************************/

/*****************************************************************************/

U8 SPISend(U8 outgoing)
{
    U8 incoming;

    SELECT_CARD();
   16170:	e59f2040 	ldr	r2, [pc, #64]	; 161b8 <.text+0x61b8>
   16174:	e592300c 	ldr	r3, [r2, #12]
   16178:	e3833080 	orr	r3, r3, #128	; 0x80
   1617c:	e582300c 	str	r3, [r2, #12]
    S0SPDR = outgoing;
   16180:	e59f3034 	ldr	r3, [pc, #52]	; 161bc <.text+0x61bc>
   16184:	e20000ff 	and	r0, r0, #255	; 0xff
   16188:	e5830008 	str	r0, [r3, #8]
    while (!(S0SPSR & (1 << SPIF)));
   1618c:	e59f1028 	ldr	r1, [pc, #40]	; 161bc <.text+0x61bc>
   16190:	e5913004 	ldr	r3, [r1, #4]
   16194:	e3130080 	tst	r3, #128	; 0x80
   16198:	0afffffb 	beq	1618c <SPISend+0x1c>
    incoming = S0SPDR;
    UNSELECT_CARD();
   1619c:	e59f2014 	ldr	r2, [pc, #20]	; 161b8 <.text+0x61b8>
   161a0:	e5910008 	ldr	r0, [r1, #8]
   161a4:	e5923004 	ldr	r3, [r2, #4]
   161a8:	e20000ff 	and	r0, r0, #255	; 0xff
   161ac:	e3833080 	orr	r3, r3, #128	; 0x80
   161b0:	e5823004 	str	r3, [r2, #4]

    return incoming;
}
   161b4:	e12fff1e 	bx	lr
   161b8:	e0028000 	and	r8, r2, r0
   161bc:	e0020000 	and	r0, r2, r0

000161c0 <SPISendN>:

void SPISendN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
   161c0:	e59f204c 	ldr	r2, [pc, #76]	; 16214 <.text+0x6214>
   161c4:	e592300c 	ldr	r3, [r2, #12]
   161c8:	e3a0c000 	mov	ip, #0	; 0x0
   161cc:	e3833080 	orr	r3, r3, #128	; 0x80
   161d0:	e582300c 	str	r3, [r2, #12]
   161d4:	ea000007 	b	161f8 <SPISendN+0x38>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = pbBuf[i];
   161d8:	e7dc2000 	ldrb	r2, [ip, r0]
   161dc:	e59f3034 	ldr	r3, [pc, #52]	; 16218 <.text+0x6218>
   161e0:	e5832008 	str	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
   161e4:	e59f302c 	ldr	r3, [pc, #44]	; 16218 <.text+0x6218>
   161e8:	e5933004 	ldr	r3, [r3, #4]
   161ec:	e3130080 	tst	r3, #128	; 0x80
   161f0:	0afffffb 	beq	161e4 <SPISendN+0x24>
   161f4:	e28cc001 	add	ip, ip, #1	; 0x1
   161f8:	e15c0001 	cmp	ip, r1
   161fc:	bafffff5 	blt	161d8 <SPISendN+0x18>
    }
    UNSELECT_CARD();
   16200:	e59f200c 	ldr	r2, [pc, #12]	; 16214 <.text+0x6214>
   16204:	e5923004 	ldr	r3, [r2, #4]
   16208:	e3833080 	orr	r3, r3, #128	; 0x80
   1620c:	e5823004 	str	r3, [r2, #4]
}
   16210:	e12fff1e 	bx	lr
   16214:	e0028000 	and	r8, r2, r0
   16218:	e0020000 	and	r0, r2, r0

0001621c <SPIRecvN>:

void SPIRecvN(U8 * pbBuf, int iLen)
{
    int i;

    SELECT_CARD();
   1621c:	e59f2054 	ldr	r2, [pc, #84]	; 16278 <.text+0x6278>
   16220:	e592300c 	ldr	r3, [r2, #12]
   16224:	e3a0c000 	mov	ip, #0	; 0x0
   16228:	e3833080 	orr	r3, r3, #128	; 0x80
   1622c:	e582300c 	str	r3, [r2, #12]
   16230:	ea000009 	b	1625c <SPIRecvN+0x40>
    for (i = 0; i < iLen; i++)
    {
        S0SPDR = 0xFF;
   16234:	e59f3040 	ldr	r3, [pc, #64]	; 1627c <.text+0x627c>
   16238:	e3a020ff 	mov	r2, #255	; 0xff
   1623c:	e5832008 	str	r2, [r3, #8]
        while (!(S0SPSR & (1 << SPIF)));
   16240:	e59f2034 	ldr	r2, [pc, #52]	; 1627c <.text+0x627c>
   16244:	e5923004 	ldr	r3, [r2, #4]
   16248:	e3130080 	tst	r3, #128	; 0x80
   1624c:	0afffffb 	beq	16240 <SPIRecvN+0x24>
        pbBuf[i] = S0SPDR;
   16250:	e5923008 	ldr	r3, [r2, #8]
   16254:	e7cc3000 	strb	r3, [ip, r0]
   16258:	e28cc001 	add	ip, ip, #1	; 0x1
   1625c:	e15c0001 	cmp	ip, r1
   16260:	bafffff3 	blt	16234 <SPIRecvN+0x18>
    }
    UNSELECT_CARD();
   16264:	e59f200c 	ldr	r2, [pc, #12]	; 16278 <.text+0x6278>
   16268:	e5923004 	ldr	r3, [r2, #4]
   1626c:	e3833080 	orr	r3, r3, #128	; 0x80
   16270:	e5823004 	str	r3, [r2, #4]
}
   16274:	e12fff1e 	bx	lr
   16278:	e0028000 	and	r8, r2, r0
   1627c:	e0020000 	and	r0, r2, r0

00016280 <SPIInit>:
   16280:	e59f00a8 	ldr	r0, [pc, #168]	; 16330 <.text+0x6330>
   16284:	e52de004 	str	lr, [sp, #-4]!
   16288:	ebffefab 	bl	1213c <rprintf>
   1628c:	e59f10a0 	ldr	r1, [pc, #160]	; 16334 <.text+0x6334>
   16290:	e3a00000 	mov	r0, #0	; 0x0
   16294:	e5810014 	str	r0, [r1, #20]
   16298:	e59f2098 	ldr	r2, [pc, #152]	; 16338 <.text+0x6338>
   1629c:	e5923008 	ldr	r3, [r2, #8]
   162a0:	e3833050 	orr	r3, r3, #80	; 0x50
   162a4:	e5823008 	str	r3, [r2, #8]
   162a8:	e5923008 	ldr	r3, [r2, #8]
   162ac:	e3833080 	orr	r3, r3, #128	; 0x80
   162b0:	e5823008 	str	r3, [r2, #8]
   162b4:	e5923008 	ldr	r3, [r2, #8]
   162b8:	e3c33020 	bic	r3, r3, #32	; 0x20
   162bc:	e5823008 	str	r3, [r2, #8]
   162c0:	e5913000 	ldr	r3, [r1]
   162c4:	e3c33c3f 	bic	r3, r3, #16128	; 0x3f00
   162c8:	e5813000 	str	r3, [r1]
   162cc:	e5913000 	ldr	r3, [r1]
   162d0:	e3833c15 	orr	r3, r3, #5376	; 0x1500
   162d4:	e5813000 	str	r3, [r1]
   162d8:	e5923004 	ldr	r3, [r2, #4]
   162dc:	e3833080 	orr	r3, r3, #128	; 0x80
   162e0:	e5823004 	str	r3, [r2, #4]
   162e4:	e2411903 	sub	r1, r1, #49152	; 0xc000
   162e8:	e3a03020 	mov	r3, #32	; 0x20
   162ec:	e5813000 	str	r3, [r1]
   162f0:	e28330de 	add	r3, r3, #222	; 0xde
   162f4:	e581300c 	str	r3, [r1, #12]
   162f8:	e59f303c 	ldr	r3, [pc, #60]	; 1633c <.text+0x633c>
   162fc:	e3a020ff 	mov	r2, #255	; 0xff
   16300:	e5832008 	str	r2, [r3, #8]
   16304:	e59f2030 	ldr	r2, [pc, #48]	; 1633c <.text+0x633c>
   16308:	e5923004 	ldr	r3, [r2, #4]
   1630c:	e3130080 	tst	r3, #128	; 0x80
   16310:	0afffffb 	beq	16304 <SPIInit+0x84>
   16314:	e2803001 	add	r3, r0, #1	; 0x1
   16318:	e20300ff 	and	r0, r3, #255	; 0xff
   1631c:	e3500015 	cmp	r0, #21	; 0x15
   16320:	e5923008 	ldr	r3, [r2, #8]
   16324:	1afffff3 	bne	162f8 <SPIInit+0x78>
   16328:	e49de004 	ldr	lr, [sp], #4
   1632c:	e12fff1e 	bx	lr
   16330:	00018680 	andeq	r8, r1, r0, lsl #13
   16334:	e002c000 	and	ip, r2, r0
   16338:	e0028000 	and	r8, r2, r0
   1633c:	e0020000 	and	r0, r2, r0

00016340 <HandleUsbReset>:
{
	if (bDevStatus & DEV_STATUS_RESET) {
		DBG("\n!");
	}
}
   16340:	e12fff1e 	bx	lr

00016344 <USBInit>:


/**
	Initialises the USB hardware and sets up the USB stack by
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
   16344:	e92d4010 	stmdb	sp!, {r4, lr}
	// init hardware
	USBHwInit();
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
   16348:	e59f4054 	ldr	r4, [pc, #84]	; 163a4 <.text+0x63a4>
   1634c:	eb00013d 	bl	16848 <USBHwInit>
   16350:	e59f0050 	ldr	r0, [pc, #80]	; 163a8 <.text+0x63a8>
   16354:	eb000074 	bl	1652c <USBHwRegisterDevIntHandler>
   16358:	e1a01004 	mov	r1, r4
   1635c:	e3a00000 	mov	r0, #0	; 0x0
   16360:	eb00005e 	bl	164e0 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
   16364:	e1a01004 	mov	r1, r4
   16368:	e3a00080 	mov	r0, #128	; 0x80
   1636c:	eb00005b 	bl	164e0 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
   16370:	e3a00000 	mov	r0, #0	; 0x0
   16374:	e3a01040 	mov	r1, #64	; 0x40
   16378:	eb000041 	bl	16484 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
   1637c:	e3a00080 	mov	r0, #128	; 0x80
   16380:	e3a01040 	mov	r1, #64	; 0x40
   16384:	eb00003e 	bl	16484 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
   16388:	e3a00000 	mov	r0, #0	; 0x0
   1638c:	e59f1018 	ldr	r1, [pc, #24]	; 163ac <.text+0x63ac>
   16390:	e59f2018 	ldr	r2, [pc, #24]	; 163b0 <.text+0x63b0>
   16394:	eb00016c 	bl	1694c <USBRegisterRequestHandler>

	return TRUE;
}
   16398:	e3a00001 	mov	r0, #1	; 0x1
   1639c:	e8bd4010 	ldmia	sp!, {r4, lr}
   163a0:	e12fff1e 	bx	lr
   163a4:	000169d0 	ldreqd	r6, [r1], -r0
   163a8:	00016340 	andeq	r6, r1, r0, asr #6
   163ac:	00016bc0 	andeq	r6, r1, r0, asr #23
   163b0:	40000d0c 	andmi	r0, r0, ip, lsl #26

000163b4 <USBHwCmd>:
		
	@param [in]	bCmd		Command to send
 */
static void USBHwCmd(U8 bCmd)
{
   163b4:	e1a00800 	mov	r0, r0, lsl #16
	// clear CDFULL/CCEMTY
	USBDevIntClr = CDFULL | CCEMTY;
   163b8:	e59f202c 	ldr	r2, [pc, #44]	; 163ec <.text+0x63ec>
	// write command code
	USBCmdCode = 0x00000500 | (bCmd << 16);
   163bc:	e20008ff 	and	r0, r0, #16711680	; 0xff0000
   163c0:	e3800c05 	orr	r0, r0, #1280	; 0x500
   163c4:	e3a03030 	mov	r3, #48	; 0x30
   163c8:	e5823008 	str	r3, [r2, #8]
   163cc:	e5820010 	str	r0, [r2, #16]
   163d0:	e59f2014 	ldr	r2, [pc, #20]	; 163ec <.text+0x63ec>
   163d4:	e5923000 	ldr	r3, [r2]
   163d8:	e2033010 	and	r3, r3, #16	; 0x10
   163dc:	e3530010 	cmp	r3, #16	; 0x10
   163e0:	1afffffa 	bne	163d0 <USBHwCmd+0x1c>
   163e4:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
   163e8:	e12fff1e 	bx	lr
   163ec:	e0090000 	and	r0, r9, r0

000163f0 <USBHwCmdWrite>:


/**
	Local function to send a command + data to the USB protocol engine
		
	@param [in]	bCmd		Command to send
	@param [in]	bData		Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
   163f0:	e92d4010 	stmdb	sp!, {r4, lr}
   163f4:	e1a04801 	mov	r4, r1, lsl #16
   163f8:	e20000ff 	and	r0, r0, #255	; 0xff
   163fc:	e1a04824 	mov	r4, r4, lsr #16
	// write command code
	USBHwCmd(bCmd);
   16400:	ebffffeb 	bl	163b4 <USBHwCmd>

	// write command data
	USBCmdCode = 0x00000100 | (bData << 16);
   16404:	e1a04804 	mov	r4, r4, lsl #16
   16408:	e59f3024 	ldr	r3, [pc, #36]	; 16434 <.text+0x6434>
   1640c:	e3844c01 	orr	r4, r4, #256	; 0x100
   16410:	e5834010 	str	r4, [r3, #16]
   16414:	e59f2018 	ldr	r2, [pc, #24]	; 16434 <.text+0x6434>
   16418:	e5923000 	ldr	r3, [r2]
   1641c:	e2033010 	and	r3, r3, #16	; 0x10
   16420:	e3530010 	cmp	r3, #16	; 0x10
   16424:	1afffffa 	bne	16414 <USBHwCmdWrite+0x24>
   16428:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CCEMTY);
}
   1642c:	e8bd4010 	ldmia	sp!, {r4, lr}
   16430:	e12fff1e 	bx	lr
   16434:	e0090000 	and	r0, r9, r0

00016438 <USBHwCmdRead>:


/**
	Local function to send a command to the USB protocol engine and read data
		
	@param [in]	bCmd		Command to send

	@return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
   16438:	e92d4010 	stmdb	sp!, {r4, lr}
   1643c:	e20040ff 	and	r4, r0, #255	; 0xff
	// write command code
	USBHwCmd(bCmd);
   16440:	e1a00004 	mov	r0, r4
   16444:	ebffffda 	bl	163b4 <USBHwCmd>
	
	// get data
	USBCmdCode = 0x00000200 | (bCmd << 16);
   16448:	e1a04804 	mov	r4, r4, lsl #16
   1644c:	e59f302c 	ldr	r3, [pc, #44]	; 16480 <.text+0x6480>
   16450:	e3844c02 	orr	r4, r4, #512	; 0x200
   16454:	e5834010 	str	r4, [r3, #16]
   16458:	e59f2020 	ldr	r2, [pc, #32]	; 16480 <.text+0x6480>
   1645c:	e5923000 	ldr	r3, [r2]
   16460:	e2033020 	and	r3, r3, #32	; 0x20
   16464:	e3530020 	cmp	r3, #32	; 0x20
   16468:	1afffffa 	bne	16458 <USBHwCmdRead+0x20>
   1646c:	e5823008 	str	r3, [r2, #8]
	Wait4DevInt(CDFULL);
	return USBCmdData;
   16470:	e5920014 	ldr	r0, [r2, #20]
   16474:	e20000ff 	and	r0, r0, #255	; 0xff
}
   16478:	e8bd4010 	ldmia	sp!, {r4, lr}
   1647c:	e12fff1e 	bx	lr
   16480:	e0090000 	and	r0, r9, r0

00016484 <USBHwEPConfig>:


/**
	'Realizes' an endpoint, meaning that buffer space is reserved for
	it. An endpoint needs to be realised before it can be used.
		
	From experiments, it appears that a USB reset causes USBReEP to
	re-initialise to 3 (= just the control endpoints).
	However, a USB bus reset does not disturb the USBMaxPSize settings.
		
	@param [in]	idx			Endpoint index
	@param [in] wMaxPSize	Maximum packet size for this endpoint
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
	USBReEP |= (1 << idx);
   16484:	e59fc050 	ldr	ip, [pc, #80]	; 164dc <.text+0x64dc>
	USBEpInd = idx;
	USBMaxPSize = wMaxPSize;
	Wait4DevInt(EP_RLZED);
}


/**
	Enables or disables an endpoint
		
	@param [in]	idx		Endpoint index
	@param [in]	fEnable	TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
}


/**
	Configures an endpoint and enables it
		
	@param [in]	bEP				Endpoint number
	@param [in]	wMaxPacketSize	Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
	int idx;
	
	idx = EP2IDX(bEP);
   16488:	e2003080 	and	r3, r0, #128	; 0x80
   1648c:	e59c2044 	ldr	r2, [ip, #68]
   16490:	e1a033c3 	mov	r3, r3, asr #7
   16494:	e200000f 	and	r0, r0, #15	; 0xf
   16498:	e1830080 	orr	r0, r3, r0, lsl #1
   1649c:	e3a03001 	mov	r3, #1	; 0x1
   164a0:	e1822013 	orr	r2, r2, r3, lsl r0
   164a4:	e1a01801 	mov	r1, r1, lsl #16
   164a8:	e1a01821 	mov	r1, r1, lsr #16
   164ac:	e58c2044 	str	r2, [ip, #68]
   164b0:	e58c0048 	str	r0, [ip, #72]
   164b4:	e58c104c 	str	r1, [ip, #76]
   164b8:	e59f201c 	ldr	r2, [pc, #28]	; 164dc <.text+0x64dc>
   164bc:	e5923000 	ldr	r3, [r2]
   164c0:	e2033c01 	and	r3, r3, #256	; 0x100
   164c4:	e3530c01 	cmp	r3, #256	; 0x100
   164c8:	1afffffa 	bne	164b8 <USBHwEPConfig+0x34>
   164cc:	e3800040 	orr	r0, r0, #64	; 0x40
   164d0:	e3a01000 	mov	r1, #0	; 0x0
   164d4:	e5823008 	str	r3, [r2, #8]
   164d8:	eaffffc4 	b	163f0 <USBHwCmdWrite>
   164dc:	e0090000 	and	r0, r9, r0

000164e0 <USBHwRegisterEPIntHandler>:
	
	// realise EP
	USBHwEPRealize(idx, wMaxPacketSize);

	// enable EP
	USBHwEPEnable(idx, TRUE);
}


/**
	Registers an endpoint event callback
		
	@param [in]	bEP				Endpoint number
	@param [in]	pfnHandler		Callback function
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
   164e0:	e52de004 	str	lr, [sp, #-4]!
	int idx;
	
	idx = EP2IDX(bEP);

	ASSERT(idx<32);

	/* add handler to list of EP handlers */
	_apfnEPIntHandlers[idx / 2] = pfnHandler;
	
	/* enable EP interrupt */
	USBEpIntEn |= (1 << idx);
   164e4:	e59fe038 	ldr	lr, [pc, #56]	; 16524 <.text+0x6524>
   164e8:	e2003080 	and	r3, r0, #128	; 0x80
   164ec:	e59ec034 	ldr	ip, [lr, #52]
   164f0:	e200000f 	and	r0, r0, #15	; 0xf
   164f4:	e1a033c3 	mov	r3, r3, asr #7
   164f8:	e1833080 	orr	r3, r3, r0, lsl #1
   164fc:	e3a02001 	mov	r2, #1	; 0x1
   16500:	e18cc312 	orr	ip, ip, r2, lsl r3
   16504:	e58ec034 	str	ip, [lr, #52]
	USBDevIntEn |= EP_SLOW;
   16508:	e59e3004 	ldr	r3, [lr, #4]
   1650c:	e59f2014 	ldr	r2, [pc, #20]	; 16528 <.text+0x6528>
   16510:	e3833004 	orr	r3, r3, #4	; 0x4
   16514:	e7821100 	str	r1, [r2, r0, lsl #2]
   16518:	e58e3004 	str	r3, [lr, #4]
	
	DBG("Registered handler for EP 0x%x\n", bEP);
}
   1651c:	e49de004 	ldr	lr, [sp], #4
   16520:	e12fff1e 	bx	lr
   16524:	e0090000 	and	r0, r9, r0
   16528:	40000d1c 	andmi	r0, r0, ip, lsl sp

0001652c <USBHwRegisterDevIntHandler>:


/**
	Registers an device status callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
	_pfnDevIntHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= DEV_STAT;
   1652c:	e59f3014 	ldr	r3, [pc, #20]	; 16548 <.text+0x6548>
   16530:	e5932004 	ldr	r2, [r3, #4]
   16534:	e59f1010 	ldr	r1, [pc, #16]	; 1654c <.text+0x654c>
   16538:	e3822008 	orr	r2, r2, #8	; 0x8
   1653c:	e5810000 	str	r0, [r1]
   16540:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for device status\n");
}
   16544:	e12fff1e 	bx	lr
   16548:	e0090000 	and	r0, r9, r0
   1654c:	40000d18 	andmi	r0, r0, r8, lsl sp

00016550 <USBHwRegisterFrameHandler>:


/**
	Registers the frame callback
		
	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
	_pfnFrameHandler = pfnHandler;
	
	// enable device interrupt
	USBDevIntEn |= FRAME;
   16550:	e59f3014 	ldr	r3, [pc, #20]	; 1656c <.text+0x656c>
   16554:	e5932004 	ldr	r2, [r3, #4]
   16558:	e59f1010 	ldr	r1, [pc, #16]	; 16570 <.text+0x6570>
   1655c:	e3822001 	orr	r2, r2, #1	; 0x1
   16560:	e5810000 	str	r0, [r1]
   16564:	e5832004 	str	r2, [r3, #4]

	DBG("Registered handler for frame\n");
}
   16568:	e12fff1e 	bx	lr
   1656c:	e0090000 	and	r0, r9, r0
   16570:	40000d14 	andmi	r0, r0, r4, lsl sp

00016574 <USBHwSetAddress>:


/**
	Sets the USB address.
		
	@param [in]	bAddr		Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
   16574:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
   16578:	e3811080 	orr	r1, r1, #128	; 0x80
   1657c:	e3a000d0 	mov	r0, #208	; 0xd0
   16580:	eaffff9a 	b	163f0 <USBHwCmdWrite>

00016584 <USBHwConnect>:
}


/**
	Connects or disconnects from the USB bus
		
	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 */
void USBHwConnect(BOOL fConnect)
{
	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
   16584:	e2501000 	subs	r1, r0, #0	; 0x0
   16588:	13a01001 	movne	r1, #1	; 0x1
   1658c:	e3a000fe 	mov	r0, #254	; 0xfe
   16590:	eaffff96 	b	163f0 <USBHwCmdWrite>

00016594 <USBHwNakIntEnable>:

}


/**
	Enables interrupt on NAK condition
		
	For IN endpoints a NAK is generated when the host wants to read data
	from the device, but none is available in the endpoint buffer.
	For OUT endpoints a NAK is generated when the host wants to write data
	to the device, but the endpoint buffer is still full.
	
	The endpoint interrupt handlers can distinguish regular (ACK) interrupts
	from NAK interrupt by checking the bits in their bEPStatus argument.
	
	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
   16594:	e20010ff 	and	r1, r0, #255	; 0xff
	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
   16598:	e3a000f3 	mov	r0, #243	; 0xf3
   1659c:	eaffff93 	b	163f0 <USBHwCmdWrite>

000165a0 <USBHwEPGetStatus>:
}


/**
	Gets the status from a specific endpoint.
		
	@param [in]	bEP		Endpoint number
	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8	USBHwEPGetStatus(U8 bEP)
{
   165a0:	e1a03000 	mov	r3, r0
	int idx = EP2IDX(bEP);

	return USBHwCmdRead(CMD_EP_SELECT | idx);
   165a4:	e2000080 	and	r0, r0, #128	; 0x80
   165a8:	e203300f 	and	r3, r3, #15	; 0xf
   165ac:	e1a003c0 	mov	r0, r0, asr #7
   165b0:	e52de004 	str	lr, [sp, #-4]!
   165b4:	e1800083 	orr	r0, r0, r3, lsl #1
   165b8:	ebffff9e 	bl	16438 <USBHwCmdRead>
}
   165bc:	e49de004 	ldr	lr, [sp], #4
   165c0:	e12fff1e 	bx	lr

000165c4 <USBHwEPStall>:


/**
	Sets the stalled property of an endpoint
		
	@param [in]	bEP		Endpoint number
	@param [in]	fStall	TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
	int idx = EP2IDX(bEP);

	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
   165c4:	e2003080 	and	r3, r0, #128	; 0x80
   165c8:	e1a033c3 	mov	r3, r3, asr #7
   165cc:	e200000f 	and	r0, r0, #15	; 0xf
   165d0:	e1833080 	orr	r3, r3, r0, lsl #1
   165d4:	e2511000 	subs	r1, r1, #0	; 0x0
   165d8:	13a01001 	movne	r1, #1	; 0x1
   165dc:	e3830040 	orr	r0, r3, #64	; 0x40
   165e0:	eaffff82 	b	163f0 <USBHwCmdWrite>

000165e4 <USBHwEPWrite>:
}


/**
	Writes data to an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iLen	Number of bytes to write
			
	@return TRUE if the data was successfully written or <0 in case of error.
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
{
   165e4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	int idx;
	
	idx = EP2IDX(bEP);
   165e8:	e200400f 	and	r4, r0, #15	; 0xf
	
	// set write enable for specific endpoint
	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
   165ec:	e59fc074 	ldr	ip, [pc, #116]	; 16668 <.text+0x6668>
   165f0:	e1a03104 	mov	r3, r4, lsl #2
   165f4:	e3833002 	orr	r3, r3, #2	; 0x2
   165f8:	e1a05002 	mov	r5, r2
	
	// set packet length
	USBTxPLen = iLen;
   165fc:	e1a0e001 	mov	lr, r1
   16600:	e20000ff 	and	r0, r0, #255	; 0xff
   16604:	e58c3028 	str	r3, [ip, #40]
   16608:	e58c2024 	str	r2, [ip, #36]
   1660c:	ea000008 	b	16634 <USBHwEPWrite+0x50>
	
	// write data
	while (USBCtrl & WR_EN) {
		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
   16610:	e55e3002 	ldrb	r3, [lr, #-2]
   16614:	e55e2001 	ldrb	r2, [lr, #-1]
   16618:	e55e1004 	ldrb	r1, [lr, #-4]
   1661c:	e1a03803 	mov	r3, r3, lsl #16
   16620:	e1833c02 	orr	r3, r3, r2, lsl #24
   16624:	e55e2003 	ldrb	r2, [lr, #-3]
   16628:	e1833001 	orr	r3, r3, r1
   1662c:	e1833402 	orr	r3, r3, r2, lsl #8
   16630:	e58c301c 	str	r3, [ip, #28]
   16634:	e59fc02c 	ldr	ip, [pc, #44]	; 16668 <.text+0x6668>
   16638:	e59c3028 	ldr	r3, [ip, #40]
   1663c:	e3130002 	tst	r3, #2	; 0x2
   16640:	e28ee004 	add	lr, lr, #4	; 0x4
   16644:	1afffff1 	bne	16610 <USBHwEPWrite+0x2c>
		pbBuf += 4;
	}

	// select endpoint and validate buffer
	USBHwCmd(CMD_EP_SELECT | idx);
   16648:	e1a003a0 	mov	r0, r0, lsr #7
   1664c:	e1800084 	orr	r0, r0, r4, lsl #1
   16650:	ebffff57 	bl	163b4 <USBHwCmd>
	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
   16654:	e3a000fa 	mov	r0, #250	; 0xfa
   16658:	ebffff55 	bl	163b4 <USBHwCmd>
	
	return iLen;
}
   1665c:	e1a00005 	mov	r0, r5
   16660:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16664:	e12fff1e 	bx	lr
   16668:	e0090000 	and	r0, r9, r0

0001666c <USBHwEPRead>:


/**
	Reads data from an endpoint buffer
		
	@param [in]	bEP		Endpoint number
	@param [in]	pbBuf	Endpoint data
	@param [in]	iMaxLen	Maximum number of bytes to read
			
	@return the number of bytes available in the EP (possibly more than iMaxLen),
	or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
{
   1666c:	e92d4010 	stmdb	sp!, {r4, lr}
	int i, idx;
	U32	dwData, dwLen;
	
	idx = EP2IDX(bEP);
   16670:	e200e00f 	and	lr, r0, #15	; 0xf
	
	// set read enable bit for specific endpoint
	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
   16674:	e1a0310e 	mov	r3, lr, lsl #2
   16678:	e59fc08c 	ldr	ip, [pc, #140]	; 1670c <.text+0x670c>
   1667c:	e3833001 	orr	r3, r3, #1	; 0x1
   16680:	e58c3028 	str	r3, [ip, #40]
   16684:	e20000ff 	and	r0, r0, #255	; 0xff
	
	// wait for PKT_RDY
	do {
		dwLen = USBRxPLen;
   16688:	e59f307c 	ldr	r3, [pc, #124]	; 1670c <.text+0x670c>
   1668c:	e5933020 	ldr	r3, [r3, #32]
	} while ((dwLen & PKT_RDY) == 0);
   16690:	e3130b02 	tst	r3, #2048	; 0x800
   16694:	0afffffb 	beq	16688 <USBHwEPRead+0x1c>
	
	// packet valid?
	if ((dwLen & DV) == 0) {
   16698:	e3130b01 	tst	r3, #1024	; 0x400
   1669c:	03e04000 	mvneq	r4, #0	; 0x0
   166a0:	0a000016 	beq	16700 <USBHwEPRead+0x94>
		return -1;
	}
	
	// get length
	dwLen &= PKT_LNGTH_MASK;
   166a4:	e1a0cb03 	mov	ip, r3, lsl #22
   166a8:	e3a04000 	mov	r4, #0	; 0x0
   166ac:	e1a0cb2c 	mov	ip, ip, lsr #22
   166b0:	e1a03004 	mov	r3, r4
   166b4:	ea000007 	b	166d8 <USBHwEPRead+0x6c>
	
	// get data
	dwData = 0;
	for (i = 0; i < dwLen; i++) {
		if ((i % 4) == 0) {
   166b8:	e3140003 	tst	r4, #3	; 0x3
			dwData = USBRxData;
   166bc:	059f3048 	ldreq	r3, [pc, #72]	; 1670c <.text+0x670c>
   166c0:	05933018 	ldreq	r3, [r3, #24]
		}
		if ((pbBuf != NULL) && (i < iMaxLen)) {
   166c4:	e3510000 	cmp	r1, #0	; 0x0
   166c8:	11540002 	cmpne	r4, r2
			pbBuf[i] = dwData & 0xFF;
   166cc:	b7c43001 	strltb	r3, [r4, r1]
		}
		dwData >>= 8;
   166d0:	e1a03423 	mov	r3, r3, lsr #8
   166d4:	e2844001 	add	r4, r4, #1	; 0x1
   166d8:	e154000c 	cmp	r4, ip
   166dc:	1afffff5 	bne	166b8 <USBHwEPRead+0x4c>
	}

	// make sure RD_EN is clear
	USBCtrl = 0;
   166e0:	e59f3024 	ldr	r3, [pc, #36]	; 1670c <.text+0x670c>
   166e4:	e3a02000 	mov	r2, #0	; 0x0

	// select endpoint and clear buffer
	USBHwCmd(CMD_EP_SELECT | idx);
   166e8:	e1a003a0 	mov	r0, r0, lsr #7
   166ec:	e180008e 	orr	r0, r0, lr, lsl #1
   166f0:	e5832028 	str	r2, [r3, #40]
   166f4:	ebffff2e 	bl	163b4 <USBHwCmd>
	USBHwCmd(CMD_EP_CLEAR_BUFFER);
   166f8:	e3a000f2 	mov	r0, #242	; 0xf2
   166fc:	ebffff2c 	bl	163b4 <USBHwCmd>
	
	return dwLen;
}
   16700:	e1a00004 	mov	r0, r4
   16704:	e8bd4010 	ldmia	sp!, {r4, lr}
   16708:	e12fff1e 	bx	lr
   1670c:	e0090000 	and	r0, r9, r0

00016710 <USBHwConfigDevice>:


/**
	Sets the 'configured' state.
		
	All registered endpoints are 'realised' and enabled, and the
	'configured' bit is set in the device status register.
		
	@param [in]	fConfigured	If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
	// set configured bit
	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
   16710:	e2501000 	subs	r1, r0, #0	; 0x0
   16714:	13a01001 	movne	r1, #1	; 0x1
   16718:	e3a000d8 	mov	r0, #216	; 0xd8
   1671c:	eaffff33 	b	163f0 <USBHwCmdWrite>

00016720 <USBHwISR>:
}


/**
	USB interrupt handler
		
	@todo Get all 11 bits of frame number instead of just 8

	Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
	U32	dwStatus;
	U32 dwIntBit;
	U8	bEPStat, bDevStat, bStat;
	int i;
	U16	wFrame;

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

	// handle device interrupts
	dwStatus = USBDevIntSt;
   16720:	e59f2110 	ldr	r2, [pc, #272]	; 16838 <.text+0x6838>
   16724:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   16728:	e5925000 	ldr	r5, [r2]
	
	// frame interrupt
	if (dwStatus & FRAME) {
   1672c:	e3150001 	tst	r5, #1	; 0x1
   16730:	0a00000b 	beq	16764 <USBHwISR+0x44>
		// clear int
		USBDevIntClr = FRAME;
		// call handler
		if (_pfnFrameHandler != NULL) {
   16734:	e59f3100 	ldr	r3, [pc, #256]	; 1683c <.text+0x683c>
   16738:	e5934000 	ldr	r4, [r3]
   1673c:	e3a03001 	mov	r3, #1	; 0x1
   16740:	e3540000 	cmp	r4, #0	; 0x0
   16744:	e5823008 	str	r3, [r2, #8]
   16748:	0a000005 	beq	16764 <USBHwISR+0x44>
			wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
   1674c:	e3a000f5 	mov	r0, #245	; 0xf5
   16750:	ebffff38 	bl	16438 <USBHwCmdRead>
			_pfnFrameHandler(wFrame);
   16754:	e1a00800 	mov	r0, r0, lsl #16
   16758:	e1a00820 	mov	r0, r0, lsr #16
   1675c:	e1a0e00f 	mov	lr, pc
   16760:	e12fff14 	bx	r4
		}
	}
	
	// device status interrupt
	if (dwStatus & DEV_STAT) {
   16764:	e3150008 	tst	r5, #8	; 0x8
   16768:	0a00000c 	beq	167a0 <USBHwISR+0x80>
		/*	Clear DEV_STAT interrupt before reading DEV_STAT register.
			This prevents corrupted device status reads, see
			LPC2148 User manual revision 2, 25 july 2006.
		*/
		USBDevIntClr = DEV_STAT;
   1676c:	e59f30c4 	ldr	r3, [pc, #196]	; 16838 <.text+0x6838>
   16770:	e3a02008 	mov	r2, #8	; 0x8
		bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
   16774:	e3a000fe 	mov	r0, #254	; 0xfe
   16778:	e5832008 	str	r2, [r3, #8]
   1677c:	ebffff2d 	bl	16438 <USBHwCmdRead>
		if (bDevStat & (CON_CH | SUS_CH | RST)) {
   16780:	e310001a 	tst	r0, #26	; 0x1a
   16784:	0a000005 	beq	167a0 <USBHwISR+0x80>
			// convert device status into something HW independent
			bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
					((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
					((bDevStat & RST) ? DEV_STATUS_RESET : 0);
			// call handler
			if (_pfnDevIntHandler != NULL) {
   16788:	e59f30b0 	ldr	r3, [pc, #176]	; 16840 <.text+0x6840>
   1678c:	e5933000 	ldr	r3, [r3]
   16790:	e3530000 	cmp	r3, #0	; 0x0
DEBUG_LED_ON(8);		
				_pfnDevIntHandler(bStat);
   16794:	12000015 	andne	r0, r0, #21	; 0x15
   16798:	11a0e00f 	movne	lr, pc
   1679c:	112fff13 	bxne	r3
DEBUG_LED_OFF(8);		
			}
		}
	}
	
	// endpoint interrupt
	if (dwStatus & EP_SLOW) {
   167a0:	e3150004 	tst	r5, #4	; 0x4
   167a4:	0a000021 	beq	16830 <USBHwISR+0x110>
		// clear EP_SLOW
		USBDevIntClr = EP_SLOW;
   167a8:	e59f3088 	ldr	r3, [pc, #136]	; 16838 <.text+0x6838>
   167ac:	e3a02004 	mov	r2, #4	; 0x4
   167b0:	e5832008 	str	r2, [r3, #8]
   167b4:	e3a04000 	mov	r4, #0	; 0x0
		// check all endpoints
		for (i = 0; i < 32; i++) {
			dwIntBit = (1 << i);
   167b8:	e3a03001 	mov	r3, #1	; 0x1
   167bc:	e1a02413 	mov	r2, r3, lsl r4
			if (USBEpIntSt & dwIntBit) {
   167c0:	e59f1070 	ldr	r1, [pc, #112]	; 16838 <.text+0x6838>
   167c4:	e5913030 	ldr	r3, [r1, #48]
   167c8:	e1130002 	tst	r3, r2
   167cc:	0a000014 	beq	16824 <USBHwISR+0x104>
				// clear int (and retrieve status)
				USBEpIntClr = dwIntBit;
   167d0:	e5812038 	str	r2, [r1, #56]
   167d4:	e59f105c 	ldr	r1, [pc, #92]	; 16838 <.text+0x6838>
   167d8:	e5913000 	ldr	r3, [r1]
   167dc:	e2030020 	and	r0, r3, #32	; 0x20
   167e0:	e3500020 	cmp	r0, #32	; 0x20
   167e4:	1afffffa 	bne	167d4 <USBHwISR+0xb4>
				Wait4DevInt(CDFULL);
				bEPStat = USBCmdData;
				// convert EP pipe stat into something HW independent
				bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
						((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
						((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
						((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
						((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
				// call handler
				if (_apfnEPIntHandlers[i / 2] != NULL) {
   167e8:	e0843fa4 	add	r3, r4, r4, lsr #31
   167ec:	e59f2050 	ldr	r2, [pc, #80]	; 16844 <.text+0x6844>
   167f0:	e1a030c3 	mov	r3, r3, asr #1
   167f4:	e7923103 	ldr	r3, [r2, r3, lsl #2]
   167f8:	e5810008 	str	r0, [r1, #8]
   167fc:	e3530000 	cmp	r3, #0	; 0x0
   16800:	e5911014 	ldr	r1, [r1, #20]
   16804:	0a000006 	beq	16824 <USBHwISR+0x104>
DEBUG_LED_ON(10);		
					_apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
   16808:	e1a000c4 	mov	r0, r4, asr #1
   1680c:	e200000f 	and	r0, r0, #15	; 0xf
   16810:	e1800384 	orr	r0, r0, r4, lsl #7
   16814:	e200008f 	and	r0, r0, #143	; 0x8f
   16818:	e201101f 	and	r1, r1, #31	; 0x1f
   1681c:	e1a0e00f 	mov	lr, pc
   16820:	e12fff13 	bx	r3
   16824:	e2844001 	add	r4, r4, #1	; 0x1
   16828:	e3540020 	cmp	r4, #32	; 0x20
   1682c:	1affffe1 	bne	167b8 <USBHwISR+0x98>
DEBUG_LED_OFF(10);
				}
			}
		}
	}
	
DEBUG_LED_OFF(9);		
}
   16830:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16834:	e12fff1e 	bx	lr
   16838:	e0090000 	and	r0, r9, r0
   1683c:	40000d14 	andmi	r0, r0, r4, lsl sp
   16840:	40000d18 	andmi	r0, r0, r8, lsl sp
   16844:	40000d1c 	andmi	r0, r0, ip, lsl sp

00016848 <USBHwInit>:



/**
	Initialises the USB hardware
		
	This function assumes that the hardware is connected as shown in
	section 10.1 of the LPC2148 data sheet:
	* P0.31 controls a switch to connect a 1.5k pull-up to D+ if low.
	* P0.23 is connected to USB VCC.
	
	Embedded artists board: make sure to disconnect P0.23 LED as it
	acts as a pull-up and so prevents detection of USB disconnect.
		
	@return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
	// configure P0.23 for Vbus sense
	PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);	// P0.23
   16848:	e59f20b0 	ldr	r2, [pc, #176]	; 16900 <.text+0x6900>
   1684c:	e5923004 	ldr	r3, [r2, #4]
   16850:	e3c33903 	bic	r3, r3, #49152	; 0xc000
   16854:	e3833901 	orr	r3, r3, #16384	; 0x4000
   16858:	e5823004 	str	r3, [r2, #4]
	// configure P0.31 for CONNECT
	PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);	// P0.31
   1685c:	e5923004 	ldr	r3, [r2, #4]
   16860:	e3c33103 	bic	r3, r3, #-1073741824	; 0xc0000000
   16864:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   16868:	e5823004 	str	r3, [r2, #4]

	// enable PUSB
	PCONP |= (1 << 31);		
   1686c:	e282281d 	add	r2, r2, #1900544	; 0x1d0000
   16870:	e59230c4 	ldr	r3, [r2, #196]
   16874:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   16878:	e58230c4 	str	r3, [r2, #196]
	
	// initialise PLL
	PLL1CON = 1;			// enable PLL
   1687c:	e3a03001 	mov	r3, #1	; 0x1
   16880:	e58230a0 	str	r3, [r2, #160]
   16884:	e52de004 	str	lr, [sp, #-4]!
	PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
   16888:	e2833022 	add	r3, r3, #34	; 0x22
   1688c:	e58230a4 	str	r3, [r2, #164]
	PLL1FEED = 0xAA;
   16890:	e2833087 	add	r3, r3, #135	; 0x87
   16894:	e58230ac 	str	r3, [r2, #172]
	PLL1FEED = 0x55;
   16898:	e3a03055 	mov	r3, #85	; 0x55
   1689c:	e58230ac 	str	r3, [r2, #172]
	while ((PLL1STAT & (1 << 10)) == 0);
   168a0:	e59fe05c 	ldr	lr, [pc, #92]	; 16904 <.text+0x6904>
   168a4:	e59e30a8 	ldr	r3, [lr, #168]
   168a8:	e3130b01 	tst	r3, #1024	; 0x400
   168ac:	0afffffb 	beq	168a0 <USBHwInit+0x58>

	PLL1CON = 3;			// enable and connect
   168b0:	e3a03003 	mov	r3, #3	; 0x3
   168b4:	e58e30a0 	str	r3, [lr, #160]
	PLL1FEED = 0xAA;
	PLL1FEED = 0x55;
	
	// disable/clear all interrupts for now
	USBDevIntEn = 0;
   168b8:	e59f2048 	ldr	r2, [pc, #72]	; 16908 <.text+0x6908>
   168bc:	e28330a7 	add	r3, r3, #167	; 0xa7
   168c0:	e58e30ac 	str	r3, [lr, #172]
   168c4:	e3a01000 	mov	r1, #0	; 0x0
	USBDevIntClr = 0xFFFFFFFF;
   168c8:	e3e0c000 	mvn	ip, #0	; 0x0
   168cc:	e3a03055 	mov	r3, #85	; 0x55
   168d0:	e58e30ac 	str	r3, [lr, #172]
	USBDevIntPri = 0;

	USBEpIntEn = 0;
	USBEpIntClr = 0xFFFFFFFF;
	USBEpIntPri = 0;

	// by default, only ACKs generate interrupts
	USBHwNakIntEnable(0);
   168d4:	e1a00001 	mov	r0, r1
   168d8:	e5821004 	str	r1, [r2, #4]
   168dc:	e582c008 	str	ip, [r2, #8]
   168e0:	e582102c 	str	r1, [r2, #44]
   168e4:	e5821034 	str	r1, [r2, #52]
   168e8:	e582c038 	str	ip, [r2, #56]
   168ec:	e5821040 	str	r1, [r2, #64]
   168f0:	ebffff27 	bl	16594 <USBHwNakIntEnable>
	
	// init debug leds
	DEBUG_LED_INIT(8);
	DEBUG_LED_INIT(9);
	DEBUG_LED_INIT(10);

	return TRUE;
}
   168f4:	e3a00001 	mov	r0, #1	; 0x1
   168f8:	e49de004 	ldr	lr, [sp], #4
   168fc:	e12fff1e 	bx	lr
   16900:	e002c000 	and	ip, r2, r0
   16904:	e01fc000 	ands	ip, pc, r0
   16908:	e0090000 	and	r0, r9, r0

0001690c <_HandleRequest>:

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
   1690c:	e52de004 	str	lr, [sp, #-4]!
	TFnHandleRequest *pfnHandler;
	int iType;
	
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
	pfnHandler = apfnReqHandlers[iType];
   16910:	e5d03000 	ldrb	r3, [r0]
   16914:	e59fc02c 	ldr	ip, [pc, #44]	; 16948 <.text+0x6948>
   16918:	e1a032a3 	mov	r3, r3, lsr #5
   1691c:	e2033003 	and	r3, r3, #3	; 0x3
   16920:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
	if (pfnHandler == NULL) {
   16924:	e3530000 	cmp	r3, #0	; 0x0
   16928:	e1a0c003 	mov	ip, r3
   1692c:	0a000002 	beq	1693c <_HandleRequest+0x30>
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
	}

	return pfnHandler(pSetup, piLen, ppbData);
   16930:	e1a0e00f 	mov	lr, pc
   16934:	e12fff13 	bx	r3
   16938:	e1a0c000 	mov	ip, r0
}
   1693c:	e1a0000c 	mov	r0, ip
   16940:	e49de004 	ldr	lr, [sp], #4
   16944:	e12fff1e 	bx	lr
   16948:	40000d5c 	andmi	r0, r0, ip, asr sp

0001694c <USBRegisterRequestHandler>:


/**
	Local function to stall the control endpoint
	
	@param [in]	bEPStat	Endpoint status
 */
static void StallControlPipe(U8 bEPStat)
{
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);

// dump setup packet
	DBG("STALL on [");
	pb = (U8 *)&Setup;
	for (i = 0; i < 8; i++) {
		DBG(" %02x", *pb++);
	}
	DBG("] stat=%x\n", bEPStat);
}


/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
	USBHwEPWrite(0x80, pbData, iChunk);
	pbData += iChunk;
	iResidue -= iChunk;
}


/**
 *	Handles IN/OUT transfers on EP0
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
	int iChunk, iType;

	if (bEP == 0x00) {
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
			pbData = apbDataStore[iType];
			iResidue = Setup.wLength;
			iLen = Setup.wLength;

			if ((Setup.wLength == 0) ||
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
					DBG("_HandleRequest1 failed\n");
					StallControlPipe(bEPStat);
					return;
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
				// send first part (possibly a zero-length status message)
				DataIn();
			}
		}
		else {		
			if (iResidue > 0) {
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
				if (iChunk < 0) {
					StallControlPipe(bEPStat);
					return;
				}
				pbData += iChunk;
				iResidue -= iChunk;
				if (iResidue == 0) {
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
					pbData = apbDataStore[iType];
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
						DBG("_HandleRequest2 failed\n");
						StallControlPipe(bEPStat);
						return;
					}
					// send status to host
					DataIn();
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
				DBG(iChunk > 0 ? "?" : "");
			}
		}
	}
	else if (bEP == 0x80) {
		// IN transfer
		// send more data if available (possibly a 0-length packet)
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}


/**
	Registers a callback for handling requests
		
	@param [in]	iType			Type of request, e.g. REQTYPE_TYPE_STANDARD
	@param [in]	*pfnHandler		Callback function pointer
	@param [in]	*pbDataStore	Data storage area for this type of request
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
	apbDataStore[iType] = pbDataStore;
   1694c:	e59f300c 	ldr	r3, [pc, #12]	; 16960 <.text+0x6960>
   16950:	e7832100 	str	r2, [r3, r0, lsl #2]
   16954:	e59f3008 	ldr	r3, [pc, #8]	; 16964 <.text+0x6964>
   16958:	e7831100 	str	r1, [r3, r0, lsl #2]
}
   1695c:	e12fff1e 	bx	lr
   16960:	40000d6c 	andmi	r0, r0, ip, ror #26
   16964:	40000d5c 	andmi	r0, r0, ip, asr sp

00016968 <StallControlPipe>:
   16968:	e52de004 	str	lr, [sp, #-4]!
   1696c:	e3a00080 	mov	r0, #128	; 0x80
   16970:	e3a01001 	mov	r1, #1	; 0x1
   16974:	ebffff12 	bl	165c4 <USBHwEPStall>
   16978:	e49de004 	ldr	lr, [sp], #4
   1697c:	e12fff1e 	bx	lr

00016980 <DataIn>:
   16980:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
   16984:	e59f603c 	ldr	r6, [pc, #60]	; 169c8 <.text+0x69c8>
   16988:	e5964000 	ldr	r4, [r6]
   1698c:	e59f5038 	ldr	r5, [pc, #56]	; 169cc <.text+0x69cc>
   16990:	e3540040 	cmp	r4, #64	; 0x40
   16994:	a3a04040 	movge	r4, #64	; 0x40
   16998:	e1a02004 	mov	r2, r4
   1699c:	e3a00080 	mov	r0, #128	; 0x80
   169a0:	e5951000 	ldr	r1, [r5]
   169a4:	ebffff0e 	bl	165e4 <USBHwEPWrite>
   169a8:	e5953000 	ldr	r3, [r5]
   169ac:	e5962000 	ldr	r2, [r6]
   169b0:	e0833004 	add	r3, r3, r4
   169b4:	e0642002 	rsb	r2, r4, r2
   169b8:	e5853000 	str	r3, [r5]
   169bc:	e5862000 	str	r2, [r6]
   169c0:	e8bd4070 	ldmia	sp!, {r4, r5, r6, lr}
   169c4:	e12fff1e 	bx	lr
   169c8:	40000d88 	andmi	r0, r0, r8, lsl #27
   169cc:	40000d84 	andmi	r0, r0, r4, lsl #27

000169d0 <USBHandleControlTransfer>:
   169d0:	e21000ff 	ands	r0, r0, #255	; 0xff
   169d4:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   169d8:	e20170ff 	and	r7, r1, #255	; 0xff
   169dc:	1a000043 	bne	16af0 <USBHandleControlTransfer+0x120>
   169e0:	e3110004 	tst	r1, #4	; 0x4
   169e4:	e59f611c 	ldr	r6, [pc, #284]	; 16b08 <.text+0x6b08>
   169e8:	0a00001d 	beq	16a64 <USBHandleControlTransfer+0x94>
   169ec:	e59f5118 	ldr	r5, [pc, #280]	; 16b0c <.text+0x6b0c>
   169f0:	e3a02008 	mov	r2, #8	; 0x8
   169f4:	e1a01005 	mov	r1, r5
   169f8:	ebffff1b 	bl	1666c <USBHwEPRead>
   169fc:	e5d50000 	ldrb	r0, [r5]
   16a00:	e59f2108 	ldr	r2, [pc, #264]	; 16b10 <.text+0x6b10>
   16a04:	e1a032a0 	mov	r3, r0, lsr #5
   16a08:	e1d510b6 	ldrh	r1, [r5, #6]
   16a0c:	e2033003 	and	r3, r3, #3	; 0x3
   16a10:	e7923103 	ldr	r3, [r2, r3, lsl #2]
   16a14:	e59f40f8 	ldr	r4, [pc, #248]	; 16b14 <.text+0x6b14>
   16a18:	e59f20f8 	ldr	r2, [pc, #248]	; 16b18 <.text+0x6b18>
   16a1c:	e3510000 	cmp	r1, #0	; 0x0
   16a20:	e5823000 	str	r3, [r2]
   16a24:	e5861000 	str	r1, [r6]
   16a28:	e5841000 	str	r1, [r4]
   16a2c:	0a000001 	beq	16a38 <USBHandleControlTransfer+0x68>
   16a30:	e1b003a0 	movs	r0, r0, lsr #7
   16a34:	0a000031 	beq	16b00 <USBHandleControlTransfer+0x130>
   16a38:	e1a00005 	mov	r0, r5
   16a3c:	e1a01004 	mov	r1, r4
   16a40:	ebffffb1 	bl	1690c <_HandleRequest>
   16a44:	e3500000 	cmp	r0, #0	; 0x0
   16a48:	0a000021 	beq	16ad4 <USBHandleControlTransfer+0x104>
   16a4c:	e1d520b6 	ldrh	r2, [r5, #6]
   16a50:	e5943000 	ldr	r3, [r4]
   16a54:	e1520003 	cmp	r2, r3
   16a58:	d5862000 	strle	r2, [r6]
   16a5c:	c5863000 	strgt	r3, [r6]
   16a60:	ea000024 	b	16af8 <USBHandleControlTransfer+0x128>
   16a64:	e5962000 	ldr	r2, [r6]
   16a68:	e3520000 	cmp	r2, #0	; 0x0
   16a6c:	da00001b 	ble	16ae0 <USBHandleControlTransfer+0x110>
   16a70:	e59f40a0 	ldr	r4, [pc, #160]	; 16b18 <.text+0x6b18>
   16a74:	e5941000 	ldr	r1, [r4]
   16a78:	ebfffefb 	bl	1666c <USBHwEPRead>
   16a7c:	e3500000 	cmp	r0, #0	; 0x0
   16a80:	ba000013 	blt	16ad4 <USBHandleControlTransfer+0x104>
   16a84:	e5962000 	ldr	r2, [r6]
   16a88:	e5943000 	ldr	r3, [r4]
   16a8c:	e0602002 	rsb	r2, r0, r2
   16a90:	e0833000 	add	r3, r3, r0
   16a94:	e3520000 	cmp	r2, #0	; 0x0
   16a98:	e5843000 	str	r3, [r4]
   16a9c:	e5862000 	str	r2, [r6]
   16aa0:	1a000016 	bne	16b00 <USBHandleControlTransfer+0x130>
   16aa4:	e59f0060 	ldr	r0, [pc, #96]	; 16b0c <.text+0x6b0c>
   16aa8:	e5d03000 	ldrb	r3, [r0]
   16aac:	e59f205c 	ldr	r2, [pc, #92]	; 16b10 <.text+0x6b10>
   16ab0:	e1a032a3 	mov	r3, r3, lsr #5
   16ab4:	e2033003 	and	r3, r3, #3	; 0x3
   16ab8:	e7923103 	ldr	r3, [r2, r3, lsl #2]
   16abc:	e59f1050 	ldr	r1, [pc, #80]	; 16b14 <.text+0x6b14>
   16ac0:	e1a02004 	mov	r2, r4
   16ac4:	e5843000 	str	r3, [r4]
   16ac8:	ebffff8f 	bl	1690c <_HandleRequest>
   16acc:	e3500000 	cmp	r0, #0	; 0x0
   16ad0:	1a000008 	bne	16af8 <USBHandleControlTransfer+0x128>
   16ad4:	e1a00007 	mov	r0, r7
   16ad8:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   16adc:	eaffffa1 	b	16968 <StallControlPipe>
   16ae0:	e1a01000 	mov	r1, r0
   16ae4:	e1a02000 	mov	r2, r0
   16ae8:	ebfffedf 	bl	1666c <USBHwEPRead>
   16aec:	ea000003 	b	16b00 <USBHandleControlTransfer+0x130>
   16af0:	e3500080 	cmp	r0, #128	; 0x80
   16af4:	1a000001 	bne	16b00 <USBHandleControlTransfer+0x130>
   16af8:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   16afc:	eaffff9f 	b	16980 <DataIn>
   16b00:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   16b04:	e12fff1e 	bx	lr
   16b08:	40000d88 	andmi	r0, r0, r8, lsl #27
   16b0c:	40000d7c 	andmi	r0, r0, ip, ror sp
   16b10:	40000d6c 	andmi	r0, r0, ip, ror #26
   16b14:	40000d8c 	andmi	r0, r0, ip, lsl #27
   16b18:	40000d84 	andmi	r0, r0, r4, lsl #27

00016b1c <USBRegisterDescriptors>:
 */
//void USBRegisterDescriptors(const U8 *pabDescriptors)
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
   16b1c:	e59f3004 	ldr	r3, [pc, #4]	; 16b28 <.text+0x6b28>
   16b20:	e5830000 	str	r0, [r3]
}
   16b24:	e12fff1e 	bx	lr
   16b28:	40000d98 	mulmi	r0, r8, sp

00016b2c <USBGetDescriptor>:


/**
	Parses the list of installed USB descriptors and attempts to find
	the specified USB descriptor.
		
	@param [in]		wTypeIndex	Type and index of the descriptor
	@param [in]		wLangID		Language ID of the descriptor (currently unused)
	@param [out]	*piLen		Descriptor length
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
   16b2c:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	U8	bType, bIndex;
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
	pab = (U8 *)pabDescrip;
   16b30:	e59f1074 	ldr	r1, [pc, #116]	; 16bac <.text+0x6bac>
   16b34:	e1a00800 	mov	r0, r0, lsl #16
   16b38:	e591c000 	ldr	ip, [r1]
   16b3c:	e1a01820 	mov	r1, r0, lsr #16
   16b40:	e1a05002 	mov	r5, r2
   16b44:	e1a04003 	mov	r4, r3
   16b48:	e1a0ec20 	mov	lr, r0, lsr #24
   16b4c:	e20110ff 	and	r1, r1, #255	; 0xff
   16b50:	e3a02000 	mov	r2, #0	; 0x0
   16b54:	ea00000f 	b	16b98 <USBGetDescriptor+0x6c>
	iCurIndex = 0;
	
	while (pab[DESC_bLength] != 0) {
		if (pab[DESC_bDescriptorType] == bType) {
   16b58:	e5dc3001 	ldrb	r3, [ip, #1]
   16b5c:	e153000e 	cmp	r3, lr
   16b60:	1a00000b 	bne	16b94 <USBGetDescriptor+0x68>
			if (iCurIndex == bIndex) {
   16b64:	e1520001 	cmp	r2, r1
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
			}
			iCurIndex++;
   16b68:	e2822001 	add	r2, r2, #1	; 0x1
   16b6c:	1a000008 	bne	16b94 <USBGetDescriptor+0x68>
   16b70:	e584c000 	str	ip, [r4]
   16b74:	e35e0002 	cmp	lr, #2	; 0x2
   16b78:	05dc2003 	ldreqb	r2, [ip, #3]
   16b7c:	05dc3002 	ldreqb	r3, [ip, #2]
   16b80:	15dc3000 	ldrneb	r3, [ip]
   16b84:	01833402 	orreq	r3, r3, r2, lsl #8
   16b88:	e3a00001 	mov	r0, #1	; 0x1
   16b8c:	e5853000 	str	r3, [r5]
   16b90:	ea000003 	b	16ba4 <USBGetDescriptor+0x78>
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
   16b94:	e08cc000 	add	ip, ip, r0
   16b98:	e5dc0000 	ldrb	r0, [ip]
   16b9c:	e3500000 	cmp	r0, #0	; 0x0
   16ba0:	1affffec 	bne	16b58 <USBGetDescriptor+0x2c>
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
   16ba4:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   16ba8:	e12fff1e 	bx	lr
   16bac:	40000d98 	mulmi	r0, r8, sp

00016bb0 <USBRegisterCustomReqHandler>:


/**
	Configures the device according to the specified configuration index and
	alternate setting by parsing the installed USB descriptor list.
	A configuration index of 0 unconfigures the device.
		
	@param [in]		bConfigIndex	Configuration index
	@param [in]		bAltSetting		Alternate setting number
	
	@todo function always returns TRUE, add stricter checking?
	
	@return TRUE if successfully configured, FALSE otherwise
 */
static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
{
	U8	*pab;
	U8	bCurConfig, bCurAltSetting;
	U8	bEP;
	U16	wMaxPktSize;
	
	ASSERT(pabDescrip != NULL);

	if (bConfigIndex == 0) {
		// unconfigure device
		USBHwConfigDevice(FALSE);
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {

			switch (pab[DESC_bDescriptorType]) {

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
				break;

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
				break;

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
				}
				break;

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
		}
		
		// configure device
		USBHwConfigDevice(TRUE);
	}

	return TRUE;
}


/**
	Local function to handle a standard device request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	
	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
		break;

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
		*piLen = 1;
		break;

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
			DBG("USBSetConfiguration failed!\n");
			return FALSE;
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;	
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_REMOTE_WAKEUP) {
			// put DEVICE_REMOTE_WAKEUP code here
		}
		if (pSetup->wValue == FEA_TEST_MODE) {
			// put TEST_MODE code here
		}
		return FALSE;

	case REQ_SET_DESCRIPTOR:
		DBG("Device req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal device req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Local function to handle a standard interface request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
		pbData[1] = 0;
		*piLen = 2;
		break;

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		// not defined for interface
		return FALSE;
	
	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
		*piLen = 1;
		break;
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
			return FALSE;
		}
		*piLen = 0;
		break;

	default:
		DBG("Illegal interface req %d\n", pSetup->bRequest);
		return FALSE;
	}

	return TRUE;
}


/**
	Local function to handle a standard endpoint request
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
		pbData[1] = 0;
		*piLen = 2;
		break;
		
	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
	
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
			break;
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;

	case REQ_SYNCH_FRAME:
		DBG("EP req %d not implemented\n", pSetup->bRequest);
		return FALSE;

	default:
		DBG("Illegal EP req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
}


/**
	Default handler for standard ('chapter 9') requests
	
	If a custom request handler was installed, this handler is called first.
		
	@param [in]		pSetup		The setup packet
	@param [in,out]	*piLen		Pointer to data length
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}


/**
	Registers a callback for custom device requests
	
	In USBHandleStandardRequest, the custom request handler gets a first
	chance at handling the request before it is handed over to the 'chapter 9'
	request handler.
	
	This can be used for example in HID devices, where a REQ_GET_DESCRIPTOR
	request is sent to an interface, which is not covered by the 'chapter 9'
	specification.
		
	@param [in]	pfnHandler	Callback function pointer
 */
void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
{
	pfnHandleCustomReq = pfnHandler;
   16bb0:	e59f3004 	ldr	r3, [pc, #4]	; 16bbc <.text+0x6bbc>
   16bb4:	e5830000 	str	r0, [r3]
}
   16bb8:	e12fff1e 	bx	lr
   16bbc:	40000d90 	mulmi	r0, r0, sp

00016bc0 <USBHandleStandardRequest>:
   16bc0:	e59f3264 	ldr	r3, [pc, #612]	; 16e2c <.text+0x6e2c>
   16bc4:	e5933000 	ldr	r3, [r3]
   16bc8:	e3530000 	cmp	r3, #0	; 0x0
   16bcc:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   16bd0:	e1a05000 	mov	r5, r0
   16bd4:	e1a08001 	mov	r8, r1
   16bd8:	e1a07002 	mov	r7, r2
   16bdc:	0a000003 	beq	16bf0 <USBHandleStandardRequest+0x30>
   16be0:	e1a0e00f 	mov	lr, pc
   16be4:	e12fff13 	bx	r3
   16be8:	e3500000 	cmp	r0, #0	; 0x0
   16bec:	1a00001e 	bne	16c6c <.text+0x6c6c>
   16bf0:	e5d53000 	ldrb	r3, [r5]
   16bf4:	e203401f 	and	r4, r3, #31	; 0x1f
   16bf8:	e3540001 	cmp	r4, #1	; 0x1
   16bfc:	0a00004e 	beq	16d3c <.text+0x6d3c>
   16c00:	e3540002 	cmp	r4, #2	; 0x2
   16c04:	0a000064 	beq	16d9c <.text+0x6d9c>
   16c08:	e3540000 	cmp	r4, #0	; 0x0
   16c0c:	1a000082 	bne	16e1c <.text+0x6e1c>
   16c10:	e5d53001 	ldrb	r3, [r5, #1]
   16c14:	e5971000 	ldr	r1, [r7]
   16c18:	e3530009 	cmp	r3, #9	; 0x9
   16c1c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   16c20:	ea00007d 	b	16e1c <.text+0x6e1c>
   16c24:	00016c4c 	andeq	r6, r1, ip, asr #24
   16c28:	00016e1c 	andeq	r6, r1, ip, lsl lr
   16c2c:	00016e1c 	andeq	r6, r1, ip, lsl lr
   16c30:	00016e1c 	andeq	r6, r1, ip, lsl lr
   16c34:	00016e1c 	andeq	r6, r1, ip, lsl lr
   16c38:	00016c64 	andeq	r6, r1, r4, ror #24
   16c3c:	00016c74 	andeq	r6, r1, r4, ror ip
   16c40:	00016e1c 	andeq	r6, r1, ip, lsl lr
   16c44:	00016c8c 	andeq	r6, r1, ip, lsl #25
   16c48:	00016ca8 	andeq	r6, r1, r8, lsr #25
   16c4c:	e3a03000 	mov	r3, #0	; 0x0
   16c50:	e5c13001 	strb	r3, [r1, #1]
   16c54:	e5c13000 	strb	r3, [r1]
   16c58:	e3a0c001 	mov	ip, #1	; 0x1
   16c5c:	e2833002 	add	r3, r3, #2	; 0x2
   16c60:	ea00000e 	b	16ca0 <.text+0x6ca0>
   16c64:	e5d50002 	ldrb	r0, [r5, #2]
   16c68:	ebfffe41 	bl	16574 <USBHwSetAddress>
   16c6c:	e3a0c001 	mov	ip, #1	; 0x1
   16c70:	ea00006a 	b	16e20 <.text+0x6e20>
   16c74:	e1d510b4 	ldrh	r1, [r5, #4]
   16c78:	e1d500b2 	ldrh	r0, [r5, #2]
   16c7c:	e1a02008 	mov	r2, r8
   16c80:	e1a03007 	mov	r3, r7
   16c84:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   16c88:	eaffffa7 	b	16b2c <USBGetDescriptor>
   16c8c:	e59f319c 	ldr	r3, [pc, #412]	; 16e30 <.text+0x6e30>
   16c90:	e5d32000 	ldrb	r2, [r3]
   16c94:	e3a03001 	mov	r3, #1	; 0x1
   16c98:	e5c12000 	strb	r2, [r1]
   16c9c:	e1a0c003 	mov	ip, r3
   16ca0:	e5883000 	str	r3, [r8]
   16ca4:	ea00005d 	b	16e20 <.text+0x6e20>
   16ca8:	e5d56002 	ldrb	r6, [r5, #2]
   16cac:	e3560000 	cmp	r6, #0	; 0x0
   16cb0:	01a00006 	moveq	r0, r6
   16cb4:	0a00001a 	beq	16d24 <.text+0x6d24>
   16cb8:	e59f3174 	ldr	r3, [pc, #372]	; 16e34 <.text+0x6e34>
   16cbc:	e3a070ff 	mov	r7, #255	; 0xff
   16cc0:	e5934000 	ldr	r4, [r3]
   16cc4:	e1a08007 	mov	r8, r7
   16cc8:	ea000011 	b	16d14 <.text+0x6d14>
   16ccc:	e5d43001 	ldrb	r3, [r4, #1]
   16cd0:	e3530004 	cmp	r3, #4	; 0x4
   16cd4:	05d47003 	ldreqb	r7, [r4, #3]
   16cd8:	0a00000b 	beq	16d0c <.text+0x6d0c>
   16cdc:	e3530005 	cmp	r3, #5	; 0x5
   16ce0:	0a000002 	beq	16cf0 <.text+0x6cf0>
   16ce4:	e3530002 	cmp	r3, #2	; 0x2
   16ce8:	05d48005 	ldreqb	r8, [r4, #5]
   16cec:	ea000006 	b	16d0c <.text+0x6d0c>
   16cf0:	e1580006 	cmp	r8, r6
   16cf4:	03570000 	cmpeq	r7, #0	; 0x0
   16cf8:	05d43004 	ldreqb	r3, [r4, #4]
   16cfc:	05d41005 	ldreqb	r1, [r4, #5]
   16d00:	05d40002 	ldreqb	r0, [r4, #2]
   16d04:	01831401 	orreq	r1, r3, r1, lsl #8
   16d08:	0bfffddd 	bleq	16484 <USBHwEPConfig>
   16d0c:	e5d43000 	ldrb	r3, [r4]
   16d10:	e0844003 	add	r4, r4, r3
   16d14:	e5d43000 	ldrb	r3, [r4]
   16d18:	e3530000 	cmp	r3, #0	; 0x0
   16d1c:	1affffea 	bne	16ccc <.text+0x6ccc>
   16d20:	e3a00001 	mov	r0, #1	; 0x1
   16d24:	ebfffe79 	bl	16710 <USBHwConfigDevice>
   16d28:	e1d520b2 	ldrh	r2, [r5, #2]
   16d2c:	e59f30fc 	ldr	r3, [pc, #252]	; 16e30 <.text+0x6e30>
   16d30:	e3a0c001 	mov	ip, #1	; 0x1
   16d34:	e5c32000 	strb	r2, [r3]
   16d38:	ea000038 	b	16e20 <.text+0x6e20>
   16d3c:	e5d53001 	ldrb	r3, [r5, #1]
   16d40:	e3530000 	cmp	r3, #0	; 0x0
   16d44:	e5972000 	ldr	r2, [r7]
   16d48:	0a000004 	beq	16d60 <.text+0x6d60>
   16d4c:	e353000a 	cmp	r3, #10	; 0xa
   16d50:	0a000007 	beq	16d74 <.text+0x6d74>
   16d54:	e353000b 	cmp	r3, #11	; 0xb
   16d58:	1a00002f 	bne	16e1c <.text+0x6e1c>
   16d5c:	ea000008 	b	16d84 <.text+0x6d84>
   16d60:	e5c23001 	strb	r3, [r2, #1]
   16d64:	e5c23000 	strb	r3, [r2]
   16d68:	e1a0c004 	mov	ip, r4
   16d6c:	e3a03002 	mov	r3, #2	; 0x2
   16d70:	eaffffca 	b	16ca0 <.text+0x6ca0>
   16d74:	e3a03000 	mov	r3, #0	; 0x0
   16d78:	e1a0c004 	mov	ip, r4
   16d7c:	e5c23000 	strb	r3, [r2]
   16d80:	ea000015 	b	16ddc <.text+0x6ddc>
   16d84:	e1d500b2 	ldrh	r0, [r5, #2]
   16d88:	e3500000 	cmp	r0, #0	; 0x0
   16d8c:	03a0c001 	moveq	ip, #1	; 0x1
   16d90:	05880000 	streq	r0, [r8]
   16d94:	0a000021 	beq	16e20 <.text+0x6e20>
   16d98:	ea00001f 	b	16e1c <.text+0x6e1c>
   16d9c:	e5d56001 	ldrb	r6, [r5, #1]
   16da0:	e3560001 	cmp	r6, #1	; 0x1
   16da4:	e5977000 	ldr	r7, [r7]
   16da8:	0a00000d 	beq	16de4 <.text+0x6de4>
   16dac:	3a000002 	bcc	16dbc <.text+0x6dbc>
   16db0:	e3560003 	cmp	r6, #3	; 0x3
   16db4:	1a000018 	bne	16e1c <.text+0x6e1c>
   16db8:	ea000010 	b	16e00 <.text+0x6e00>
   16dbc:	e5d50004 	ldrb	r0, [r5, #4]
   16dc0:	ebfffdf6 	bl	165a0 <USBHwEPGetStatus>
   16dc4:	e1a000a0 	mov	r0, r0, lsr #1
   16dc8:	e2000001 	and	r0, r0, #1	; 0x1
   16dcc:	e3a03000 	mov	r3, #0	; 0x0
   16dd0:	e5c73001 	strb	r3, [r7, #1]
   16dd4:	e5c70000 	strb	r0, [r7]
   16dd8:	e3a0c001 	mov	ip, #1	; 0x1
   16ddc:	e5884000 	str	r4, [r8]
   16de0:	ea00000e 	b	16e20 <.text+0x6e20>
   16de4:	e1d510b2 	ldrh	r1, [r5, #2]
   16de8:	e3510000 	cmp	r1, #0	; 0x0
   16dec:	1a00000a 	bne	16e1c <.text+0x6e1c>
   16df0:	e5d50004 	ldrb	r0, [r5, #4]
   16df4:	ebfffdf2 	bl	165c4 <USBHwEPStall>
   16df8:	e1a0c006 	mov	ip, r6
   16dfc:	ea000007 	b	16e20 <.text+0x6e20>
   16e00:	e1d530b2 	ldrh	r3, [r5, #2]
   16e04:	e3530000 	cmp	r3, #0	; 0x0
   16e08:	1a000003 	bne	16e1c <.text+0x6e1c>
   16e0c:	e5d50004 	ldrb	r0, [r5, #4]
   16e10:	e3a01001 	mov	r1, #1	; 0x1
   16e14:	ebfffdea 	bl	165c4 <USBHwEPStall>
   16e18:	eaffff93 	b	16c6c <.text+0x6c6c>
   16e1c:	e3a0c000 	mov	ip, #0	; 0x0
   16e20:	e1a0000c 	mov	r0, ip
   16e24:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   16e28:	e12fff1e 	bx	lr
   16e2c:	40000d90 	mulmi	r0, r0, sp
   16e30:	40000d94 	mulmi	r0, r4, sp
   16e34:	40000d98 	mulmi	r0, r8, sp

00016e38 <restoreIRQ>:

static inline unsigned __get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  ); 
   16e38:	e10f2000 	mrs	r2, CPSR
  return retval;
}

static inline void __set_cpsr(unsigned val)
{
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );	
   16e3c:	e2000080 	and	r0, r0, #128	; 0x80
   16e40:	e3c23080 	bic	r3, r2, #128	; 0x80
   16e44:	e1833000 	orr	r3, r3, r0
   16e48:	e129f003 	msr	CPSR_fc, r3
}

unsigned disableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | IRQ_MASK);
  return _cpsr;
}

unsigned restoreIRQ(unsigned oldCPSR)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  return _cpsr;
}
   16e4c:	e1a00002 	mov	r0, r2
   16e50:	e12fff1e 	bx	lr

00016e54 <restoreFIQ>:
   16e54:	e10f2000 	mrs	r2, CPSR
   16e58:	e2000040 	and	r0, r0, #64	; 0x40
   16e5c:	e3c23040 	bic	r3, r2, #64	; 0x40
   16e60:	e1833000 	orr	r3, r3, r0
   16e64:	e129f003 	msr	CPSR_fc, r3

unsigned enableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~IRQ_MASK);
  return _cpsr;
}

unsigned disableFIQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr | FIQ_MASK);
  return _cpsr;
}

unsigned restoreFIQ(unsigned oldCPSR)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr((_cpsr & ~FIQ_MASK) | (oldCPSR & FIQ_MASK));
  return _cpsr;
}
   16e68:	e1a00002 	mov	r0, r2
   16e6c:	e12fff1e 	bx	lr

00016e70 <disableFIQ>:
   16e70:	e10f0000 	mrs	r0, CPSR
   16e74:	e3803040 	orr	r3, r0, #64	; 0x40
   16e78:	e129f003 	msr	CPSR_fc, r3
   16e7c:	e12fff1e 	bx	lr

00016e80 <enableFIQ>:
   16e80:	e10f0000 	mrs	r0, CPSR
   16e84:	e3c03040 	bic	r3, r0, #64	; 0x40
   16e88:	e129f003 	msr	CPSR_fc, r3

unsigned enableFIQ(void)
{
  unsigned _cpsr;

  _cpsr = __get_cpsr();
  __set_cpsr(_cpsr & ~FIQ_MASK);
  return _cpsr;
}
   16e8c:	e12fff1e 	bx	lr

00016e90 <disableIRQ>:
   16e90:	e10f0000 	mrs	r0, CPSR
   16e94:	e3803080 	orr	r3, r0, #128	; 0x80
   16e98:	e129f003 	msr	CPSR_fc, r3
   16e9c:	e12fff1e 	bx	lr

00016ea0 <enableIRQ>:
   16ea0:	e10f0000 	mrs	r0, CPSR
   16ea4:	e3c03080 	bic	r3, r0, #128	; 0x80
   16ea8:	e129f003 	msr	CPSR_fc, r3
   16eac:	e12fff1e 	bx	lr

00016eb0 <free>:
   16eb0:	e59f3014 	ldr	r3, [pc, #20]	; 16ecc <.text+0x6ecc>
   16eb4:	e1a01000 	mov	r1, r0
   16eb8:	e52de004 	str	lr, [sp, #-4]!
   16ebc:	e5930000 	ldr	r0, [r3]
   16ec0:	eb00025c 	bl	17838 <_free_r>
   16ec4:	e49de004 	ldr	lr, [sp], #4
   16ec8:	e12fff1e 	bx	lr
   16ecc:	400004a0 	andmi	r0, r0, r0, lsr #9

00016ed0 <malloc>:
   16ed0:	e59f3014 	ldr	r3, [pc, #20]	; 16eec <.text+0x6eec>
   16ed4:	e1a01000 	mov	r1, r0
   16ed8:	e52de004 	str	lr, [sp, #-4]!
   16edc:	e5930000 	ldr	r0, [r3]
   16ee0:	eb000002 	bl	16ef0 <_malloc_r>
   16ee4:	e49de004 	ldr	lr, [sp], #4
   16ee8:	e12fff1e 	bx	lr
   16eec:	400004a0 	andmi	r0, r0, r0, lsr #9

00016ef0 <_malloc_r>:
   16ef0:	e281300b 	add	r3, r1, #11	; 0xb
   16ef4:	e3530016 	cmp	r3, #22	; 0x16
   16ef8:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16efc:	93a08010 	movls	r8, #16	; 0x10
   16f00:	83c38007 	bichi	r8, r3, #7	; 0x7
   16f04:	e1580001 	cmp	r8, r1
   16f08:	23a03000 	movcs	r3, #0	; 0x0
   16f0c:	33a03001 	movcc	r3, #1	; 0x1
   16f10:	e1933fa8 	orrs	r3, r3, r8, lsr #31
   16f14:	e1a0a000 	mov	sl, r0
   16f18:	13a0300c 	movne	r3, #12	; 0xc
   16f1c:	13a00000 	movne	r0, #0	; 0x0
   16f20:	158a3000 	strne	r3, [sl]
   16f24:	1a00018a 	bne	17554 <_malloc_r+0x664>
   16f28:	e1a0000a 	mov	r0, sl
   16f2c:	eb0001a0 	bl	175b4 <__malloc_lock>
   16f30:	e3580f7e 	cmp	r8, #504	; 0x1f8
   16f34:	2a000011 	bcs	16f80 <_malloc_r+0x90>
   16f38:	e59f361c 	ldr	r3, [pc, #1564]	; 1755c <.text+0x755c>
   16f3c:	e1a021a8 	mov	r2, r8, lsr #3
   16f40:	e0833182 	add	r3, r3, r2, lsl #3
   16f44:	e593400c 	ldr	r4, [r3, #12]
   16f48:	e1540003 	cmp	r4, r3
   16f4c:	1a000003 	bne	16f60 <_malloc_r+0x70>
   16f50:	e2843008 	add	r3, r4, #8	; 0x8
   16f54:	e593400c 	ldr	r4, [r3, #12]
   16f58:	e1540003 	cmp	r4, r3
   16f5c:	0a000005 	beq	16f78 <_malloc_r+0x88>
   16f60:	e5943004 	ldr	r3, [r4, #4]
   16f64:	e3c33003 	bic	r3, r3, #3	; 0x3
   16f68:	e0843003 	add	r3, r4, r3
   16f6c:	e5932004 	ldr	r2, [r3, #4]
   16f70:	e594000c 	ldr	r0, [r4, #12]
   16f74:	ea00016e 	b	17534 <_malloc_r+0x644>
   16f78:	e2825002 	add	r5, r2, #2	; 0x2
   16f7c:	ea00002a 	b	1702c <_malloc_r+0x13c>
   16f80:	e1b024a8 	movs	r2, r8, lsr #9
   16f84:	01a021a8 	moveq	r2, r8, lsr #3
   16f88:	0a000017 	beq	16fec <_malloc_r+0xfc>
   16f8c:	e3520004 	cmp	r2, #4	; 0x4
   16f90:	91a03328 	movls	r3, r8, lsr #6
   16f94:	92832038 	addls	r2, r3, #56	; 0x38
   16f98:	9a000013 	bls	16fec <_malloc_r+0xfc>
   16f9c:	e3520014 	cmp	r2, #20	; 0x14
   16fa0:	9282205b 	addls	r2, r2, #91	; 0x5b
   16fa4:	9a000010 	bls	16fec <_malloc_r+0xfc>
   16fa8:	e3520054 	cmp	r2, #84	; 0x54
   16fac:	91a03628 	movls	r3, r8, lsr #12
   16fb0:	9283206e 	addls	r2, r3, #110	; 0x6e
   16fb4:	9a00000c 	bls	16fec <_malloc_r+0xfc>
   16fb8:	e3520f55 	cmp	r2, #340	; 0x154
   16fbc:	91a037a8 	movls	r3, r8, lsr #15
   16fc0:	92832077 	addls	r2, r3, #119	; 0x77
   16fc4:	9a000008 	bls	16fec <_malloc_r+0xfc>
   16fc8:	e59f3590 	ldr	r3, [pc, #1424]	; 17560 <.text+0x7560>
   16fcc:	e1520003 	cmp	r2, r3
   16fd0:	83a0207e 	movhi	r2, #126	; 0x7e
   16fd4:	8a000004 	bhi	16fec <_malloc_r+0xfc>
   16fd8:	ea000001 	b	16fe4 <_malloc_r+0xf4>
   16fdc:	e2422001 	sub	r2, r2, #1	; 0x1
   16fe0:	ea000010 	b	17028 <_malloc_r+0x138>
   16fe4:	e1a03928 	mov	r3, r8, lsr #18
   16fe8:	e283207c 	add	r2, r3, #124	; 0x7c
   16fec:	e59f3568 	ldr	r3, [pc, #1384]	; 1755c <.text+0x755c>
   16ff0:	e083c182 	add	ip, r3, r2, lsl #3
   16ff4:	e59c400c 	ldr	r4, [ip, #12]
   16ff8:	ea000008 	b	17020 <_malloc_r+0x130>
   16ffc:	e5943004 	ldr	r3, [r4, #4]
   17000:	e3c33003 	bic	r3, r3, #3	; 0x3
   17004:	e0681003 	rsb	r1, r8, r3
   17008:	e351000f 	cmp	r1, #15	; 0xf
   1700c:	cafffff2 	bgt	16fdc <_malloc_r+0xec>
   17010:	e3510000 	cmp	r1, #0	; 0x0
   17014:	e594000c 	ldr	r0, [r4, #12]
   17018:	aa000143 	bge	1752c <_malloc_r+0x63c>
   1701c:	e1a04000 	mov	r4, r0
   17020:	e154000c 	cmp	r4, ip
   17024:	1afffff4 	bne	16ffc <_malloc_r+0x10c>
   17028:	e2825001 	add	r5, r2, #1	; 0x1
   1702c:	e59fb528 	ldr	fp, [pc, #1320]	; 1755c <.text+0x755c>
   17030:	e28b7008 	add	r7, fp, #8	; 0x8
   17034:	e5974008 	ldr	r4, [r7, #8]
   17038:	e1540007 	cmp	r4, r7
   1703c:	0a000054 	beq	17194 <_malloc_r+0x2a4>
   17040:	e5943004 	ldr	r3, [r4, #4]
   17044:	e3c32003 	bic	r2, r3, #3	; 0x3
   17048:	e0680002 	rsb	r0, r8, r2
   1704c:	e350000f 	cmp	r0, #15	; 0xf
   17050:	da000009 	ble	1707c <_malloc_r+0x18c>
   17054:	e0842008 	add	r2, r4, r8
   17058:	e3883001 	orr	r3, r8, #1	; 0x1
   1705c:	e3801001 	orr	r1, r0, #1	; 0x1
   17060:	e5843004 	str	r3, [r4, #4]
   17064:	e587200c 	str	r2, [r7, #12]
   17068:	e5872008 	str	r2, [r7, #8]
   1706c:	e7820000 	str	r0, [r2, r0]
   17070:	e9820082 	stmib	r2, {r1, r7}
   17074:	e582700c 	str	r7, [r2, #12]
   17078:	ea000132 	b	17548 <_malloc_r+0x658>
   1707c:	e3500000 	cmp	r0, #0	; 0x0
   17080:	e587700c 	str	r7, [r7, #12]
   17084:	e5877008 	str	r7, [r7, #8]
   17088:	a0842002 	addge	r2, r4, r2
   1708c:	a5923004 	ldrge	r3, [r2, #4]
   17090:	a3833001 	orrge	r3, r3, #1	; 0x1
   17094:	a5823004 	strge	r3, [r2, #4]
   17098:	aa00012a 	bge	17548 <_malloc_r+0x658>
   1709c:	e3520c02 	cmp	r2, #512	; 0x200
   170a0:	2a00000c 	bcs	170d8 <_malloc_r+0x1e8>
   170a4:	e1a011a2 	mov	r1, r2, lsr #3
   170a8:	e59b2004 	ldr	r2, [fp, #4]
   170ac:	e1a00121 	mov	r0, r1, lsr #2
   170b0:	e3a03001 	mov	r3, #1	; 0x1
   170b4:	e1822013 	orr	r2, r2, r3, lsl r0
   170b8:	e08b1181 	add	r1, fp, r1, lsl #3
   170bc:	e5913008 	ldr	r3, [r1, #8]
   170c0:	e584100c 	str	r1, [r4, #12]
   170c4:	e5843008 	str	r3, [r4, #8]
   170c8:	e58b2004 	str	r2, [fp, #4]
   170cc:	e583400c 	str	r4, [r3, #12]
   170d0:	e5814008 	str	r4, [r1, #8]
   170d4:	ea00002e 	b	17194 <_malloc_r+0x2a4>
   170d8:	e1b014a2 	movs	r1, r2, lsr #9
   170dc:	01a011a2 	moveq	r1, r2, lsr #3
   170e0:	0a000013 	beq	17134 <_malloc_r+0x244>
   170e4:	e3510004 	cmp	r1, #4	; 0x4
   170e8:	91a03322 	movls	r3, r2, lsr #6
   170ec:	92831038 	addls	r1, r3, #56	; 0x38
   170f0:	9a00000f 	bls	17134 <_malloc_r+0x244>
   170f4:	e3510014 	cmp	r1, #20	; 0x14
   170f8:	9281105b 	addls	r1, r1, #91	; 0x5b
   170fc:	9a00000c 	bls	17134 <_malloc_r+0x244>
   17100:	e3510054 	cmp	r1, #84	; 0x54
   17104:	91a03622 	movls	r3, r2, lsr #12
   17108:	9283106e 	addls	r1, r3, #110	; 0x6e
   1710c:	9a000008 	bls	17134 <_malloc_r+0x244>
   17110:	e3510f55 	cmp	r1, #340	; 0x154
   17114:	91a037a2 	movls	r3, r2, lsr #15
   17118:	92831077 	addls	r1, r3, #119	; 0x77
   1711c:	9a000004 	bls	17134 <_malloc_r+0x244>
   17120:	e59f3438 	ldr	r3, [pc, #1080]	; 17560 <.text+0x7560>
   17124:	e1510003 	cmp	r1, r3
   17128:	91a03922 	movls	r3, r2, lsr #18
   1712c:	83a0107e 	movhi	r1, #126	; 0x7e
   17130:	9283107c 	addls	r1, r3, #124	; 0x7c
   17134:	e08b0181 	add	r0, fp, r1, lsl #3
   17138:	e590c008 	ldr	ip, [r0, #8]
   1713c:	e15c0000 	cmp	ip, r0
   17140:	1a00000a 	bne	17170 <_malloc_r+0x280>
   17144:	e59f0410 	ldr	r0, [pc, #1040]	; 1755c <.text+0x755c>
   17148:	e5902004 	ldr	r2, [r0, #4]
   1714c:	e1a01121 	mov	r1, r1, lsr #2
   17150:	e3a03001 	mov	r3, #1	; 0x1
   17154:	e1822113 	orr	r2, r2, r3, lsl r1
   17158:	e1a0e00c 	mov	lr, ip
   1715c:	e5802004 	str	r2, [r0, #4]
   17160:	ea000007 	b	17184 <_malloc_r+0x294>
   17164:	e59cc008 	ldr	ip, [ip, #8]
   17168:	e15c0000 	cmp	ip, r0
   1716c:	0a000003 	beq	17180 <_malloc_r+0x290>
   17170:	e59c3004 	ldr	r3, [ip, #4]
   17174:	e3c33003 	bic	r3, r3, #3	; 0x3
   17178:	e1520003 	cmp	r2, r3
   1717c:	3afffff8 	bcc	17164 <_malloc_r+0x274>
   17180:	e59ce00c 	ldr	lr, [ip, #12]
   17184:	e584e00c 	str	lr, [r4, #12]
   17188:	e584c008 	str	ip, [r4, #8]
   1718c:	e58c400c 	str	r4, [ip, #12]
   17190:	e58e4008 	str	r4, [lr, #8]
   17194:	e3550000 	cmp	r5, #0	; 0x0
   17198:	e2853003 	add	r3, r5, #3	; 0x3
   1719c:	a1a03005 	movge	r3, r5
   171a0:	e1a03143 	mov	r3, r3, asr #2
   171a4:	e3a02001 	mov	r2, #1	; 0x1
   171a8:	e1a02312 	mov	r2, r2, lsl r3
   171ac:	e59f93a8 	ldr	r9, [pc, #936]	; 1755c <.text+0x755c>
   171b0:	e5991004 	ldr	r1, [r9, #4]
   171b4:	e1520001 	cmp	r2, r1
   171b8:	8a000037 	bhi	1729c <_malloc_r+0x3ac>
   171bc:	e1120001 	tst	r2, r1
   171c0:	01a02082 	moveq	r2, r2, lsl #1
   171c4:	03c53003 	biceq	r3, r5, #3	; 0x3
   171c8:	0a000001 	beq	171d4 <_malloc_r+0x2e4>
   171cc:	ea000004 	b	171e4 <_malloc_r+0x2f4>
   171d0:	e1a02082 	mov	r2, r2, lsl #1
   171d4:	e1120001 	tst	r2, r1
   171d8:	e2833004 	add	r3, r3, #4	; 0x4
   171dc:	0afffffb 	beq	171d0 <_malloc_r+0x2e0>
   171e0:	e1a05003 	mov	r5, r3
   171e4:	e08b6185 	add	r6, fp, r5, lsl #3
   171e8:	e1a0e005 	mov	lr, r5
   171ec:	e1a01006 	mov	r1, r6
   171f0:	e591400c 	ldr	r4, [r1, #12]
   171f4:	ea000008 	b	1721c <_malloc_r+0x32c>
   171f8:	e5943004 	ldr	r3, [r4, #4]
   171fc:	e3c33003 	bic	r3, r3, #3	; 0x3
   17200:	e068c003 	rsb	ip, r8, r3
   17204:	e35c000f 	cmp	ip, #15	; 0xf
   17208:	ca0000ad 	bgt	174c4 <_malloc_r+0x5d4>
   1720c:	e35c0000 	cmp	ip, #0	; 0x0
   17210:	e594000c 	ldr	r0, [r4, #12]
   17214:	aa0000b9 	bge	17500 <_malloc_r+0x610>
   17218:	e1a04000 	mov	r4, r0
   1721c:	e1540001 	cmp	r4, r1
   17220:	1afffff4 	bne	171f8 <_malloc_r+0x308>
   17224:	e28ee001 	add	lr, lr, #1	; 0x1
   17228:	e31e0003 	tst	lr, #3	; 0x3
   1722c:	12841008 	addne	r1, r4, #8	; 0x8
   17230:	1affffee 	bne	171f0 <_malloc_r+0x300>
   17234:	e1a00005 	mov	r0, r5
   17238:	e1a01006 	mov	r1, r6
   1723c:	e3100003 	tst	r0, #3	; 0x3
   17240:	e2411008 	sub	r1, r1, #8	; 0x8
   17244:	e2400001 	sub	r0, r0, #1	; 0x1
   17248:	0a00000f 	beq	1728c <_malloc_r+0x39c>
   1724c:	e5913008 	ldr	r3, [r1, #8]
   17250:	e1530001 	cmp	r3, r1
   17254:	0afffff8 	beq	1723c <_malloc_r+0x34c>
   17258:	e5993004 	ldr	r3, [r9, #4]
   1725c:	e1a02082 	mov	r2, r2, lsl #1
   17260:	e1520003 	cmp	r2, r3
   17264:	8a00000c 	bhi	1729c <_malloc_r+0x3ac>
   17268:	e3520000 	cmp	r2, #0	; 0x0
   1726c:	0a00000a 	beq	1729c <_malloc_r+0x3ac>
   17270:	e1a0500e 	mov	r5, lr
   17274:	ea000001 	b	17280 <_malloc_r+0x390>
   17278:	e2855004 	add	r5, r5, #4	; 0x4
   1727c:	e1a02082 	mov	r2, r2, lsl #1
   17280:	e1120003 	tst	r2, r3
   17284:	0afffffb 	beq	17278 <_malloc_r+0x388>
   17288:	eaffffd5 	b	171e4 <_malloc_r+0x2f4>
   1728c:	e5993004 	ldr	r3, [r9, #4]
   17290:	e1c33002 	bic	r3, r3, r2
   17294:	e5893004 	str	r3, [r9, #4]
   17298:	eaffffee 	b	17258 <_malloc_r+0x368>
   1729c:	e5996008 	ldr	r6, [r9, #8]
   172a0:	e5963004 	ldr	r3, [r6, #4]
   172a4:	e3c37003 	bic	r7, r3, #3	; 0x3
   172a8:	e0681007 	rsb	r1, r8, r7
   172ac:	e351000f 	cmp	r1, #15	; 0xf
   172b0:	c3a03000 	movgt	r3, #0	; 0x0
   172b4:	d3a03001 	movle	r3, #1	; 0x1
   172b8:	e1570008 	cmp	r7, r8
   172bc:	33833001 	orrcc	r3, r3, #1	; 0x1
   172c0:	e3530000 	cmp	r3, #0	; 0x0
   172c4:	0a000070 	beq	1748c <_malloc_r+0x59c>
   172c8:	e59f3294 	ldr	r3, [pc, #660]	; 17564 <.text+0x7564>
   172cc:	e5932000 	ldr	r2, [r3]
   172d0:	e59f3290 	ldr	r3, [pc, #656]	; 17568 <.text+0x7568>
   172d4:	e5933000 	ldr	r3, [r3]
   172d8:	e2822010 	add	r2, r2, #16	; 0x10
   172dc:	e3730001 	cmn	r3, #1	; 0x1
   172e0:	e0884002 	add	r4, r8, r2
   172e4:	12843eff 	addne	r3, r4, #4080	; 0xff0
   172e8:	1283300f 	addne	r3, r3, #15	; 0xf
   172ec:	13c34eff 	bicne	r4, r3, #4080	; 0xff0
   172f0:	13c4400f 	bicne	r4, r4, #15	; 0xf
   172f4:	e1a0000a 	mov	r0, sl
   172f8:	e1a01004 	mov	r1, r4
   172fc:	ebffeb6f 	bl	120c0 <_sbrk_r>
   17300:	e3700001 	cmn	r0, #1	; 0x1
   17304:	0a000051 	beq	17450 <_malloc_r+0x560>
   17308:	e086c007 	add	ip, r6, r7
   1730c:	e150000c 	cmp	r0, ip
   17310:	e1a05000 	mov	r5, r0
   17314:	2a000002 	bcs	17324 <_malloc_r+0x434>
   17318:	e1560009 	cmp	r6, r9
   1731c:	1a00004b 	bne	17450 <_malloc_r+0x560>
   17320:	ea000062 	b	174b0 <_malloc_r+0x5c0>
   17324:	e59f2240 	ldr	r2, [pc, #576]	; 1756c <.text+0x756c>
   17328:	e5923000 	ldr	r3, [r2]
   1732c:	e0841003 	add	r1, r4, r3
   17330:	e5821000 	str	r1, [r2]
   17334:	1a000007 	bne	17358 <_malloc_r+0x468>
   17338:	e1a03a00 	mov	r3, r0, lsl #20
   1733c:	e1a03a23 	mov	r3, r3, lsr #20
   17340:	e3530000 	cmp	r3, #0	; 0x0
   17344:	00843007 	addeq	r3, r4, r7
   17348:	05992008 	ldreq	r2, [r9, #8]
   1734c:	03833001 	orreq	r3, r3, #1	; 0x1
   17350:	05823004 	streq	r3, [r2, #4]
   17354:	0a000033 	beq	17428 <_malloc_r+0x538>
   17358:	e59f2208 	ldr	r2, [pc, #520]	; 17568 <.text+0x7568>
   1735c:	e5923000 	ldr	r3, [r2]
   17360:	e3730001 	cmn	r3, #1	; 0x1
   17364:	106c3000 	rsbne	r3, ip, r0
   17368:	159f21fc 	ldrne	r2, [pc, #508]	; 1756c <.text+0x756c>
   1736c:	10813003 	addne	r3, r1, r3
   17370:	05820000 	streq	r0, [r2]
   17374:	15823000 	strne	r3, [r2]
   17378:	e2103007 	ands	r3, r0, #7	; 0x7
   1737c:	12631008 	rsbne	r1, r3, #8	; 0x8
   17380:	10805001 	addne	r5, r0, r1
   17384:	01a01003 	moveq	r1, r3
   17388:	e0853004 	add	r3, r5, r4
   1738c:	e1a03a03 	mov	r3, r3, lsl #20
   17390:	e1a03a23 	mov	r3, r3, lsr #20
   17394:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
   17398:	e0814003 	add	r4, r1, r3
   1739c:	e1a01004 	mov	r1, r4
   173a0:	e1a0000a 	mov	r0, sl
   173a4:	ebffeb45 	bl	120c0 <_sbrk_r>
   173a8:	e59f31bc 	ldr	r3, [pc, #444]	; 1756c <.text+0x756c>
   173ac:	e3700001 	cmn	r0, #1	; 0x1
   173b0:	01a00005 	moveq	r0, r5
   173b4:	03a04000 	moveq	r4, #0	; 0x0
   173b8:	e5931000 	ldr	r1, [r3]
   173bc:	e0652000 	rsb	r2, r5, r0
   173c0:	e0822004 	add	r2, r2, r4
   173c4:	e0811004 	add	r1, r1, r4
   173c8:	e3822001 	orr	r2, r2, #1	; 0x1
   173cc:	e1560009 	cmp	r6, r9
   173d0:	e5831000 	str	r1, [r3]
   173d4:	e5852004 	str	r2, [r5, #4]
   173d8:	e5895008 	str	r5, [r9, #8]
   173dc:	0a000011 	beq	17428 <_malloc_r+0x538>
   173e0:	e357000f 	cmp	r7, #15	; 0xf
   173e4:	93a03001 	movls	r3, #1	; 0x1
   173e8:	95853004 	strls	r3, [r5, #4]
   173ec:	9a000017 	bls	17450 <_malloc_r+0x560>
   173f0:	e5963004 	ldr	r3, [r6, #4]
   173f4:	e247200c 	sub	r2, r7, #12	; 0xc
   173f8:	e3c22007 	bic	r2, r2, #7	; 0x7
   173fc:	e2033001 	and	r3, r3, #1	; 0x1
   17400:	e1833002 	orr	r3, r3, r2
   17404:	e3a01005 	mov	r1, #5	; 0x5
   17408:	e352000f 	cmp	r2, #15	; 0xf
   1740c:	e0862002 	add	r2, r6, r2
   17410:	e5863004 	str	r3, [r6, #4]
   17414:	e5821008 	str	r1, [r2, #8]
   17418:	e5821004 	str	r1, [r2, #4]
   1741c:	82861008 	addhi	r1, r6, #8	; 0x8
   17420:	81a0000a 	movhi	r0, sl
   17424:	8b000103 	blhi	17838 <_free_r>
   17428:	e59f1140 	ldr	r1, [pc, #320]	; 17570 <.text+0x7570>
   1742c:	e59f3138 	ldr	r3, [pc, #312]	; 1756c <.text+0x756c>
   17430:	e5932000 	ldr	r2, [r3]
   17434:	e5913000 	ldr	r3, [r1]
   17438:	e1520003 	cmp	r2, r3
   1743c:	85812000 	strhi	r2, [r1]
   17440:	e59f112c 	ldr	r1, [pc, #300]	; 17574 <.text+0x7574>
   17444:	e5913000 	ldr	r3, [r1]
   17448:	e1520003 	cmp	r2, r3
   1744c:	85812000 	strhi	r2, [r1]
   17450:	e5993008 	ldr	r3, [r9, #8]
   17454:	e5932004 	ldr	r2, [r3, #4]
   17458:	e3c22003 	bic	r2, r2, #3	; 0x3
   1745c:	e0681002 	rsb	r1, r8, r2
   17460:	e351000f 	cmp	r1, #15	; 0xf
   17464:	c3a03000 	movgt	r3, #0	; 0x0
   17468:	d3a03001 	movle	r3, #1	; 0x1
   1746c:	e1520008 	cmp	r2, r8
   17470:	33833001 	orrcc	r3, r3, #1	; 0x1
   17474:	e3530000 	cmp	r3, #0	; 0x0
   17478:	0a000003 	beq	1748c <_malloc_r+0x59c>
   1747c:	e1a0000a 	mov	r0, sl
   17480:	eb00004c 	bl	175b8 <__malloc_unlock>
   17484:	e3a00000 	mov	r0, #0	; 0x0
   17488:	ea000031 	b	17554 <_malloc_r+0x664>
   1748c:	e5994008 	ldr	r4, [r9, #8]
   17490:	e3811001 	orr	r1, r1, #1	; 0x1
   17494:	e0842008 	add	r2, r4, r8
   17498:	e3883001 	orr	r3, r8, #1	; 0x1
   1749c:	e1a0000a 	mov	r0, sl
   174a0:	e5843004 	str	r3, [r4, #4]
   174a4:	e5892008 	str	r2, [r9, #8]
   174a8:	e5821004 	str	r1, [r2, #4]
   174ac:	ea000026 	b	1754c <_malloc_r+0x65c>
   174b0:	e59f20b4 	ldr	r2, [pc, #180]	; 1756c <.text+0x756c>
   174b4:	e5923000 	ldr	r3, [r2]
   174b8:	e0841003 	add	r1, r4, r3
   174bc:	e5821000 	str	r1, [r2]
   174c0:	eaffffa4 	b	17358 <_malloc_r+0x468>
   174c4:	e3883001 	orr	r3, r8, #1	; 0x1
   174c8:	e594000c 	ldr	r0, [r4, #12]
   174cc:	e5843004 	str	r3, [r4, #4]
   174d0:	e0843008 	add	r3, r4, r8
   174d4:	e5b41008 	ldr	r1, [r4, #8]!
   174d8:	e38c2001 	orr	r2, ip, #1	; 0x1
   174dc:	e5801008 	str	r1, [r0, #8]
   174e0:	e581000c 	str	r0, [r1, #12]
   174e4:	e1a0000a 	mov	r0, sl
   174e8:	e5873008 	str	r3, [r7, #8]
   174ec:	e587300c 	str	r3, [r7, #12]
   174f0:	e783c00c 	str	ip, [r3, ip]
   174f4:	e9830084 	stmib	r3, {r2, r7}
   174f8:	e583700c 	str	r7, [r3, #12]
   174fc:	ea000007 	b	17520 <_malloc_r+0x630>
   17500:	e0843003 	add	r3, r4, r3
   17504:	e5932004 	ldr	r2, [r3, #4]
   17508:	e5b41008 	ldr	r1, [r4, #8]!
   1750c:	e3822001 	orr	r2, r2, #1	; 0x1
   17510:	e5832004 	str	r2, [r3, #4]
   17514:	e5801008 	str	r1, [r0, #8]
   17518:	e581000c 	str	r0, [r1, #12]
   1751c:	e1a0000a 	mov	r0, sl
   17520:	eb000024 	bl	175b8 <__malloc_unlock>
   17524:	e1a00004 	mov	r0, r4
   17528:	ea000009 	b	17554 <_malloc_r+0x664>
   1752c:	e0843003 	add	r3, r4, r3
   17530:	e5932004 	ldr	r2, [r3, #4]
   17534:	e5941008 	ldr	r1, [r4, #8]
   17538:	e3822001 	orr	r2, r2, #1	; 0x1
   1753c:	e5801008 	str	r1, [r0, #8]
   17540:	e5832004 	str	r2, [r3, #4]
   17544:	e581000c 	str	r0, [r1, #12]
   17548:	e1a0000a 	mov	r0, sl
   1754c:	eb000019 	bl	175b8 <__malloc_unlock>
   17550:	e2840008 	add	r0, r4, #8	; 0x8
   17554:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17558:	e12fff1e 	bx	lr
   1755c:	40000090 	mulmi	r0, r0, r0
   17560:	00000554 	andeq	r0, r0, r4, asr r5
   17564:	40000d9c 	mulmi	r0, ip, sp
   17568:	4000049c 	mulmi	r0, ip, r4
   1756c:	40000da8 	andmi	r0, r0, r8, lsr #27
   17570:	40000da0 	andmi	r0, r0, r0, lsr #27
   17574:	40000da4 	andmi	r0, r0, r4, lsr #27

00017578 <memcpy>:
   17578:	e3a0c000 	mov	ip, #0	; 0x0
   1757c:	ea000002 	b	1758c <memcpy+0x14>
   17580:	e7dc3001 	ldrb	r3, [ip, r1]
   17584:	e7cc3000 	strb	r3, [ip, r0]
   17588:	e28cc001 	add	ip, ip, #1	; 0x1
   1758c:	e2522001 	subs	r2, r2, #1	; 0x1
   17590:	2afffffa 	bcs	17580 <memcpy+0x8>
   17594:	e12fff1e 	bx	lr

00017598 <memset>:
   17598:	e3a03000 	mov	r3, #0	; 0x0
   1759c:	ea000001 	b	175a8 <memset+0x10>
   175a0:	e7c31000 	strb	r1, [r3, r0]
   175a4:	e2833001 	add	r3, r3, #1	; 0x1
   175a8:	e2522001 	subs	r2, r2, #1	; 0x1
   175ac:	2afffffb 	bcs	175a0 <memset+0x8>
   175b0:	e12fff1e 	bx	lr

000175b4 <__malloc_lock>:
   175b4:	e12fff1e 	bx	lr

000175b8 <__malloc_unlock>:
   175b8:	e12fff1e 	bx	lr

000175bc <strchr>:
   175bc:	e20110ff 	and	r1, r1, #255	; 0xff
   175c0:	ea000000 	b	175c8 <strchr+0xc>
   175c4:	e2800001 	add	r0, r0, #1	; 0x1
   175c8:	e5d03000 	ldrb	r3, [r0]
   175cc:	e3530000 	cmp	r3, #0	; 0x0
   175d0:	0a000002 	beq	175e0 <strchr+0x24>
   175d4:	e1530001 	cmp	r3, r1
   175d8:	1afffff9 	bne	175c4 <strchr+0x8>
   175dc:	e12fff1e 	bx	lr
   175e0:	e3510000 	cmp	r1, #0	; 0x0
   175e4:	13a00000 	movne	r0, #0	; 0x0
   175e8:	e12fff1e 	bx	lr

000175ec <strcmp>:
   175ec:	ea000000 	b	175f4 <strcmp+0x8>
   175f0:	e2811001 	add	r1, r1, #1	; 0x1
   175f4:	e5d02000 	ldrb	r2, [r0]
   175f8:	e3520000 	cmp	r2, #0	; 0x0
   175fc:	e2800001 	add	r0, r0, #1	; 0x1
   17600:	0a000002 	beq	17610 <strcmp+0x24>
   17604:	e5d13000 	ldrb	r3, [r1]
   17608:	e1530002 	cmp	r3, r2
   1760c:	0afffff7 	beq	175f0 <strcmp+0x4>
   17610:	e5d10000 	ldrb	r0, [r1]
   17614:	e0600002 	rsb	r0, r0, r2
   17618:	e12fff1e 	bx	lr

0001761c <strcpy>:
   1761c:	e1a02000 	mov	r2, r0
   17620:	e4d13001 	ldrb	r3, [r1], #1
   17624:	e3530000 	cmp	r3, #0	; 0x0
   17628:	e4c23001 	strb	r3, [r2], #1
   1762c:	1afffffb 	bne	17620 <strcpy+0x4>
   17630:	e12fff1e 	bx	lr

00017634 <strlen>:
   17634:	e1a02000 	mov	r2, r0
   17638:	ea000000 	b	17640 <strlen+0xc>
   1763c:	e2800001 	add	r0, r0, #1	; 0x1
   17640:	e5d03000 	ldrb	r3, [r0]
   17644:	e3530000 	cmp	r3, #0	; 0x0
   17648:	1afffffb 	bne	1763c <strlen+0x8>
   1764c:	e0620000 	rsb	r0, r2, r0
   17650:	e12fff1e 	bx	lr

00017654 <strncmp>:
   17654:	e3520000 	cmp	r2, #0	; 0x0
   17658:	01a00002 	moveq	r0, r2
   1765c:	012fff1e 	bxeq	lr
   17660:	ea000005 	b	1767c <strncmp+0x28>
   17664:	e3520000 	cmp	r2, #0	; 0x0
   17668:	0a000009 	beq	17694 <strncmp+0x40>
   1766c:	e35c0000 	cmp	ip, #0	; 0x0
   17670:	0a000007 	beq	17694 <strncmp+0x40>
   17674:	e2800001 	add	r0, r0, #1	; 0x1
   17678:	e2811001 	add	r1, r1, #1	; 0x1
   1767c:	e2522001 	subs	r2, r2, #1	; 0x1
   17680:	3a000003 	bcc	17694 <strncmp+0x40>
   17684:	e5d1c000 	ldrb	ip, [r1]
   17688:	e5d03000 	ldrb	r3, [r0]
   1768c:	e15c0003 	cmp	ip, r3
   17690:	0afffff3 	beq	17664 <strncmp+0x10>
   17694:	e5d02000 	ldrb	r2, [r0]
   17698:	e5d13000 	ldrb	r3, [r1]
   1769c:	e0630002 	rsb	r0, r3, r2
   176a0:	e12fff1e 	bx	lr

000176a4 <strncpy>:
   176a4:	e1a0c000 	mov	ip, r0
   176a8:	ea000005 	b	176c4 <strncpy+0x20>
   176ac:	e5d13000 	ldrb	r3, [r1]
   176b0:	e3530000 	cmp	r3, #0	; 0x0
   176b4:	e2422001 	sub	r2, r2, #1	; 0x1
   176b8:	e4cc3001 	strb	r3, [ip], #1
   176bc:	0a000002 	beq	176cc <strncpy+0x28>
   176c0:	e2811001 	add	r1, r1, #1	; 0x1
   176c4:	e3520000 	cmp	r2, #0	; 0x0
   176c8:	1afffff7 	bne	176ac <strncpy+0x8>
   176cc:	e1a0100c 	mov	r1, ip
   176d0:	ea000001 	b	176dc <strncpy+0x38>
   176d4:	e3a03000 	mov	r3, #0	; 0x0
   176d8:	e5413001 	strb	r3, [r1, #-1]
   176dc:	e2422001 	sub	r2, r2, #1	; 0x1
   176e0:	e3720001 	cmn	r2, #1	; 0x1
   176e4:	e2811001 	add	r1, r1, #1	; 0x1
   176e8:	1afffff9 	bne	176d4 <strncpy+0x30>
   176ec:	e12fff1e 	bx	lr

000176f0 <strrchr>:
   176f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
   176f4:	e2515000 	subs	r5, r1, #0	; 0x0
   176f8:	e1a03000 	mov	r3, r0
   176fc:	13a04000 	movne	r4, #0	; 0x0
   17700:	1a000002 	bne	17710 <strrchr+0x20>
   17704:	ea000007 	b	17728 <strrchr+0x38>
   17708:	e1a04000 	mov	r4, r0
   1770c:	e2803001 	add	r3, r0, #1	; 0x1
   17710:	e1a00003 	mov	r0, r3
   17714:	e1a01005 	mov	r1, r5
   17718:	ebffffa7 	bl	175bc <strchr>
   1771c:	e3500000 	cmp	r0, #0	; 0x0
   17720:	1afffff8 	bne	17708 <strrchr+0x18>
   17724:	ea000001 	b	17730 <strrchr+0x40>
   17728:	ebffffa3 	bl	175bc <strchr>
   1772c:	e1a04000 	mov	r4, r0
   17730:	e1a00004 	mov	r0, r4
   17734:	e8bd4030 	ldmia	sp!, {r4, r5, lr}
   17738:	e12fff1e 	bx	lr

0001773c <_malloc_trim_r>:
   1773c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
   17740:	e59f70e4 	ldr	r7, [pc, #228]	; 1782c <.text+0x782c>
   17744:	e1a04001 	mov	r4, r1
   17748:	e1a05000 	mov	r5, r0
   1774c:	ebffff98 	bl	175b4 <__malloc_lock>
   17750:	e5973008 	ldr	r3, [r7, #8]
   17754:	e5933004 	ldr	r3, [r3, #4]
   17758:	e3c36003 	bic	r6, r3, #3	; 0x3
   1775c:	e0644006 	rsb	r4, r4, r6
   17760:	e2844efe 	add	r4, r4, #4064	; 0xfe0
   17764:	e284400f 	add	r4, r4, #15	; 0xf
   17768:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
   1776c:	e3c4400f 	bic	r4, r4, #15	; 0xf
   17770:	e2444a01 	sub	r4, r4, #4096	; 0x1000
   17774:	e3540a01 	cmp	r4, #4096	; 0x1000
   17778:	e3a01000 	mov	r1, #0	; 0x0
   1777c:	e1a00005 	mov	r0, r5
   17780:	ba00001c 	blt	177f8 <_malloc_trim_r+0xbc>
   17784:	ebffea4d 	bl	120c0 <_sbrk_r>
   17788:	e5973008 	ldr	r3, [r7, #8]
   1778c:	e0863003 	add	r3, r6, r3
   17790:	e1500003 	cmp	r0, r3
   17794:	e2641000 	rsb	r1, r4, #0	; 0x0
   17798:	e1a00005 	mov	r0, r5
   1779c:	1a000015 	bne	177f8 <_malloc_trim_r+0xbc>
   177a0:	ebffea46 	bl	120c0 <_sbrk_r>
   177a4:	e0643006 	rsb	r3, r4, r6
   177a8:	e3700001 	cmn	r0, #1	; 0x1
   177ac:	e3a01000 	mov	r1, #0	; 0x0
   177b0:	e59fe078 	ldr	lr, [pc, #120]	; 17830 <.text+0x7830>
   177b4:	e383c001 	orr	ip, r3, #1	; 0x1
   177b8:	e1a00005 	mov	r0, r5
   177bc:	1a000010 	bne	17804 <_malloc_trim_r+0xc8>
   177c0:	ebffea3e 	bl	120c0 <_sbrk_r>
   177c4:	e597c008 	ldr	ip, [r7, #8]
   177c8:	e1a02000 	mov	r2, r0
   177cc:	e06c3002 	rsb	r3, ip, r2
   177d0:	e353000f 	cmp	r3, #15	; 0xf
   177d4:	e1a00005 	mov	r0, r5
   177d8:	e3831001 	orr	r1, r3, #1	; 0x1
   177dc:	da000005 	ble	177f8 <_malloc_trim_r+0xbc>
   177e0:	e59f304c 	ldr	r3, [pc, #76]	; 17834 <.text+0x7834>
   177e4:	e5933000 	ldr	r3, [r3]
   177e8:	e0633002 	rsb	r3, r3, r2
   177ec:	e59f203c 	ldr	r2, [pc, #60]	; 17830 <.text+0x7830>
   177f0:	e58c1004 	str	r1, [ip, #4]
   177f4:	e5823000 	str	r3, [r2]
   177f8:	ebffff6e 	bl	175b8 <__malloc_unlock>
   177fc:	e3a00000 	mov	r0, #0	; 0x0
   17800:	ea000007 	b	17824 <_malloc_trim_r+0xe8>
   17804:	e59e3000 	ldr	r3, [lr]
   17808:	e5972008 	ldr	r2, [r7, #8]
   1780c:	e0643003 	rsb	r3, r4, r3
   17810:	e1a00005 	mov	r0, r5
   17814:	e582c004 	str	ip, [r2, #4]
   17818:	e58e3000 	str	r3, [lr]
   1781c:	ebffff65 	bl	175b8 <__malloc_unlock>
   17820:	e3a00001 	mov	r0, #1	; 0x1
   17824:	e8bd40f0 	ldmia	sp!, {r4, r5, r6, r7, lr}
   17828:	e12fff1e 	bx	lr
   1782c:	40000090 	mulmi	r0, r0, r0
   17830:	40000da8 	andmi	r0, r0, r8, lsr #27
   17834:	4000049c 	mulmi	r0, ip, r4

00017838 <_free_r>:
   17838:	e92d41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1783c:	e2515000 	subs	r5, r1, #0	; 0x0
   17840:	e1a08000 	mov	r8, r0
   17844:	0a00008c 	beq	17a7c <_free_r+0x244>
   17848:	ebffff59 	bl	175b4 <__malloc_lock>
   1784c:	e5153004 	ldr	r3, [r5, #-4]
   17850:	e59f722c 	ldr	r7, [pc, #556]	; 17a84 <.text+0x7a84>
   17854:	e245e008 	sub	lr, r5, #8	; 0x8
   17858:	e3c30001 	bic	r0, r3, #1	; 0x1
   1785c:	e08e4000 	add	r4, lr, r0
   17860:	e5972008 	ldr	r2, [r7, #8]
   17864:	e5941004 	ldr	r1, [r4, #4]
   17868:	e1540002 	cmp	r4, r2
   1786c:	e3c16003 	bic	r6, r1, #3	; 0x3
   17870:	e2031001 	and	r1, r3, #1	; 0x1
   17874:	1a000015 	bne	178d0 <_free_r+0x98>
   17878:	e3510000 	cmp	r1, #0	; 0x0
   1787c:	e0800006 	add	r0, r0, r6
   17880:	1a000006 	bne	178a0 <_free_r+0x68>
   17884:	e5151008 	ldr	r1, [r5, #-8]
   17888:	e061e00e 	rsb	lr, r1, lr
   1788c:	e59e200c 	ldr	r2, [lr, #12]
   17890:	e59e3008 	ldr	r3, [lr, #8]
   17894:	e5823008 	str	r3, [r2, #8]
   17898:	e583200c 	str	r2, [r3, #12]
   1789c:	e0800001 	add	r0, r0, r1
   178a0:	e59f31e0 	ldr	r3, [pc, #480]	; 17a88 <.text+0x7a88>
   178a4:	e5933000 	ldr	r3, [r3]
   178a8:	e1500003 	cmp	r0, r3
   178ac:	e3803001 	orr	r3, r0, #1	; 0x1
   178b0:	e587e008 	str	lr, [r7, #8]
   178b4:	e58e3004 	str	r3, [lr, #4]
   178b8:	3a00006d 	bcc	17a74 <_free_r+0x23c>
   178bc:	e59f31c8 	ldr	r3, [pc, #456]	; 17a8c <.text+0x7a8c>
   178c0:	e1a00008 	mov	r0, r8
   178c4:	e5931000 	ldr	r1, [r3]
   178c8:	ebffff9b 	bl	1773c <_malloc_trim_r>
   178cc:	ea000068 	b	17a74 <_free_r+0x23c>
   178d0:	e3510000 	cmp	r1, #0	; 0x0
   178d4:	e5846004 	str	r6, [r4, #4]
   178d8:	13a01000 	movne	r1, #0	; 0x0
   178dc:	1a000009 	bne	17908 <_free_r+0xd0>
   178e0:	e5152008 	ldr	r2, [r5, #-8]
   178e4:	e062e00e 	rsb	lr, r2, lr
   178e8:	e59ec008 	ldr	ip, [lr, #8]
   178ec:	e2873008 	add	r3, r7, #8	; 0x8
   178f0:	e15c0003 	cmp	ip, r3
   178f4:	159e300c 	ldrne	r3, [lr, #12]
   178f8:	1583c008 	strne	ip, [r3, #8]
   178fc:	158c300c 	strne	r3, [ip, #12]
   17900:	e0800002 	add	r0, r0, r2
   17904:	03a01001 	moveq	r1, #1	; 0x1
   17908:	e0843006 	add	r3, r4, r6
   1790c:	e5933004 	ldr	r3, [r3, #4]
   17910:	e3130001 	tst	r3, #1	; 0x1
   17914:	1a000012 	bne	17964 <_free_r+0x12c>
   17918:	e3510000 	cmp	r1, #0	; 0x0
   1791c:	e0800006 	add	r0, r0, r6
   17920:	1a00000b 	bne	17954 <_free_r+0x11c>
   17924:	e5942008 	ldr	r2, [r4, #8]
   17928:	e59f3160 	ldr	r3, [pc, #352]	; 17a90 <.text+0x7a90>
   1792c:	e1520003 	cmp	r2, r3
   17930:	1a000007 	bne	17954 <_free_r+0x11c>
   17934:	e3803001 	orr	r3, r0, #1	; 0x1
   17938:	e582e00c 	str	lr, [r2, #12]
   1793c:	e582e008 	str	lr, [r2, #8]
   17940:	e78e0000 	str	r0, [lr, r0]
   17944:	e58e3004 	str	r3, [lr, #4]
   17948:	e58e2008 	str	r2, [lr, #8]
   1794c:	e58e200c 	str	r2, [lr, #12]
   17950:	ea000047 	b	17a74 <_free_r+0x23c>
   17954:	e2842008 	add	r2, r4, #8	; 0x8
   17958:	e892000c 	ldmia	r2, {r2, r3}
   1795c:	e5832008 	str	r2, [r3, #8]
   17960:	e582300c 	str	r3, [r2, #12]
   17964:	e3803001 	orr	r3, r0, #1	; 0x1
   17968:	e3510000 	cmp	r1, #0	; 0x0
   1796c:	e58e3004 	str	r3, [lr, #4]
   17970:	e78e0000 	str	r0, [lr, r0]
   17974:	1a00003e 	bne	17a74 <_free_r+0x23c>
   17978:	e3500c02 	cmp	r0, #512	; 0x200
   1797c:	2a00000d 	bcs	179b8 <_free_r+0x180>
   17980:	e1a001a0 	mov	r0, r0, lsr #3
   17984:	e5972004 	ldr	r2, [r7, #4]
   17988:	e1a01120 	mov	r1, r0, lsr #2
   1798c:	e3a03001 	mov	r3, #1	; 0x1
   17990:	e1822113 	orr	r2, r2, r3, lsl r1
   17994:	e59f30e8 	ldr	r3, [pc, #232]	; 17a84 <.text+0x7a84>
   17998:	e0833180 	add	r3, r3, r0, lsl #3
   1799c:	e5931008 	ldr	r1, [r3, #8]
   179a0:	e58e300c 	str	r3, [lr, #12]
   179a4:	e58e1008 	str	r1, [lr, #8]
   179a8:	e5872004 	str	r2, [r7, #4]
   179ac:	e581e00c 	str	lr, [r1, #12]
   179b0:	e583e008 	str	lr, [r3, #8]
   179b4:	ea00002e 	b	17a74 <_free_r+0x23c>
   179b8:	e1b014a0 	movs	r1, r0, lsr #9
   179bc:	01a011a0 	moveq	r1, r0, lsr #3
   179c0:	0a000013 	beq	17a14 <_free_r+0x1dc>
   179c4:	e3510004 	cmp	r1, #4	; 0x4
   179c8:	91a03320 	movls	r3, r0, lsr #6
   179cc:	92831038 	addls	r1, r3, #56	; 0x38
   179d0:	9a00000f 	bls	17a14 <_free_r+0x1dc>
   179d4:	e3510014 	cmp	r1, #20	; 0x14
   179d8:	9281105b 	addls	r1, r1, #91	; 0x5b
   179dc:	9a00000c 	bls	17a14 <_free_r+0x1dc>
   179e0:	e3510054 	cmp	r1, #84	; 0x54
   179e4:	91a03620 	movls	r3, r0, lsr #12
   179e8:	9283106e 	addls	r1, r3, #110	; 0x6e
   179ec:	9a000008 	bls	17a14 <_free_r+0x1dc>
   179f0:	e3510f55 	cmp	r1, #340	; 0x154
   179f4:	91a037a0 	movls	r3, r0, lsr #15
   179f8:	92831077 	addls	r1, r3, #119	; 0x77
   179fc:	9a000004 	bls	17a14 <_free_r+0x1dc>
   17a00:	e59f308c 	ldr	r3, [pc, #140]	; 17a94 <.text+0x7a94>
   17a04:	e1510003 	cmp	r1, r3
   17a08:	91a03920 	movls	r3, r0, lsr #18
   17a0c:	83a0107e 	movhi	r1, #126	; 0x7e
   17a10:	9283107c 	addls	r1, r3, #124	; 0x7c
   17a14:	e59f3068 	ldr	r3, [pc, #104]	; 17a84 <.text+0x7a84>
   17a18:	e0832181 	add	r2, r3, r1, lsl #3
   17a1c:	e592c008 	ldr	ip, [r2, #8]
   17a20:	e15c0002 	cmp	ip, r2
   17a24:	1a000009 	bne	17a50 <_free_r+0x218>
   17a28:	e5973004 	ldr	r3, [r7, #4]
   17a2c:	e3a02001 	mov	r2, #1	; 0x1
   17a30:	e1a01121 	mov	r1, r1, lsr #2
   17a34:	e1833112 	orr	r3, r3, r2, lsl r1
   17a38:	e1a0200c 	mov	r2, ip
   17a3c:	e5873004 	str	r3, [r7, #4]
   17a40:	ea000007 	b	17a64 <_free_r+0x22c>
   17a44:	e59cc008 	ldr	ip, [ip, #8]
   17a48:	e15c0002 	cmp	ip, r2
   17a4c:	0a000003 	beq	17a60 <_free_r+0x228>
   17a50:	e59c3004 	ldr	r3, [ip, #4]
   17a54:	e3c33003 	bic	r3, r3, #3	; 0x3
   17a58:	e1500003 	cmp	r0, r3
   17a5c:	3afffff8 	bcc	17a44 <_free_r+0x20c>
   17a60:	e59c200c 	ldr	r2, [ip, #12]
   17a64:	e58e200c 	str	r2, [lr, #12]
   17a68:	e58ec008 	str	ip, [lr, #8]
   17a6c:	e58ce00c 	str	lr, [ip, #12]
   17a70:	e582e008 	str	lr, [r2, #8]
   17a74:	e1a00008 	mov	r0, r8
   17a78:	ebfffece 	bl	175b8 <__malloc_unlock>
   17a7c:	e8bd41f0 	ldmia	sp!, {r4, r5, r6, r7, r8, lr}
   17a80:	e12fff1e 	bx	lr
   17a84:	40000090 	mulmi	r0, r0, r0
   17a88:	40000498 	mulmi	r0, r8, r4
   17a8c:	40000d9c 	mulmi	r0, ip, sp
   17a90:	40000098 	mulmi	r0, r8, r0
   17a94:	00000554 	andeq	r0, r0, r4, asr r5

00017a98 <__aeabi_uidiv>:
   17a98:	e2512001 	subs	r2, r1, #1	; 0x1
   17a9c:	012fff1e 	bxeq	lr
   17aa0:	3a000036 	bcc	17b80 <__aeabi_uidiv+0xe8>
   17aa4:	e1500001 	cmp	r0, r1
   17aa8:	9a000022 	bls	17b38 <__aeabi_uidiv+0xa0>
   17aac:	e1110002 	tst	r1, r2
   17ab0:	0a000023 	beq	17b44 <__aeabi_uidiv+0xac>
   17ab4:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   17ab8:	01a01181 	moveq	r1, r1, lsl #3
   17abc:	03a03008 	moveq	r3, #8	; 0x8
   17ac0:	13a03001 	movne	r3, #1	; 0x1
   17ac4:	e3510201 	cmp	r1, #268435456	; 0x10000000
   17ac8:	31510000 	cmpcc	r1, r0
   17acc:	31a01201 	movcc	r1, r1, lsl #4
   17ad0:	31a03203 	movcc	r3, r3, lsl #4
   17ad4:	3afffffa 	bcc	17ac4 <__aeabi_uidiv+0x2c>
   17ad8:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   17adc:	31510000 	cmpcc	r1, r0
   17ae0:	31a01081 	movcc	r1, r1, lsl #1
   17ae4:	31a03083 	movcc	r3, r3, lsl #1
   17ae8:	3afffffa 	bcc	17ad8 <__aeabi_uidiv+0x40>
   17aec:	e3a02000 	mov	r2, #0	; 0x0
   17af0:	e1500001 	cmp	r0, r1
   17af4:	20400001 	subcs	r0, r0, r1
   17af8:	21822003 	orrcs	r2, r2, r3
   17afc:	e15000a1 	cmp	r0, r1, lsr #1
   17b00:	204000a1 	subcs	r0, r0, r1, lsr #1
   17b04:	218220a3 	orrcs	r2, r2, r3, lsr #1
   17b08:	e1500121 	cmp	r0, r1, lsr #2
   17b0c:	20400121 	subcs	r0, r0, r1, lsr #2
   17b10:	21822123 	orrcs	r2, r2, r3, lsr #2
   17b14:	e15001a1 	cmp	r0, r1, lsr #3
   17b18:	204001a1 	subcs	r0, r0, r1, lsr #3
   17b1c:	218221a3 	orrcs	r2, r2, r3, lsr #3
   17b20:	e3500000 	cmp	r0, #0	; 0x0
   17b24:	11b03223 	movnes	r3, r3, lsr #4
   17b28:	11a01221 	movne	r1, r1, lsr #4
   17b2c:	1affffef 	bne	17af0 <__aeabi_uidiv+0x58>
   17b30:	e1a00002 	mov	r0, r2
   17b34:	e12fff1e 	bx	lr
   17b38:	03a00001 	moveq	r0, #1	; 0x1
   17b3c:	13a00000 	movne	r0, #0	; 0x0
   17b40:	e12fff1e 	bx	lr
   17b44:	e3510801 	cmp	r1, #65536	; 0x10000
   17b48:	21a01821 	movcs	r1, r1, lsr #16
   17b4c:	23a02010 	movcs	r2, #16	; 0x10
   17b50:	33a02000 	movcc	r2, #0	; 0x0
   17b54:	e3510c01 	cmp	r1, #256	; 0x100
   17b58:	21a01421 	movcs	r1, r1, lsr #8
   17b5c:	22822008 	addcs	r2, r2, #8	; 0x8
   17b60:	e3510010 	cmp	r1, #16	; 0x10
   17b64:	21a01221 	movcs	r1, r1, lsr #4
   17b68:	22822004 	addcs	r2, r2, #4	; 0x4
   17b6c:	e3510004 	cmp	r1, #4	; 0x4
   17b70:	82822003 	addhi	r2, r2, #3	; 0x3
   17b74:	908220a1 	addls	r2, r2, r1, lsr #1
   17b78:	e1a00230 	mov	r0, r0, lsr r2
   17b7c:	e12fff1e 	bx	lr
   17b80:	e52de008 	str	lr, [sp, #-8]!
   17b84:	eb0000c7 	bl	17ea8 <__aeabi_idiv0>
   17b88:	e3a00000 	mov	r0, #0	; 0x0
   17b8c:	e49de008 	ldr	lr, [sp], #8
   17b90:	e12fff1e 	bx	lr

00017b94 <__aeabi_uidivmod>:
   17b94:	e92d4003 	stmdb	sp!, {r0, r1, lr}
   17b98:	ebffffbe 	bl	17a98 <__aeabi_uidiv>
   17b9c:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
   17ba0:	e0030092 	mul	r3, r2, r0
   17ba4:	e0411003 	sub	r1, r1, r3
   17ba8:	e12fff1e 	bx	lr

00017bac <__aeabi_idiv>:
   17bac:	e3510000 	cmp	r1, #0	; 0x0
   17bb0:	e020c001 	eor	ip, r0, r1
   17bb4:	0a000042 	beq	17cc4 <__aeabi_idiv+0x118>
   17bb8:	42611000 	rsbmi	r1, r1, #0	; 0x0
   17bbc:	e2512001 	subs	r2, r1, #1	; 0x1
   17bc0:	0a000027 	beq	17c64 <__aeabi_idiv+0xb8>
   17bc4:	e1b03000 	movs	r3, r0
   17bc8:	42603000 	rsbmi	r3, r0, #0	; 0x0
   17bcc:	e1530001 	cmp	r3, r1
   17bd0:	9a000026 	bls	17c70 <__aeabi_idiv+0xc4>
   17bd4:	e1110002 	tst	r1, r2
   17bd8:	0a000028 	beq	17c80 <__aeabi_idiv+0xd4>
   17bdc:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   17be0:	01a01181 	moveq	r1, r1, lsl #3
   17be4:	03a02008 	moveq	r2, #8	; 0x8
   17be8:	13a02001 	movne	r2, #1	; 0x1
   17bec:	e3510201 	cmp	r1, #268435456	; 0x10000000
   17bf0:	31510003 	cmpcc	r1, r3
   17bf4:	31a01201 	movcc	r1, r1, lsl #4
   17bf8:	31a02202 	movcc	r2, r2, lsl #4
   17bfc:	3afffffa 	bcc	17bec <__aeabi_idiv+0x40>
   17c00:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   17c04:	31510003 	cmpcc	r1, r3
   17c08:	31a01081 	movcc	r1, r1, lsl #1
   17c0c:	31a02082 	movcc	r2, r2, lsl #1
   17c10:	3afffffa 	bcc	17c00 <__aeabi_idiv+0x54>
   17c14:	e3a00000 	mov	r0, #0	; 0x0
   17c18:	e1530001 	cmp	r3, r1
   17c1c:	20433001 	subcs	r3, r3, r1
   17c20:	21800002 	orrcs	r0, r0, r2
   17c24:	e15300a1 	cmp	r3, r1, lsr #1
   17c28:	204330a1 	subcs	r3, r3, r1, lsr #1
   17c2c:	218000a2 	orrcs	r0, r0, r2, lsr #1
   17c30:	e1530121 	cmp	r3, r1, lsr #2
   17c34:	20433121 	subcs	r3, r3, r1, lsr #2
   17c38:	21800122 	orrcs	r0, r0, r2, lsr #2
   17c3c:	e15301a1 	cmp	r3, r1, lsr #3
   17c40:	204331a1 	subcs	r3, r3, r1, lsr #3
   17c44:	218001a2 	orrcs	r0, r0, r2, lsr #3
   17c48:	e3530000 	cmp	r3, #0	; 0x0
   17c4c:	11b02222 	movnes	r2, r2, lsr #4
   17c50:	11a01221 	movne	r1, r1, lsr #4
   17c54:	1affffef 	bne	17c18 <__aeabi_idiv+0x6c>
   17c58:	e35c0000 	cmp	ip, #0	; 0x0
   17c5c:	42600000 	rsbmi	r0, r0, #0	; 0x0
   17c60:	e12fff1e 	bx	lr
   17c64:	e13c0000 	teq	ip, r0
   17c68:	42600000 	rsbmi	r0, r0, #0	; 0x0
   17c6c:	e12fff1e 	bx	lr
   17c70:	33a00000 	movcc	r0, #0	; 0x0
   17c74:	01a00fcc 	moveq	r0, ip, asr #31
   17c78:	03800001 	orreq	r0, r0, #1	; 0x1
   17c7c:	e12fff1e 	bx	lr
   17c80:	e3510801 	cmp	r1, #65536	; 0x10000
   17c84:	21a01821 	movcs	r1, r1, lsr #16
   17c88:	23a02010 	movcs	r2, #16	; 0x10
   17c8c:	33a02000 	movcc	r2, #0	; 0x0
   17c90:	e3510c01 	cmp	r1, #256	; 0x100
   17c94:	21a01421 	movcs	r1, r1, lsr #8
   17c98:	22822008 	addcs	r2, r2, #8	; 0x8
   17c9c:	e3510010 	cmp	r1, #16	; 0x10
   17ca0:	21a01221 	movcs	r1, r1, lsr #4
   17ca4:	22822004 	addcs	r2, r2, #4	; 0x4
   17ca8:	e3510004 	cmp	r1, #4	; 0x4
   17cac:	82822003 	addhi	r2, r2, #3	; 0x3
   17cb0:	908220a1 	addls	r2, r2, r1, lsr #1
   17cb4:	e35c0000 	cmp	ip, #0	; 0x0
   17cb8:	e1a00233 	mov	r0, r3, lsr r2
   17cbc:	42600000 	rsbmi	r0, r0, #0	; 0x0
   17cc0:	e12fff1e 	bx	lr
   17cc4:	e52de008 	str	lr, [sp, #-8]!
   17cc8:	eb000076 	bl	17ea8 <__aeabi_idiv0>
   17ccc:	e3a00000 	mov	r0, #0	; 0x0
   17cd0:	e49de008 	ldr	lr, [sp], #8
   17cd4:	e12fff1e 	bx	lr

00017cd8 <__aeabi_idivmod>:
   17cd8:	e92d4003 	stmdb	sp!, {r0, r1, lr}
   17cdc:	ebffffb2 	bl	17bac <__aeabi_idiv>
   17ce0:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
   17ce4:	e0030092 	mul	r3, r2, r0
   17ce8:	e0411003 	sub	r1, r1, r3
   17cec:	e12fff1e 	bx	lr

00017cf0 <__umodsi3>:
   17cf0:	e2512001 	subs	r2, r1, #1	; 0x1
   17cf4:	3a00002c 	bcc	17dac <__umodsi3+0xbc>
   17cf8:	11500001 	cmpne	r0, r1
   17cfc:	03a00000 	moveq	r0, #0	; 0x0
   17d00:	81110002 	tsthi	r1, r2
   17d04:	00000002 	andeq	r0, r0, r2
   17d08:	912fff1e 	bxls	lr
   17d0c:	e3a02000 	mov	r2, #0	; 0x0
   17d10:	e3510201 	cmp	r1, #268435456	; 0x10000000
   17d14:	31510000 	cmpcc	r1, r0
   17d18:	31a01201 	movcc	r1, r1, lsl #4
   17d1c:	32822004 	addcc	r2, r2, #4	; 0x4
   17d20:	3afffffa 	bcc	17d10 <__umodsi3+0x20>
   17d24:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   17d28:	31510000 	cmpcc	r1, r0
   17d2c:	31a01081 	movcc	r1, r1, lsl #1
   17d30:	32822001 	addcc	r2, r2, #1	; 0x1
   17d34:	3afffffa 	bcc	17d24 <__umodsi3+0x34>
   17d38:	e2522003 	subs	r2, r2, #3	; 0x3
   17d3c:	ba00000e 	blt	17d7c <__umodsi3+0x8c>
   17d40:	e1500001 	cmp	r0, r1
   17d44:	20400001 	subcs	r0, r0, r1
   17d48:	e15000a1 	cmp	r0, r1, lsr #1
   17d4c:	204000a1 	subcs	r0, r0, r1, lsr #1
   17d50:	e1500121 	cmp	r0, r1, lsr #2
   17d54:	20400121 	subcs	r0, r0, r1, lsr #2
   17d58:	e15001a1 	cmp	r0, r1, lsr #3
   17d5c:	204001a1 	subcs	r0, r0, r1, lsr #3
   17d60:	e3500001 	cmp	r0, #1	; 0x1
   17d64:	e1a01221 	mov	r1, r1, lsr #4
   17d68:	a2522004 	subges	r2, r2, #4	; 0x4
   17d6c:	aafffff3 	bge	17d40 <__umodsi3+0x50>
   17d70:	e3120003 	tst	r2, #3	; 0x3
   17d74:	13300000 	teqne	r0, #0	; 0x0
   17d78:	0a00000a 	beq	17da8 <__umodsi3+0xb8>
   17d7c:	e3720002 	cmn	r2, #2	; 0x2
   17d80:	ba000006 	blt	17da0 <__umodsi3+0xb0>
   17d84:	0a000002 	beq	17d94 <__umodsi3+0xa4>
   17d88:	e1500001 	cmp	r0, r1
   17d8c:	20400001 	subcs	r0, r0, r1
   17d90:	e1a010a1 	mov	r1, r1, lsr #1
   17d94:	e1500001 	cmp	r0, r1
   17d98:	20400001 	subcs	r0, r0, r1
   17d9c:	e1a010a1 	mov	r1, r1, lsr #1
   17da0:	e1500001 	cmp	r0, r1
   17da4:	20400001 	subcs	r0, r0, r1
   17da8:	e12fff1e 	bx	lr
   17dac:	e52de008 	str	lr, [sp, #-8]!
   17db0:	eb00003c 	bl	17ea8 <__aeabi_idiv0>
   17db4:	e3a00000 	mov	r0, #0	; 0x0
   17db8:	e49de008 	ldr	lr, [sp], #8
   17dbc:	e12fff1e 	bx	lr

00017dc0 <__modsi3>:
   17dc0:	e3510000 	cmp	r1, #0	; 0x0
   17dc4:	0a000032 	beq	17e94 <__modsi3+0xd4>
   17dc8:	42611000 	rsbmi	r1, r1, #0	; 0x0
   17dcc:	e1b0c000 	movs	ip, r0
   17dd0:	42600000 	rsbmi	r0, r0, #0	; 0x0
   17dd4:	e2512001 	subs	r2, r1, #1	; 0x1
   17dd8:	11500001 	cmpne	r0, r1
   17ddc:	03a00000 	moveq	r0, #0	; 0x0
   17de0:	81110002 	tsthi	r1, r2
   17de4:	00000002 	andeq	r0, r0, r2
   17de8:	9a000026 	bls	17e88 <__modsi3+0xc8>
   17dec:	e3a02000 	mov	r2, #0	; 0x0
   17df0:	e3510201 	cmp	r1, #268435456	; 0x10000000
   17df4:	31510000 	cmpcc	r1, r0
   17df8:	31a01201 	movcc	r1, r1, lsl #4
   17dfc:	32822004 	addcc	r2, r2, #4	; 0x4
   17e00:	3afffffa 	bcc	17df0 <__modsi3+0x30>
   17e04:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   17e08:	31510000 	cmpcc	r1, r0
   17e0c:	31a01081 	movcc	r1, r1, lsl #1
   17e10:	32822001 	addcc	r2, r2, #1	; 0x1
   17e14:	3afffffa 	bcc	17e04 <__modsi3+0x44>
   17e18:	e2522003 	subs	r2, r2, #3	; 0x3
   17e1c:	ba00000e 	blt	17e5c <__modsi3+0x9c>
   17e20:	e1500001 	cmp	r0, r1
   17e24:	20400001 	subcs	r0, r0, r1
   17e28:	e15000a1 	cmp	r0, r1, lsr #1
   17e2c:	204000a1 	subcs	r0, r0, r1, lsr #1
   17e30:	e1500121 	cmp	r0, r1, lsr #2
   17e34:	20400121 	subcs	r0, r0, r1, lsr #2
   17e38:	e15001a1 	cmp	r0, r1, lsr #3
   17e3c:	204001a1 	subcs	r0, r0, r1, lsr #3
   17e40:	e3500001 	cmp	r0, #1	; 0x1
   17e44:	e1a01221 	mov	r1, r1, lsr #4
   17e48:	a2522004 	subges	r2, r2, #4	; 0x4
   17e4c:	aafffff3 	bge	17e20 <__modsi3+0x60>
   17e50:	e3120003 	tst	r2, #3	; 0x3
   17e54:	13300000 	teqne	r0, #0	; 0x0
   17e58:	0a00000a 	beq	17e88 <__modsi3+0xc8>
   17e5c:	e3720002 	cmn	r2, #2	; 0x2
   17e60:	ba000006 	blt	17e80 <__modsi3+0xc0>
   17e64:	0a000002 	beq	17e74 <__modsi3+0xb4>
   17e68:	e1500001 	cmp	r0, r1
   17e6c:	20400001 	subcs	r0, r0, r1
   17e70:	e1a010a1 	mov	r1, r1, lsr #1
   17e74:	e1500001 	cmp	r0, r1
   17e78:	20400001 	subcs	r0, r0, r1
   17e7c:	e1a010a1 	mov	r1, r1, lsr #1
   17e80:	e1500001 	cmp	r0, r1
   17e84:	20400001 	subcs	r0, r0, r1
   17e88:	e35c0000 	cmp	ip, #0	; 0x0
   17e8c:	42600000 	rsbmi	r0, r0, #0	; 0x0
   17e90:	e12fff1e 	bx	lr
   17e94:	e52de008 	str	lr, [sp, #-8]!
   17e98:	eb000002 	bl	17ea8 <__aeabi_idiv0>
   17e9c:	e3a00000 	mov	r0, #0	; 0x0
   17ea0:	e49de008 	ldr	lr, [sp], #8
   17ea4:	e12fff1e 	bx	lr

00017ea8 <__aeabi_idiv0>:
   17ea8:	e12fff1e 	bx	lr

00017eac <abSense>:
   17eac:	00ff0070 0a000000 00000000 0000ffff     p...............
	...

00017ebe <abInquiry>:
   17ebe:	02048000 0000001f 5543504c 20204253     ........LPCUSB  
   17ece:	7373614d 6f747320 65676172 20202020     Mass storage    
   17ede:	20312e30 04a40000                                0.1 ..

00017ee4 <_global_impure_ptr>:
   17ee4:	400004a4 6665440a 746c7561 43495620     ...@.Default VIC
   17ef4:	6f745320 00000070 00006425 00202020      Stop...%d..   .
   17f04:	6f4c0d0a 616d6f67 20636974 54203256     ..Logomatic V2 T
   17f14:	20747365 65646f43 000d0a3a 20434441     est Code:...ADC 
   17f24:	74736554 6c697720 6562206c 206e6967     Test will begin 
   17f34:	35206e69 63657320 73646e6f 6968202c     in 5 seconds, hi
   17f44:	74732074 6220706f 6f747475 6f74206e     t stop button to
   17f54:	72657420 616e696d 74206574 74206568      terminate the t
   17f64:	2e747365 000a0a0d 65540d0a 63207473     est.......Test c
   17f74:	6c706d6f 2c657465 636f6c20 676e696b     omplete, locking
   17f84:	2e707520 0d0a2e2e 00000000 49204453      up.........SD I
   17f94:	2074696e 6f727245 000d0a72 4f204453     nit Error...SD O
   17fa4:	526e6570 20746f6f 6f727245 000d0a72     penRoot Error...
   17fb4:	45444f4d 0d0a3220 00000000 45444f4d     MODE 2......MODE
   17fc4:	0d0a3120 00000000 45444f4d 0d0a3020      1......MODE 0..
   17fd4:	00000000 43474f4c 742e4e4f 00007478     ....LOGCON.txt..
   17fe4:	6f727245 72632072 69746165 4c20676e     Error creating L
   17ff4:	4f43474f 78742e4e 6c202c74 696b636f     OGCON.txt, locki
   18004:	7520676e 2e2e2e70 00000d0a 45444f4d     ng up.......MODE
   18014:	30203d20 53410a0d 20494943 0d4e203d      = 0..ASCII = N.
   18024:	7561420a 203d2064 460a0d34 75716572     .Baud = 4..Frequ
   18034:	79636e65 31203d20 0a0d3030 67697254     ency = 100..Trig
   18044:	20726567 72616843 65746361 203d2072     ger Character = 
   18054:	540a0d24 20747865 6d617246 203d2065     $..Text Frame = 
   18064:	0d303031 3144410a 3d20332e 0a0d4e20     100..AD1.3 = N..
   18074:	2e304441 203d2033 410a0d4e 322e3044     AD0.3 = N..AD0.2
   18084:	4e203d20 44410a0d 20312e30 0d4e203d      = N..AD0.1 = N.
   18094:	3144410a 3d20322e 0a0d4e20 2e304441     .AD1.2 = N..AD0.
   180a4:	203d2034 410a0d4e 372e3144 4e203d20     4 = N..AD1.7 = N
   180b4:	44410a0d 20362e31 0d4e203d 6661530a     ..AD1.6 = N..Saf
   180c4:	20796574 3d206e4f 0a0d5920 00000000     tey On = Y......
   180d4:	65646f6d 25203d20 000d0a64 20637361     mode = %d...asc 
   180e4:	6325203d 00000d0a 64756162 25203d20     = %c....baud = %
   180f4:	000d0a64 71657266 25203d20 000d0a64     d...freq = %d...
   18104:	67697274 25203d20 000d0a63 6d617266     trig = %c...fram
   18114:	203d2065 0d0a6425 00000000 5f316461     e = %d......ad1_
   18124:	203d2033 0d0a6325 00000000 5f306461     3 = %c......ad0_
   18134:	203d2033 0d0a6325 00000000 5f306461     3 = %c......ad0_
   18144:	203d2032 0d0a6325 00000000 5f306461     2 = %c......ad0_
   18154:	203d2031 0d0a6325 00000000 5f316461     1 = %c......ad1_
   18164:	203d2032 0d0a6325 00000000 5f306461     2 = %c......ad0_
   18174:	203d2034 0d0a6325 00000000 5f316461     4 = %c......ad1_
   18184:	203d2037 0d0a6325 00000000 5f316461     7 = %c......ad1_
   18194:	203d2036 0d0a6325 00000000 65666173     6 = %c......safe
   181a4:	3d207974 0a632520 0000000d 74474f4c     ty = %c.....LOGt
   181b4:	32747365 64323025 7478742e 00000000     est2%02d.txt....
   181c4:	206f6f54 796e614d 676f4c20 0d0a2173     Too Many Logs!..
   181d4:	00000000 25474f4c 2e643230 00747874     ....LOG%02d.txt.
   181e4:	756e616d 20203a66 30257830 0d0a7832     manuf:  0x%02x..
   181f4:	00000000 3a6d656f 20202020 0d0a7325     ....oem:    %s..
   18204:	00000000 646f7270 2020203a 0d0a7325     ....prod:   %s..
   18214:	00000000 3a766572 20202020 78323025     ....rev:    %02x
   18224:	00000d0a 69726573 203a6c61 30257830     ....serial: 0x%0
   18234:	0a786c38 0000000d 65746164 2020203a     8lx.....date:   
   18244:	64323025 3230252f 000d0a64 657a6973     %02d/%02d...size
   18254:	2020203a 0a646c25 0000000d 79706f63     :   %ld.....copy
   18264:	2020203a 0d0a6425 00000000 702e7277     :   %d......wr.p
   18274:	203a2e72 252f6425 000d0a64 6d726f66     r.: %d/%d...form
   18284:	203a7461 0d0a6425 00000000 65657266     at: %d......free
   18294:	2020203a 2f646c25 0a646c25 0000000d     :   %ld/%ld.....
   182a4:	6e65706f 20676e69 74726170 6f697469     opening partitio
   182b4:	6166206e 64656c69 00000d0a 6e65706f     n failed....open
   182c4:	20676e69 656c6966 74737973 66206d65     ing filesystem f
   182d4:	656c6961 000d0a64 0000002f 6e65706f     ailed.../...open
   182e4:	20676e69 746f6f72 72696420 6f746365     ing root directo
   182f4:	66207972 656c6961 000d0a64 52204453     ry failed...SD R
   18304:	4e205741 4120544f 4c494156 454c4241     AW NOT AVAILABLE
   18314:	00000d0a 65720d0a 6e6f7073 203a6573     ......response: 
   18324:	0d0a6425 00000000 203d2069 66377830     %d......i = 0x7f
   18334:	0d0a6666 00000000 434f4c42 4953204b     ff......BLOCK SI
   18344:	5320455a 45205445 0a205252 0000000d     ZE SET ERR .....
   18354:	725f6473 725f7761 20646165 6b726f62     sd_raw_read bork
   18364:	000d0a73 4c4c414d 4620434f 534c4941     s...MALLOC FAILS
   18374:	00000d0a 6c696146 52206465 69646165     ....Failed Readi
   18384:	4820676e 65646165 000d0a72 33323130     ng Header...0123
   18394:	37363534 42413938 46454443 00000000     456789ABCDEF....
   183a4:	74696e49 696c6169 676e6973 42535520     Initialising USB
   183b4:	61747320 000a6b63 72617453 676e6974      stack..Starting
   183c4:	42535520 6d6f6320 696e756d 69746163      USB communicati
   183d4:	000a6e6f 3a445343 00000000 32302520     on..CSD:.... %02
   183e4:	00000078 75677241 746e656d 74756f20     x...Argument out
   183f4:	20666f20 6e756f62 0a2e7364 00000000      of bounds......
   18404:	72646441 20737365 2074756f 6220666f     Address out of b
   18414:	646e756f 000a2e73 6f727245 75642072     ounds...Error du
   18424:	676e6972 61726520 73206573 65757165     ring erase seque
   18434:	2e65636e 0000000a 20435243 6c696166     nce.....CRC fail
   18444:	0a2e6465 00000000 656c6c49 206c6167     ed......Illegal 
   18454:	6d6d6f63 2e646e61 0000000a 73617245     command.....Eras
   18464:	65722065 20746573 65657328 6e615320     e reset (see San
   18474:	6b736944 636f6420 35702073 2933312d     Disk docs p5-13)
   18484:	00000a2e 0000002e 6e6b6e55 206e776f     ........Unknown 
   18494:	6f727265 78302072 28207825 20656573     error 0x%x (see 
   184a4:	446e6153 206b7369 73636f64 2d357020     SanDisk docs p5-
   184b4:	2e293331 0000000a 70736572 6678303d     13).....resp=0xf
   184c4:	00000a66 70736572 78303d21 000a6666     f...resp!=0xff..
   184d4:	64726143 20736920 6b636f4c 0a2e6465     Card is Locked..
   184e4:	00000000 45205057 65736172 696b5320     ....WP Erase Ski
   184f4:	4c202c70 2f6b636f 6f6c6e55 43206b63     p, Lock/Unlock C
   18504:	4620646d 656c6961 000a2e64 656e6547     md Failed...Gene
   18514:	206c6172 6e55202f 776f6e6b 7265206e     ral / Unknown er
   18524:	20726f72 63202d2d 20647261 6b6f7262     ror -- card brok
   18534:	2e3f6e65 0000000a 65746e49 6c616e72     en?.....Internal
   18544:	72616320 6f632064 6f72746e 72656c6c      card controller
   18554:	72726520 0a2e726f 00000000 64726143      error......Card
   18564:	746e6920 616e7265 4345206c 61772043      internal ECC wa
   18574:	70612073 65696c70 62202c64 66207475     s applied, but f
   18584:	656c6961 6f742064 726f6320 74636572     ailed to correct
   18594:	65687420 74616420 000a2e61 74697257      the data...Writ
   185a4:	72702065 6365746f 69762074 74616c6f     e protect violat
   185b4:	2e6e6f69 0000000a 69206e41 6c61766e     ion.....An inval
   185c4:	73206469 63656c65 6e6f6974 6573202c     id selection, se
   185d4:	726f7463 6f662073 72652072 2e657361     ctors for erase.
   185e4:	0000000a 2074754f 5220666f 65676e61     ....Out of Range
   185f4:	5343202c 764f5f44 72777265 2e657469     , CSD_Overwrite.
   18604:	0000000a 6e6b6e55 206e776f 6f727265     ....Unknown erro
   18614:	30203a72 20782578 65657328 6e615320     r: 0x%x (see San
   18624:	6b736944 636f6420 35702073 2934312d     Disk docs p5-14)
   18634:	00000a2e 49204453 2074696e 656e6f64     ....SD Init done
   18644:	0a2e2e2e 00000000 64726143 64696420     ........Card did
   18654:	2074276e 75746572 74206e72 72206568     n't return the r
   18664:	79646165 61747320 202c6574 61657262     eady state, brea
   18674:	676e696b 2e707520 000a2e2e 49697073     king up.....spiI
   18684:	2074696e 20726f66 28495053 000a2930     nit for SPI(0)..
   18694:	00000043                                C...
