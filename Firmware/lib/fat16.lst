   1              		.file	"fat16.c"
   9              	.Ltext0:
  10              		.align	2
  12              	fat16_dir_entry_seek_callback:
  13              	.LFB7:
  14              		.file 1 "../lib/fat16.c"
   1:../lib/fat16.c **** /* This program is free software; you can redistribute it and/or modify
   2:../lib/fat16.c ****  * it under the terms of the GNU General Public License version 2 as
   3:../lib/fat16.c ****  * published by the Free Software Foundation.
   4:../lib/fat16.c ****  */
   5:../lib/fat16.c **** 
   6:../lib/fat16.c **** #include <stdio.h>
   7:../lib/fat16.c **** 
   8:../lib/fat16.c **** //Debug
   9:../lib/fat16.c **** #include "rprintf.h"
  10:../lib/fat16.c **** 
  11:../lib/fat16.c **** #include "partition.h"
  12:../lib/fat16.c **** #include "fat16.h"
  13:../lib/fat16.c **** #include "fat16_config.h"
  14:../lib/fat16.c **** #include "sd_raw.h"
  15:../lib/fat16.c **** 
  16:../lib/fat16.c **** #include <stdlib.h>
  17:../lib/fat16.c **** #include <string.h>
  18:../lib/fat16.c **** 
  19:../lib/fat16.c **** /**
  20:../lib/fat16.c ****  * \addtogroup fat16 FAT16 support
  21:../lib/fat16.c ****  *
  22:../lib/fat16.c ****  * This module implements FAT16 read and write access.
  23:../lib/fat16.c ****  *
  24:../lib/fat16.c ****  * The following features are supported:
  25:../lib/fat16.c ****  * - File names up to 31 characters long.
  26:../lib/fat16.c ****  * - Unlimited depth of subdirectories.
  27:../lib/fat16.c ****  * - Short 8.3 and long filenames.
  28:../lib/fat16.c ****  * - Creating and deleting files.
  29:../lib/fat16.c ****  * - Reading and writing from and to files.
  30:../lib/fat16.c ****  * - File resizing.
  31:../lib/fat16.c ****  * - File sizes of up to 4 gigabytes.
  32:../lib/fat16.c ****  *
  33:../lib/fat16.c ****  * @{
  34:../lib/fat16.c ****  */
  35:../lib/fat16.c **** /**
  36:../lib/fat16.c ****  * \file
  37:../lib/fat16.c ****  * FAT16 implementation.
  38:../lib/fat16.c ****  *
  39:../lib/fat16.c ****  * \author Roland Riegel
  40:../lib/fat16.c ****  */
  41:../lib/fat16.c **** 
  42:../lib/fat16.c **** /**
  43:../lib/fat16.c ****  * \addtogroup fat16_config FAT16 configuration
  44:../lib/fat16.c ****  * Preprocessor defines to configure the FAT16 implementation.
  45:../lib/fat16.c ****  */
  46:../lib/fat16.c **** 
  47:../lib/fat16.c **** /**
  48:../lib/fat16.c ****  * \addtogroup fat16_fs FAT16 access
  49:../lib/fat16.c ****  * Basic functions for handling a FAT16 filesystem.
  50:../lib/fat16.c ****  */
  51:../lib/fat16.c **** 
  52:../lib/fat16.c **** /**
  53:../lib/fat16.c ****  * \addtogroup fat16_file FAT16 file functions
  54:../lib/fat16.c ****  * Functions for managing files.
  55:../lib/fat16.c ****  */
  56:../lib/fat16.c **** 
  57:../lib/fat16.c **** /**
  58:../lib/fat16.c ****  * \addtogroup fat16_dir FAT16 directory functions
  59:../lib/fat16.c ****  * Functions for managing directories.
  60:../lib/fat16.c ****  */
  61:../lib/fat16.c **** 
  62:../lib/fat16.c **** /**
  63:../lib/fat16.c ****  * @}
  64:../lib/fat16.c ****  */
  65:../lib/fat16.c **** 
  66:../lib/fat16.c **** #define FAT16_CLUSTER_FREE 0x0000
  67:../lib/fat16.c **** #define FAT16_CLUSTER_RESERVED_MIN (uint16_t)0xfff0
  68:../lib/fat16.c **** #define FAT16_CLUSTER_RESERVED_MAX (uint16_t)0xfff6
  69:../lib/fat16.c **** #define FAT16_CLUSTER_BAD (uint16_t)0xfff7
  70:../lib/fat16.c **** #define FAT16_CLUSTER_LAST_MIN (uint16_t)0xfff8
  71:../lib/fat16.c **** #define FAT16_CLUSTER_LAST_MAX (uint16_t)0xffff
  72:../lib/fat16.c **** 
  73:../lib/fat16.c **** #define FAT16_DIRENTRY_DELETED 0xe5
  74:../lib/fat16.c **** #define FAT16_DIRENTRY_LFNLAST (1 << 6)
  75:../lib/fat16.c **** #define FAT16_DIRENTRY_LFNSEQMASK ((1 << 6) - 1)
  76:../lib/fat16.c **** 
  77:../lib/fat16.c **** /* Each entry within the directory table has a size of 32 bytes
  78:../lib/fat16.c ****  * and either contains a 8.3 DOS-style file name or a part of a
  79:../lib/fat16.c ****  * long file name, which may consist of several directory table
  80:../lib/fat16.c ****  * entries at once.
  81:../lib/fat16.c ****  *
  82:../lib/fat16.c ****  * multi-byte integer values are stored little-endian!
  83:../lib/fat16.c ****  *
  84:../lib/fat16.c ****  * 8.3 file name entry:
  85:../lib/fat16.c ****  * ====================
  86:../lib/fat16.c ****  * offset  length  description
  87:../lib/fat16.c ****  *      0       8  name (space padded)
  88:../lib/fat16.c ****  *      8       3  extension (space padded)
  89:../lib/fat16.c ****  *     11       1  attributes (FAT16_ATTRIB_*)
  90:../lib/fat16.c ****  
  91:../lib/fat16.c ****  *     0x0E     2  Creation Time
  92:../lib/fat16.c ****  *     0x10     2  Creation Date
  93:../lib/fat16.c ****  
  94:../lib/fat16.c ****  *
  95:../lib/fat16.c ****  * long file name (lfn) entry ordering for a single file name:
  96:../lib/fat16.c ****  * ===========================================================
  97:../lib/fat16.c ****  * LFN entry n
  98:../lib/fat16.c ****  *     ...
  99:../lib/fat16.c ****  * LFN entry 2
 100:../lib/fat16.c ****  * LFN entry 1
 101:../lib/fat16.c ****  * 8.3 entry (see above)
 102:../lib/fat16.c ****  *
 103:../lib/fat16.c ****  * lfn entry:
 104:../lib/fat16.c ****  * ==========
 105:../lib/fat16.c ****  * offset  length  description
 106:../lib/fat16.c ****  *      0       1  ordinal field
 107:../lib/fat16.c ****  *      1       2  unicode character 1
 108:../lib/fat16.c ****  *      3       3  unicode character 2
 109:../lib/fat16.c ****  *      5       3  unicode character 3
 110:../lib/fat16.c ****  *      7       3  unicode character 4
 111:../lib/fat16.c ****  *      9       3  unicode character 5
 112:../lib/fat16.c ****  *     11       1  attribute (always 0x0f)
 113:../lib/fat16.c ****  *     12       1  type (reserved, always 0)
 114:../lib/fat16.c ****  *     13       1  checksum
 115:../lib/fat16.c ****  *     14       2  unicode character 6
 116:../lib/fat16.c ****  *     16       2  unicode character 7
 117:../lib/fat16.c ****  *     18       2  unicode character 8
 118:../lib/fat16.c ****  *     20       2  unicode character 9
 119:../lib/fat16.c ****  *     22       2  unicode character 10
 120:../lib/fat16.c ****  *     24       2  unicode character 11
 121:../lib/fat16.c ****  *     26       2  cluster (unused, always 0)
 122:../lib/fat16.c ****  *     28       2  unicode character 12
 123:../lib/fat16.c ****  *     30       2  unicode character 13
 124:../lib/fat16.c ****  *
 125:../lib/fat16.c ****  * The ordinal field contains a descending number, from n to 1.
 126:../lib/fat16.c ****  * For the n'th lfn entry the ordinal field is or'ed with 0x40.
 127:../lib/fat16.c ****  * For deleted lfn entries, the ordinal field is set to 0xe5.
 128:../lib/fat16.c ****  */
 129:../lib/fat16.c **** 
 130:../lib/fat16.c **** struct fat16_header_struct
 131:../lib/fat16.c **** {
 132:../lib/fat16.c ****     uint32_t size;
 133:../lib/fat16.c **** 
 134:../lib/fat16.c ****     uint32_t fat_offset;
 135:../lib/fat16.c ****     uint32_t fat_size;
 136:../lib/fat16.c **** 
 137:../lib/fat16.c ****     uint16_t sector_size;
 138:../lib/fat16.c ****     uint16_t cluster_size;
 139:../lib/fat16.c **** 
 140:../lib/fat16.c ****     uint32_t root_dir_offset;
 141:../lib/fat16.c **** 
 142:../lib/fat16.c ****     uint32_t cluster_zero_offset;
 143:../lib/fat16.c **** };
 144:../lib/fat16.c **** 
 145:../lib/fat16.c **** struct fat16_fs_struct
 146:../lib/fat16.c **** {
 147:../lib/fat16.c ****     struct partition_struct* partition;
 148:../lib/fat16.c ****     struct fat16_header_struct header;
 149:../lib/fat16.c **** };
 150:../lib/fat16.c **** 
 151:../lib/fat16.c **** struct fat16_file_struct
 152:../lib/fat16.c **** {
 153:../lib/fat16.c ****     struct fat16_fs_struct* fs;
 154:../lib/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 155:../lib/fat16.c ****     uint32_t pos;
 156:../lib/fat16.c ****     uint16_t pos_cluster;
 157:../lib/fat16.c **** };
 158:../lib/fat16.c **** 
 159:../lib/fat16.c **** struct fat16_dir_struct
 160:../lib/fat16.c **** {
 161:../lib/fat16.c ****     struct fat16_fs_struct* fs;
 162:../lib/fat16.c ****     struct fat16_dir_entry_struct dir_entry;
 163:../lib/fat16.c ****     uint16_t entry_next;
 164:../lib/fat16.c **** };
 165:../lib/fat16.c **** 
 166:../lib/fat16.c **** struct fat16_read_callback_arg
 167:../lib/fat16.c **** {
 168:../lib/fat16.c ****     uint16_t entry_cur;
 169:../lib/fat16.c ****     uint16_t entry_num;
 170:../lib/fat16.c ****     uint32_t entry_offset;
 171:../lib/fat16.c ****     uint8_t byte_count;
 172:../lib/fat16.c **** };
 173:../lib/fat16.c **** 
 174:../lib/fat16.c **** struct fat16_usage_count_callback_arg
 175:../lib/fat16.c **** {
 176:../lib/fat16.c ****     uint16_t cluster_count;
 177:../lib/fat16.c ****     uint8_t buffer_size;
 178:../lib/fat16.c **** };
 179:../lib/fat16.c **** 
 180:../lib/fat16.c **** static uint8_t fat16_read_header(struct fat16_fs_struct* fs);
 181:../lib/fat16.c **** static uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, stru
 182:../lib/fat16.c **** static uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const
 183:../lib/fat16.c **** static uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p);
 184:../lib/fat16.c **** static uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p);
 185:../lib/fat16.c **** static uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* r
 186:../lib/fat16.c **** static uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 187:../lib/fat16.c **** static uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint1
 188:../lib/fat16.c **** static uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 189:../lib/fat16.c **** static uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num);
 190:../lib/fat16.c **** static uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry
 191:../lib/fat16.c **** 
 192:../lib/fat16.c **** static uint8_t fat16_get_fs_free_callback(uint8_t* buffer, uint32_t offset, void* p);
 193:../lib/fat16.c **** 
 194:../lib/fat16.c **** /**
 195:../lib/fat16.c ****  * \ingroup fat16_fs
 196:../lib/fat16.c ****  * Opens a FAT16 filesystem.
 197:../lib/fat16.c ****  *
 198:../lib/fat16.c ****  * \param[in] partition Discriptor of partition on which the filesystem resides.
 199:../lib/fat16.c ****  * \returns 0 on error, a FAT16 filesystem descriptor on success.
 200:../lib/fat16.c ****  * \see fat16_open
 201:../lib/fat16.c ****  */
 202:../lib/fat16.c **** struct fat16_fs_struct* fat16_open(struct partition_struct* partition)
 203:../lib/fat16.c **** {
 204:../lib/fat16.c ****     if(!partition ||
 205:../lib/fat16.c ****         #if FAT16_WRITE_SUPPORT
 206:../lib/fat16.c ****         !partition->device_write
 207:../lib/fat16.c ****        #else
 208:../lib/fat16.c ****         0
 209:../lib/fat16.c ****        #endif
 210:../lib/fat16.c ****        )
 211:../lib/fat16.c ****     return 0;
 212:../lib/fat16.c **** 
 213:../lib/fat16.c ****     struct fat16_fs_struct* fs = malloc(sizeof(*fs));
 214:../lib/fat16.c ****     if(!fs)
 215:../lib/fat16.c ****     {
 216:../lib/fat16.c ****         rprintf("MALLOC FAILS\n\r");
 217:../lib/fat16.c ****         return 0;
 218:../lib/fat16.c ****     }
 219:../lib/fat16.c ****     memset(fs, 0, sizeof(*fs));
 220:../lib/fat16.c **** 
 221:../lib/fat16.c ****     fs->partition = partition;
 222:../lib/fat16.c ****     if(!fat16_read_header(fs))
 223:../lib/fat16.c ****     {
 224:../lib/fat16.c ****         rprintf("Failed Reading Header\n\r");
 225:../lib/fat16.c ****         free(fs);
 226:../lib/fat16.c ****         return 0;
 227:../lib/fat16.c ****     }
 228:../lib/fat16.c **** 
 229:../lib/fat16.c ****     return fs;
 230:../lib/fat16.c **** }
 231:../lib/fat16.c **** 
 232:../lib/fat16.c **** /**
 233:../lib/fat16.c ****  * \ingroup fat16_fs
 234:../lib/fat16.c ****  * Closes a FAT16 filesystem.
 235:../lib/fat16.c ****  *
 236:../lib/fat16.c ****  * When this function returns, the given filesystem descriptor
 237:../lib/fat16.c ****  * will be invalid.
 238:../lib/fat16.c ****  *
 239:../lib/fat16.c ****  * \param[in] fs The filesystem to close.
 240:../lib/fat16.c ****  * \see fat16_open
 241:../lib/fat16.c ****  */
 242:../lib/fat16.c **** void fat16_close(struct fat16_fs_struct* fs)
 243:../lib/fat16.c **** {
 244:../lib/fat16.c ****     if(!fs)
 245:../lib/fat16.c ****         return;
 246:../lib/fat16.c **** 
 247:../lib/fat16.c ****     free(fs);
 248:../lib/fat16.c **** }
 249:../lib/fat16.c **** 
 250:../lib/fat16.c **** /**
 251:../lib/fat16.c ****  * \ingroup fat16_fs
 252:../lib/fat16.c ****  * Reads and parses the header of a FAT16 filesystem.
 253:../lib/fat16.c ****  *
 254:../lib/fat16.c ****  * \param[inout] fs The filesystem for which to parse the header.
 255:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 256:../lib/fat16.c ****  */
 257:../lib/fat16.c **** uint8_t fat16_read_header(struct fat16_fs_struct* fs)
 258:../lib/fat16.c **** {
 259:../lib/fat16.c ****     if(!fs)
 260:../lib/fat16.c ****         return 0;
 261:../lib/fat16.c **** 
 262:../lib/fat16.c ****     struct partition_struct* partition = fs->partition;
 263:../lib/fat16.c ****     if(!partition)
 264:../lib/fat16.c ****     {
 265:../lib/fat16.c ****         rprintf("Partition = 0\n\r");
 266:../lib/fat16.c ****         return 0;
 267:../lib/fat16.c ****     }
 268:../lib/fat16.c **** 
 269:../lib/fat16.c ****     /* read fat parameters */
 270:../lib/fat16.c ****     uint8_t buffer[25];
 271:../lib/fat16.c ****     uint32_t partition_offset = partition->offset * 512;
 272:../lib/fat16.c **** 
 273:../lib/fat16.c ****     if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
 274:../lib/fat16.c ****         return 0;
 275:../lib/fat16.c **** 
 276:../lib/fat16.c ****     uint16_t bytes_per_sector = ((uint16_t) buffer[0x00]) |
 277:../lib/fat16.c ****     ((uint16_t) buffer[0x01] << 8);
 278:../lib/fat16.c ****     uint8_t sectors_per_cluster = buffer[0x02];
 279:../lib/fat16.c ****     uint16_t reserved_sectors = ((uint16_t) buffer[0x03]) |
 280:../lib/fat16.c ****     ((uint16_t) buffer[0x04] << 8);
 281:../lib/fat16.c ****     uint8_t fat_copies = buffer[0x05];
 282:../lib/fat16.c ****     uint16_t max_root_entries = ((uint16_t) buffer[0x06]) |
 283:../lib/fat16.c ****     ((uint16_t) buffer[0x07] << 8);
 284:../lib/fat16.c ****     uint16_t sector_count_16 = ((uint16_t) buffer[0x08]) |
 285:../lib/fat16.c ****     ((uint16_t) buffer[0x09] << 8);
 286:../lib/fat16.c ****     uint16_t sectors_per_fat = ((uint16_t) buffer[0x0b]) |
 287:../lib/fat16.c ****     ((uint16_t) buffer[0x0c] << 8);
 288:../lib/fat16.c ****     uint32_t sector_count = ((uint32_t) buffer[0x15]) |
 289:../lib/fat16.c ****     ((uint32_t) buffer[0x16] << 8) |
 290:../lib/fat16.c ****     ((uint32_t) buffer[0x17] << 16) |
 291:../lib/fat16.c ****     ((uint32_t) buffer[0x18] << 24);
 292:../lib/fat16.c **** 
 293:../lib/fat16.c ****     if(sectors_per_fat == 0)
 294:../lib/fat16.c ****     /* this is not a FAT16 */
 295:../lib/fat16.c ****         return 0;
 296:../lib/fat16.c **** 
 297:../lib/fat16.c ****     if(sector_count == 0)
 298:../lib/fat16.c ****     {
 299:../lib/fat16.c ****         if(sector_count_16 == 0)
 300:../lib/fat16.c ****     /* illegal volume size */
 301:../lib/fat16.c ****             return 0;
 302:../lib/fat16.c ****         else
 303:../lib/fat16.c ****             sector_count = sector_count_16;
 304:../lib/fat16.c ****     }
 305:../lib/fat16.c **** 
 306:../lib/fat16.c ****     /* ensure we really have a FAT16 fs here */
 307:../lib/fat16.c ****     uint32_t data_sector_count = sector_count
 308:../lib/fat16.c ****     - reserved_sectors
 309:../lib/fat16.c ****     - (uint32_t) sectors_per_fat * fat_copies
 310:../lib/fat16.c ****     - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sector);
 311:../lib/fat16.c ****     uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
 312:../lib/fat16.c ****     if(data_cluster_count < 4085 || data_cluster_count >= 65525)
 313:../lib/fat16.c ****     /* this is not a FAT16 */
 314:../lib/fat16.c ****         return 0;
 315:../lib/fat16.c **** 
 316:../lib/fat16.c ****     partition->type = PARTITION_TYPE_FAT16;
 317:../lib/fat16.c **** 
 318:../lib/fat16.c ****     /* fill header information */
 319:../lib/fat16.c ****     struct fat16_header_struct* header = &fs->header;
 320:../lib/fat16.c ****     memset(header, 0, sizeof(*header));
 321:../lib/fat16.c **** 
 322:../lib/fat16.c ****     header->size = sector_count * bytes_per_sector;
 323:../lib/fat16.c **** 
 324:../lib/fat16.c ****     header->fat_offset = /* jump to partition */
 325:../lib/fat16.c ****     partition_offset +
 326:../lib/fat16.c ****     /* jump to fat */
 327:../lib/fat16.c ****     (uint32_t) reserved_sectors * bytes_per_sector;
 328:../lib/fat16.c ****     header->fat_size = (data_cluster_count + 2) * 2;
 329:../lib/fat16.c **** 
 330:../lib/fat16.c ****     header->sector_size = bytes_per_sector;
 331:../lib/fat16.c ****     header->cluster_size = (uint32_t) bytes_per_sector * sectors_per_cluster;
 332:../lib/fat16.c **** 
 333:../lib/fat16.c ****     header->root_dir_offset = /* jump to fats */
 334:../lib/fat16.c ****     header->fat_offset +
 335:../lib/fat16.c ****     /* jump to root directory entries */
 336:../lib/fat16.c ****     (uint32_t) fat_copies * sectors_per_fat * bytes_per_sector;
 337:../lib/fat16.c **** 
 338:../lib/fat16.c ****     header->cluster_zero_offset = /* jump to root directory entries */
 339:../lib/fat16.c ****     header->root_dir_offset +
 340:../lib/fat16.c ****     /* skip root directory entries */
 341:../lib/fat16.c ****     (uint32_t) max_root_entries * 32;
 342:../lib/fat16.c **** 
 343:../lib/fat16.c ****     return 1;
 344:../lib/fat16.c **** }
 345:../lib/fat16.c **** 
 346:../lib/fat16.c **** /**
 347:../lib/fat16.c ****  * \ingroup fat16_fs
 348:../lib/fat16.c ****  * Reads a directory entry of the root directory.
 349:../lib/fat16.c ****  *
 350:../lib/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 351:../lib/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 352:../lib/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 353:../lib/fat16.c ****  * \returns 0 on failure, 1 on success
 354:../lib/fat16.c ****  * \see fat16_read_sub_dir_entry, fat16_read_dir_entry_by_path
 355:../lib/fat16.c ****  */
 356:../lib/fat16.c **** uint8_t fat16_read_root_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, struct fat1
 357:../lib/fat16.c **** {
 358:../lib/fat16.c ****     if(!fs || !dir_entry)
 359:../lib/fat16.c ****         return 0;
 360:../lib/fat16.c **** 
 361:../lib/fat16.c ****     /* we read from the root directory entry */
 362:../lib/fat16.c ****     const struct fat16_header_struct* header = &fs->header;
 363:../lib/fat16.c ****     device_read_interval_t device_read_interval = fs->partition->device_read_interval;
 364:../lib/fat16.c ****     uint8_t buffer[32];
 365:../lib/fat16.c **** 
 366:../lib/fat16.c ****     /* seek to the n-th entry */
 367:../lib/fat16.c ****     struct fat16_read_callback_arg arg;
 368:../lib/fat16.c ****     memset(&arg, 0, sizeof(arg));
 369:../lib/fat16.c ****     arg.entry_num = entry_num;
 370:../lib/fat16.c ****     if(!device_read_interval(header->root_dir_offset,
 371:../lib/fat16.c ****         buffer,
 372:../lib/fat16.c ****        sizeof(buffer),
 373:../lib/fat16.c ****        header->cluster_zero_offset - header->root_dir_offset,
 374:../lib/fat16.c ****        fat16_dir_entry_seek_callback,
 375:../lib/fat16.c ****        &arg) ||
 376:../lib/fat16.c ****        arg.entry_offset == 0
 377:../lib/fat16.c ****        )
 378:../lib/fat16.c ****     return 0;
 379:../lib/fat16.c **** 
 380:../lib/fat16.c ****     /* read entry */
 381:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 382:../lib/fat16.c ****     if(!device_read_interval(arg.entry_offset,
 383:../lib/fat16.c ****         buffer,
 384:../lib/fat16.c ****        sizeof(buffer),
 385:../lib/fat16.c ****        arg.byte_count,
 386:../lib/fat16.c ****        fat16_dir_entry_read_callback,
 387:../lib/fat16.c ****        dir_entry))
 388:../lib/fat16.c ****     return 0;
 389:../lib/fat16.c **** 
 390:../lib/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 391:../lib/fat16.c **** }
 392:../lib/fat16.c **** 
 393:../lib/fat16.c **** /**
 394:../lib/fat16.c ****  * \ingroup fat16_fs
 395:../lib/fat16.c ****  * Reads a directory entry of a given parent directory.
 396:../lib/fat16.c ****  *
 397:../lib/fat16.c ****  * \param[in] fs Descriptor of file system to use.
 398:../lib/fat16.c ****  * \param[in] entry_num The index of the directory entry to read.
 399:../lib/fat16.c ****  * \param[in] parent Directory entry descriptor in which to read directory entry.
 400:../lib/fat16.c ****  * \param[out] dir_entry Directory entry descriptor which will get filled.
 401:../lib/fat16.c ****  * \returns 0 on failure, 1 on success
 402:../lib/fat16.c ****  * \see fat16_read_root_dir_entry, fat16_read_dir_entry_by_path
 403:../lib/fat16.c ****  */
 404:../lib/fat16.c **** uint8_t fat16_read_sub_dir_entry(const struct fat16_fs_struct* fs, uint16_t entry_num, const struct
 405:../lib/fat16.c **** {
 406:../lib/fat16.c ****     if(!fs || !parent || !dir_entry)
 407:../lib/fat16.c ****         return 0;
 408:../lib/fat16.c **** 
 409:../lib/fat16.c ****     /* we are in a parent directory and want to search within its directory entry table */
 410:../lib/fat16.c ****     if(!(parent->attributes & FAT16_ATTRIB_DIR))
 411:../lib/fat16.c ****         return 0;
 412:../lib/fat16.c **** 
 413:../lib/fat16.c ****     /* loop through all clusters of the directory */
 414:../lib/fat16.c ****     uint8_t buffer[32];
 415:../lib/fat16.c ****     uint32_t cluster_offset;
 416:../lib/fat16.c ****     uint16_t cluster_size = fs->header.cluster_size;
 417:../lib/fat16.c ****     uint16_t cluster_num = parent->cluster;
 418:../lib/fat16.c ****     struct fat16_read_callback_arg arg;
 419:../lib/fat16.c **** 
 420:../lib/fat16.c ****     while(1)
 421:../lib/fat16.c ****     {
 422:../lib/fat16.c ****         /* calculate new cluster offset */
 423:../lib/fat16.c ****         cluster_offset = fs->header.cluster_zero_offset + (uint32_t) (cluster_num - 2) * cluster_si
 424:../lib/fat16.c **** 
 425:../lib/fat16.c ****         /* seek to the n-th entry */
 426:../lib/fat16.c ****         memset(&arg, 0, sizeof(arg));
 427:../lib/fat16.c ****         arg.entry_num = entry_num;
 428:../lib/fat16.c ****         if(!fs->partition->device_read_interval(cluster_offset,
 429:../lib/fat16.c ****             buffer,
 430:../lib/fat16.c ****            sizeof(buffer),
 431:../lib/fat16.c ****            cluster_size,
 432:../lib/fat16.c ****            fat16_dir_entry_seek_callback,
 433:../lib/fat16.c ****            &arg)
 434:../lib/fat16.c ****            )
 435:../lib/fat16.c ****         return 0;
 436:../lib/fat16.c **** 
 437:../lib/fat16.c ****         /* check if we found the entry */
 438:../lib/fat16.c ****         if(arg.entry_offset)
 439:../lib/fat16.c ****             break;
 440:../lib/fat16.c **** 
 441:../lib/fat16.c ****         /* get number of next cluster */
 442:../lib/fat16.c ****         if(!(cluster_num = fat16_get_next_cluster(fs, cluster_num)))
 443:../lib/fat16.c ****             return 0; /* directory entry not found */
 444:../lib/fat16.c ****     }
 445:../lib/fat16.c **** 
 446:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 447:../lib/fat16.c **** 
 448:../lib/fat16.c ****     /* read entry */
 449:../lib/fat16.c ****     if(!fs->partition->device_read_interval(arg.entry_offset,
 450:../lib/fat16.c ****         buffer,
 451:../lib/fat16.c ****        sizeof(buffer),
 452:../lib/fat16.c ****        arg.byte_count,
 453:../lib/fat16.c ****        fat16_dir_entry_read_callback,
 454:../lib/fat16.c ****        dir_entry))
 455:../lib/fat16.c ****     return 0;
 456:../lib/fat16.c **** 
 457:../lib/fat16.c ****     return dir_entry->long_name[0] != '\0' ? 1 : 0;
 458:../lib/fat16.c **** }
 459:../lib/fat16.c **** 
 460:../lib/fat16.c **** /**
 461:../lib/fat16.c ****  * \ingroup fat16_fs
 462:../lib/fat16.c ****  * Callback function for seeking through subdirectory entries.
 463:../lib/fat16.c ****  */
 464:../lib/fat16.c **** uint8_t fat16_dir_entry_seek_callback(uint8_t* buffer, uint32_t offset, void* p)
 465:../lib/fat16.c **** {
  15              		@ Function supports interworking.
  16              		@ args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		.loc 1 469 0
 466:../lib/fat16.c **** ;
 467:../lib/fat16.c **** 
 468:../lib/fat16.c ****     /* skip deleted or empty entries */
 469:../lib/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
  21              	r3, [r0, #0]	@ zero_extendqisi2
  22 0000 0030D0E5 		cmp	r3, #0
  23 0004 000053E3 		cmpne	r3, #229
  24 0008 E5005313 		.loc 1 465 0
  25              		@ lr needed for prologue
  26              		.loc 1 469 0
  27              		beq	.L2
  28 000c 1500000A 		.loc 1 472 0
 470:../lib/fat16.c ****     return 1;
 471:../lib/fat16.c **** 
 472:../lib/fat16.c ****     if(arg->entry_cur == arg->entry_num)
  29              	, [r2, #0]
  30 0010 B0C0D2E1 		ldrh	r3, [r2, #2]
  31 0014 B230D2E1 		cmp	r3, ip
  32 0018 0C0053E1 		bne	.L4
  33 001c 0B00001A 		.loc 1 474 0
 473:../lib/fat16.c ****  {
 474:../lib/fat16.c ****         arg->entry_offset = offset;
  34              	r1, [r2, #4]
  35 0020 041082E5 		.loc 1 475 0
 475:../lib/fat16.c ****       arg->byte_count = buffer[11] == 0x0f ?
  36              	drb	r3, [r0, #11]	@ zero_extendqisi2
  37 0024 0B30D0E5 		cmp	r3, #15
  38 0028 0F0053E3 		ldreqb	r3, [r0, #0]	@ zero_extendqisi2
  39 002c 0030D005 		andeq	r3, r3, #63
  40 0030 3F300302 		moveq	r3, r3, asl #5
  41 0034 8332A001 		addeq	r3, r3, #32
  42 0038 20308302 		mov	r1, #32
  43 003c 2010A0E3 	.LVL1:
  44              		mov	r0, #0
  45 0040 0000A0E3 	.LVL2:
  46              		andeq	r1, r3, #255
  47 0044 FF100302 		strb	r1, [r2, #8]
  48 0048 0810C2E5 		bx	lr
  49 004c 1EFF2FE1 	.LVL3:
  50              	.L4:
  51              		.loc 1 482 0
 476:../lib/fat16.c ****        ((buffer[0] & FAT16_DIRENTRY_LFNSEQMASK) + 1) * 32 :
 477:../lib/fat16.c ****         32;
 478:../lib/fat16.c ****         return 0;
 479:../lib/fat16.c ****     }
 480:../lib/fat16.c **** 
 481:../lib/fat16.c ****     /* if we read a 8.3 entry, we reached a new directory entry */
 482:../lib/fat16.c ****     if(buffer[11] != 0x0f)
  52              	11]	@ zero_extendqisi2
  53 0050 0B30D0E5 		.loc 1 483 0
 483:../lib/fat16.c ****  ++arg->entry_cur;
  54              	dd	r1, ip, #1
  55 0054 01108CE2 	.LVL4:
  56              		.loc 1 482 0
  57              		cmp	r3, #15
  58 0058 0F0053E3 		.loc 1 483 0
  59              		mov	r0, #1
  60 005c 0100A0E3 	.LVL5:
  61              		strneh	r1, [r2, #0]	@ movhi
  62 0060 B010C211 		.loc 1 482 0
  63              		bxne	lr
  64 0064 1EFF2F11 	.LVL6:
  65              	.L2:
  66              		.loc 1 483 0
  67              		mov	r0, #1
  68 0068 0100A0E3 	.LVL7:
  69              		.loc 1 486 0
 484:../lib/fat16.c ****     return 1;
 485:../lib/fat16.c **** }
 486:../lib/fat16.c **** 
  70              	size	fat16_dir_entry_seek_callback, .-fat16_dir_entry_seek_callback
  71 006c 1EFF2FE1 		.align	2
  73              	fat16_dir_entry_read_callback:
  74              	.LFB8:
  75              		.loc 1 493 0
  76              		@ Function supports interworking.
  77              		@ args = 0, pretend = 0, frame = 0
 487:../lib/fat16.c **** 
 488:../lib/fat16.c ****  * \ingroup fat16_fs
 489:../lib/fat16.c ****  * Callback function for reading a directory entry.
 490:../lib/fat16.c ****  */
 491:../lib/fat16.c **** uint8_t fat16_dir_entry_read_callback(uint8_t* buffer, uint32_t offset, void* p)
 492:../lib/fat16.c **** {
 493:../lib/fat16.c ****     struct fat16_dir_entry_struct* dir_entry = p;
  78              	_needed = 0, uses_anonymous_args = 0
  79              	.LVL8:
  80              		stmfd	sp!, {r4, r5, lr}
  81              	.LCFI0:
  82              		.loc 1 497 0
  83 0070 30402DE9 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  84              		cmp	r3, #0
 494:../lib/fat16.c **** * there should not be any deleted or empty entries */
 495:../lib/fat16.c ****     if(buffer[0] == FAT16_DIRENTRY_DELETED || !buffer[0])
 496:../lib/fat16.c ****         return 0;
 497:../lib/fat16.c **** 
  85              	r3, #229
  86 0074 0030D0E5 		.loc 1 493 0
  87 0078 000053E3 		mov	ip, r2
  88 007c E5005313 		.loc 1 497 0
  89              		beq	.L13
  90 0080 02C0A0E1 	.LVL9:
  91              		.loc 1 500 0
  92 0084 6200000A 		ldr	r3, [r2, #40]
  93              		cmp	r3, #0
 498:../lib/fat16.c **** if(!dir_entry->entry_offset)
 499:../lib/fat16.c ****         dir_entry->entry_offset = offset;
 500:../lib/fat16.c **** 
  94              	01 0
  95 0088 283092E5 		streq	r1, [r2, #40]
  96 008c 000053E3 	.LBB9:
 501:../lib/fat16.c ****  switch(fat16_interpret_dir_entry(dir_entry, buffer))
  97              	B10:
  98 0090 28108205 		.loc 1 534 0
  99              		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 100              		cmp	r2, #0
 502:../lib/fat16.c ****    {
 503:../lib/fat16.c ****         case 0: /* failure */
 504:../lib/fat16.c ****             return 0;
 505:../lib/fat16.c ****             case 1: /* buffer successfully parsed, continue */
 506:../lib/fat16.c ****             return 1;
 507:../lib/fat16.c ****             case 2: /* directory entry complete, finish */
 508:../lib/fat16.c ****             return 0;
 509:../lib/fat16.c ****         }
 510:../lib/fat16.c **** 
 511:../lib/fat16.c ****     return 0;
 512:../lib/fat16.c **** }
 513:../lib/fat16.c **** 
 514:../lib/fat16.c **** /**
 515:../lib/fat16.c ****  * \ingroup fat16_fs
 516:../lib/fat16.c ****  * Interprets a raw directory entry and puts the contained
 517:../lib/fat16.c ****  * information into the directory entry.
 518:../lib/fat16.c ****  *
 519:../lib/fat16.c ****  * For a single file there may exist multiple directory
 520:../lib/fat16.c ****  * entries. All except the last one are lfn entries, which
 521:../lib/fat16.c ****  * contain parts of the long filename. The last directory
 522:../lib/fat16.c ****  * entry is a traditional 8.3 style one. It contains all
 523:../lib/fat16.c ****  * other information like size, cluster, date and time.
 524:../lib/fat16.c ****  *
 525:../lib/fat16.c ****  * \param[in,out] dir_entry The directory entry to fill.
 526:../lib/fat16.c ****  * \param[in] raw_entry A pointer to 32 bytes of raw data.
 527:../lib/fat16.c ****  * \returns 0 on failure, 1 on success and 2 if the
 528:../lib/fat16.c ****  *          directory entry is complete.
 529:../lib/fat16.c ****  */
 530:../lib/fat16.c **** uint8_t fat16_interpret_dir_entry(struct fat16_dir_entry_struct* dir_entry, const uint8_t* raw_entr
 531:../lib/fat16.c **** {
 532:../lib/fat16.c ****     if(!dir_entry || !raw_entry || !raw_entry[0])
 533:../lib/fat16.c ****         return 0;
 534:../lib/fat16.c **** 
 101              		.L13
 102 0094 0020D0E5 		.loc 1 538 0
 103 0098 000052E3 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 104 009c 5C00000A 		cmp	r3, #15
 535:../lib/fat16.c **** long_name;
 536:../lib/fat16.c ****     if(raw_entry[11] == 0x0f)
 537:../lib/fat16.c ****     {
 538:../lib/fat16.c ****         uint16_t char_offset = ((raw_entry[0] & 0x3f) - 1) * 13;
 105              		r5, r0, #11
 106 00a0 0B30D0E5 		bne	.L18
 107 00a4 0F0053E3 	.LBB11:
 108 00a8 0B5080E2 		.loc 1 540 0
 109 00ac 2600001A 		and	r2, r2, #63
 110              		mov	r3, #13
 539:../lib/fat16.c ****      if(char_offset + 12 < sizeof(dir_entry->long_name))
 540:../lib/fat16.c ****         {
 111              	3, r2, r3
 112 00b0 3F2002E2 		sub	r3, r3, #13
 113 00b4 0D30A0E3 		mov	r3, r3, asl #16
 114 00b8 920303E0 		mov	r2, r3, lsr #16
 115 00bc 0D3043E2 	.LVL10:
 116 00c0 0338A0E1 		.loc 1 542 0
 117 00c4 2328A0E1 		add	r3, r2, #12
 118              		cmp	r3, #31
 541:../lib/fat16.c ****           /* Lfn supports unicode, but we do not, for now.
 542:../lib/fat16.c ****                                                  * So we assume pure ascii and read only every
 119              	0, #1
 120 00c8 0C3082E2 	.LVL11:
 121 00cc 1F0053E3 		bhi	.L22
 122 00d0 0100A083 	.LVL12:
 123              		.loc 1 548 0
 124 00d4 4F00008A 		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 125              		strb	r3, [ip, r2]
 543:../lib/fat16.c ****                                                * second byte.
 544:../lib/fat16.c ****                                                  */
 545:../lib/fat16.c ****             long_name[char_offset + 0] = raw_entry[1];
 546:../lib/fat16.c ****             long_name[char_offset + 1] = raw_entry[3];
 547:../lib/fat16.c ****             long_name[char_offset + 2] = raw_entry[5];
 548:../lib/fat16.c ****             long_name[char_offset + 3] = raw_entry[7];
 126              	 549 0
 127 00d8 0130D0E5 		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 128 00dc 0230CCE7 		add	r2, ip, r2
 549:../lib/fat16.c ****       long_name[char_offset + 4] = raw_entry[9];
 129              	L13:
 130 00e0 0330D0E5 		strb	r3, [r2, #1]
 131 00e4 02208CE0 		.loc 1 550 0
 132              		ldrb	r3, [r0, #5]	@ zero_extendqisi2
 133 00e8 0130C2E5 		strb	r3, [r2, #2]
 550:../lib/fat16.c ****            long_name[char_offset + 5] = raw_entry[14];
 134              	 1 551 0
 135 00ec 0530D0E5 		ldrb	r3, [r0, #7]	@ zero_extendqisi2
 136 00f0 0230C2E5 		strb	r3, [r2, #3]
 551:../lib/fat16.c ****            long_name[char_offset + 6] = raw_entry[16];
 137              	oc 1 552 0
 138 00f4 0730D0E5 		ldrb	r3, [r0, #9]	@ zero_extendqisi2
 139 00f8 0330C2E5 		strb	r3, [r2, #4]
 552:../lib/fat16.c ****            long_name[char_offset + 7] = raw_entry[18];
 140              	oc 1 553 0
 141 00fc 0930D0E5 		ldrb	r3, [r0, #14]	@ zero_extendqisi2
 142 0100 0430C2E5 		strb	r3, [r2, #5]
 553:../lib/fat16.c ****            long_name[char_offset + 8] = raw_entry[20];
 143              	oc 1 554 0
 144 0104 0E30D0E5 		ldrb	r3, [r0, #16]	@ zero_extendqisi2
 145 0108 0530C2E5 		strb	r3, [r2, #6]
 554:../lib/fat16.c ****            long_name[char_offset + 9] = raw_entry[22];
 146              	oc 1 555 0
 147 010c 1030D0E5 		ldrb	r3, [r0, #18]	@ zero_extendqisi2
 148 0110 0630C2E5 		strb	r3, [r2, #7]
 555:../lib/fat16.c ****            long_name[char_offset + 10] = raw_entry[24];
 149              	oc 1 556 0
 150 0114 1230D0E5 		ldrb	r3, [r0, #20]	@ zero_extendqisi2
 151 0118 0730C2E5 		strb	r3, [r2, #8]
 556:../lib/fat16.c ****            long_name[char_offset + 11] = raw_entry[28];
 152              	oc 1 557 0
 153 011c 1430D0E5 		ldrb	r3, [r0, #22]	@ zero_extendqisi2
 154 0120 0830C2E5 		strb	r3, [r2, #9]
 557:../lib/fat16.c ****            long_name[char_offset + 12] = raw_entry[30];
 155              	oc 1 558 0
 156 0124 1630D0E5 		ldrb	r3, [r0, #24]	@ zero_extendqisi2
 157 0128 0930C2E5 		strb	r3, [r2, #10]
 558:../lib/fat16.c ****        }
 158              	oc 1 559 0
 159 012c 1830D0E5 		ldrb	r3, [r0, #28]	@ zero_extendqisi2
 160 0130 0A30C2E5 		strb	r3, [r2, #11]
 559:../lib/fat16.c ****         return 1;
 161              	oc 1 560 0
 162 0134 1C30D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 163 0138 0B30C2E5 		mov	r0, #1
 560:../lib/fat16.c ****    }
 164              	L14:
 165 013c 1E30D0E5 		strb	r3, [r2, #12]
 166 0140 0100A0E3 		b	.L22
 167              	.LVL15:
 168 0144 0C30C2E5 	.L18:
 169 0148 320000EA 	.LBE11:
 170              		.loc 1 568 0
 171              		ldrb	r2, [ip, #0]	@ zero_extendqisi2
 172              		cmp	r2, #0
 561:../lib/fat16.c ****    else
 562:../lib/fat16.c ****     {
 563:../lib/fat16.c ****         /* if we do not have a long name, take the short one */
 564:../lib/fat16.c ****         if(long_name[0] == '\0')
 565:../lib/fat16.c ****         {
 566:../lib/fat16.c ****             uint8_t i;
 567:../lib/fat16.c ****             for(i = 0; i < 8; ++i)
 568:../lib/fat16.c ****             {
 173              	
 174 014c 0020DCE5 		mov	r1, r2
 175 0150 000052E3 	.LVL16:
 176 0154 1D00001A 	.L25:
 177 0158 0210A0E1 	.LBB12:
 178              		.loc 1 573 0
 179              		ldrb	r3, [r2, r0]	@ zero_extendqisi2
 180              		cmp	r3, #32
 569:../lib/fat16.c ****         if(raw_entry[i] == ' ')
 570:../lib/fat16.c ****                     break;
 571:../lib/fat16.c ****                 long_name[i] = raw_entry[i];
 572:../lib/fat16.c ****             }
 573:../lib/fat16.c ****             if(raw_entry[8] != ' ')
 181              	 571 0
 182 015c 0030D2E7 		add	lr, r1, #1
 183 0160 200053E3 		.loc 1 573 0
 184              		beq	.L26
 185 0164 01E081E2 		.loc 1 571 0
 186              		and	r1, lr, #255
 187 0168 0400000A 		cmp	r1, #8
 188              		.loc 1 575 0
 189 016c FF100EE2 		strb	r3, [r2, ip]
 190 0170 080051E3 		.loc 1 571 0
 574:../lib/fat16.c ****        {
 575:../lib/fat16.c ****                 long_name[i++] = '.';
 191              	2, #1
 192 0174 0C30C2E7 		bne	.L25
 193              	.L26:
 194 0178 012082E2 		.loc 1 577 0
 195 017c F6FFFF1A 		ldrb	r3, [r0, #8]	@ zero_extendqisi2
 196              		cmp	r3, #32
 576:../lib/fat16.c ****                uint8_t j = 8;
 577:../lib/fat16.c ****                 for(; j < 11; ++j)
 197              	L28
 198 0180 0830D0E5 	.LBB13:
 199 0184 200053E3 		.loc 1 579 0
 200 0188 0E00000A 		mov	r3, #46
 201              		add	r2, r1, #1
 578:../lib/fat16.c ****               {
 579:../lib/fat16.c ****                     if(raw_entry[j] != ' ')
 202              		r3, [ip, r1]
 203 018c 2E30A0E3 		and	r1, r2, #255
 204 0190 012081E2 		mov	r3, r0
 205 0194 0130CCE7 	.L30:
 206 0198 FF1002E2 		.loc 1 584 0
 207 019c 0030A0E1 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 208              		cmp	r2, #32
 580:../lib/fat16.c ****                   {
 581:../lib/fat16.c ****                         long_name[i++] = raw_entry[j];
 582:../lib/fat16.c ****                     }
 583:../lib/fat16.c ****                     else
 584:../lib/fat16.c ****                     {
 209              	 582 0
 210 01a0 0820D3E5 		add	lr, r0, #3
 211 01a4 200052E3 		.loc 1 586 0
 212              		add	r4, r1, #1
 213 01a8 03E080E2 		add	r3, r3, #1
 585:../lib/fat16.c ****                    break;
 586:../lib/fat16.c ****                     }
 214              	 1 584 0
 215 01ac 014081E2 		beq	.L28
 216 01b0 013083E2 		.loc 1 582 0
 217              		cmp	r3, lr
 218 01b4 0300000A 		.loc 1 586 0
 219              		strb	r2, [ip, r1]
 220 01b8 0E0053E1 		and	r1, r4, #255
 221              		.loc 1 582 0
 222 01bc 0120CCE7 		bne	.L30
 223 01c0 FF1004E2 	.L28:
 224              	.LBE13:
 225 01c4 F5FFFF1A 		.loc 1 595 0
 226              		mov	r3, #0
 227              		strb	r3, [ip, r1]
 587:../lib/fat16.c ****               }
 588:../lib/fat16.c ****             }
 589:../lib/fat16.c **** 
 590:../lib/fat16.c ****             long_name[i] = '\0';
 591:../lib/fat16.c ****         }
 592:../lib/fat16.c **** 
 593:../lib/fat16.c ****         /* extract properties of file and store them within the structure */
 594:../lib/fat16.c ****         dir_entry->attributes = raw_entry[11];
 595:../lib/fat16.c ****         dir_entry->cluster = ((uint16_t) raw_entry[26]) |
 228              	.LBE12:
 229 01c8 0030A0E3 		.loc 1 599 0
 230 01cc 0130CCE7 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 231              		strb	r3, [ip, #32]
 232              		.loc 1 600 0
 233              		ldrb	r2, [r0, #27]	@ zero_extendqisi2
 596:../lib/fat16.c **** (uint16_t) raw_entry[27] << 8);
 597:../lib/fat16.c ****         dir_entry->file_size = ((uint32_t) raw_entry[28]) |
 598:../lib/fat16.c ****         ((uint32_t) raw_entry[29] << 8) |
 599:../lib/fat16.c ****         ((uint32_t) raw_entry[30] << 16) |
 234              	r3, [r0, #26]	@ zero_extendqisi2
 235 01d0 0030D5E5 		orr	r3, r3, r2, asl #8
 236 01d4 2030CCE5 		strh	r3, [ip, #34]	@ movhi
 600:../lib/fat16.c ****     ((uint32_t) raw_entry[31] << 24);
 237              	oc 1 602 0
 238 01d8 1B20D0E5 		ldrb	r3, [r0, #30]	@ zero_extendqisi2
 239 01dc 1A30D0E5 		ldrb	r2, [r0, #28]	@ zero_extendqisi2
 240 01e0 023483E1 		ldrb	r1, [r0, #29]	@ zero_extendqisi2
 241 01e4 B232CCE1 	.LVL18:
 601:../lib/fat16.c ****         return 2;
 602:../lib/fat16.c ****     }
 242              		r0, [r0, #31]	@ zero_extendqisi2
 243 01e8 1E30D0E5 	.LVL19:
 244 01ec 1C20D0E5 		mov	r3, r3, asl #16
 245 01f0 1D10D0E5 		orr	r3, r3, r0, asl #24
 246              		orr	r2, r2, r1, asl #8
 247 01f4 1F00D0E5 		orr	r2, r2, r3
 248              		mov	r0, #0
 249 01f8 0338A0E1 		str	r2, [ip, #36]
 250 01fc 003C83E1 		b	.L22
 251 0200 012482E1 	.LVL20:
 252 0204 032082E1 	.L13:
 253 0208 0000A0E3 		mov	r0, #0
 254 020c 24208CE5 	.LVL21:
 255 0210 000000EA 	.L22:
 256              	.LBE10:
 257              	.LBE9:
 258 0214 0000A0E3 		.loc 1 514 0
 259              		ldmfd	sp!, {r4, r5, lr}
 260              		bx	lr
 261              	.LFE8:
 263              		.align	2
 265 021c 1EFF2FE1 	fat16_get_next_cluster:
 266              	.LFB11:
 267              		.loc 1 695 0
 268              		@ Function supports interworking.
 269              		@ args = 0, pretend = 0, frame = 4
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              	.LVL22:
 603:../lib/fat16.c **** 
 604:../lib/fat16.c **** /**
 605:../lib/fat16.c ****  * \ingroup fat16_file
 606:../lib/fat16.c ****  * Retrieves the directory entry of a path.
 607:../lib/fat16.c ****  *
 608:../lib/fat16.c ****  * The given path may both describe a file or a directory.
 609:../lib/fat16.c ****  *
 610:../lib/fat16.c ****  * \param[in] fs The FAT16 filesystem on which to search.
 611:../lib/fat16.c ****  * \param[in] path The path of which to read the directory entry.
 612:../lib/fat16.c ****  * \param[out] dir_entry The directory entry to fill.
 613:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 614:../lib/fat16.c ****  * \see fat16_read_dir
 615:../lib/fat16.c ****  */
 616:../lib/fat16.c **** uint8_t fat16_get_dir_entry_of_path(struct fat16_fs_struct* fs, const char* path, struct fat16_dir_
 617:../lib/fat16.c **** {
 618:../lib/fat16.c ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 619:../lib/fat16.c ****         return 0;
 620:../lib/fat16.c **** 
 621:../lib/fat16.c ****     if(path[0] == '/')
 622:../lib/fat16.c ****         ++path;
 623:../lib/fat16.c **** 
 624:../lib/fat16.c ****     /* begin with the root directory */
 625:../lib/fat16.c ****     memset(dir_entry, 0, sizeof(*dir_entry));
 626:../lib/fat16.c ****     dir_entry->attributes = FAT16_ATTRIB_DIR;
 627:../lib/fat16.c **** 
 628:../lib/fat16.c ****     if(path[0] == '\0')
 629:../lib/fat16.c ****         return 1;
 630:../lib/fat16.c **** 
 631:../lib/fat16.c ****     while(1)
 632:../lib/fat16.c ****     {
 633:../lib/fat16.c ****         struct fat16_dir_struct* dd = fat16_open_dir(fs, dir_entry);
 634:../lib/fat16.c ****         if(!dd)
 635:../lib/fat16.c ****             break;
 636:../lib/fat16.c **** 
 637:../lib/fat16.c ****         /* extract the next hierarchy we will search for */
 638:../lib/fat16.c ****         const char* sep_pos = strchr(path, '/');
 639:../lib/fat16.c ****         if(!sep_pos)
 640:../lib/fat16.c ****             sep_pos = path + strlen(path);
 641:../lib/fat16.c ****         uint8_t length_to_sep = sep_pos - path;
 642:../lib/fat16.c **** 
 643:../lib/fat16.c ****         /* read directory entries */
 644:../lib/fat16.c ****         while(fat16_read_dir(dd, dir_entry))
 645:../lib/fat16.c ****         {
 646:../lib/fat16.c ****             /* check if we have found the next hierarchy */
 647:../lib/fat16.c ****             if((strlen(dir_entry->long_name) != length_to_sep ||
 648:../lib/fat16.c ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 649:../lib/fat16.c ****             continue;
 650:../lib/fat16.c **** 
 651:../lib/fat16.c ****             fat16_close_dir(dd);
 652:../lib/fat16.c ****             dd = 0;
 653:../lib/fat16.c **** 
 654:../lib/fat16.c ****             if(path[length_to_sep] == '\0')
 655:../lib/fat16.c ****     /* we iterated through the whole path and have found the file */
 656:../lib/fat16.c ****                 return 1;
 657:../lib/fat16.c **** 
 658:../lib/fat16.c ****             if(dir_entry->attributes & FAT16_ATTRIB_DIR)
 659:../lib/fat16.c ****             {
 660:../lib/fat16.c ****                 /* we found a parent directory of the file we are searching for */
 661:../lib/fat16.c ****                 path = sep_pos + 1;
 662:../lib/fat16.c ****                 break;
 663:../lib/fat16.c ****             }
 664:../lib/fat16.c **** 
 665:../lib/fat16.c ****             /* a parent of the file exists, but not the file itself */
 666:../lib/fat16.c ****             return 0;
 667:../lib/fat16.c ****         }
 668:../lib/fat16.c **** 
 669:../lib/fat16.c ****         fat16_close_dir(dd);
 670:../lib/fat16.c ****     }
 671:../lib/fat16.c **** 
 672:../lib/fat16.c ****     return 0;
 673:../lib/fat16.c **** }
 674:../lib/fat16.c **** 
 675:../lib/fat16.c **** /**
 676:../lib/fat16.c ****  * \ingroup fat16_fs
 677:../lib/fat16.c ****  * Retrieves the next following cluster of a given cluster.
 678:../lib/fat16.c ****  *
 679:../lib/fat16.c ****  * Using the filesystem file allocation table, this function returns
 680:../lib/fat16.c ****  * the number of the cluster containing the data directly following
 681:../lib/fat16.c ****  * the data within the cluster with the given number.
 682:../lib/fat16.c ****  *
 683:../lib/fat16.c ****  * \param[in] fs The filesystem for which to determine the next cluster.
 684:../lib/fat16.c ****  * \param[in] cluster_num The number of the cluster for which to determine its successor.
 685:../lib/fat16.c ****  * \returns The wanted cluster number, or 0 on error.
 686:../lib/fat16.c ****  */
 687:../lib/fat16.c **** uint16_t fat16_get_next_cluster(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 688:../lib/fat16.c **** {
 689:../lib/fat16.c ****     if(!fs || cluster_num < 2)
 690:../lib/fat16.c ****         return 0;
 691:../lib/fat16.c **** 
 692:../lib/fat16.c ****     /* read appropriate fat entry */
 693:../lib/fat16.c ****     uint8_t fat_entry[2];
 694:../lib/fat16.c ****     if(!fs->partition->device_read(fs->header.fat_offset + 2 * cluster_num, fat_entry, 2))
 695:../lib/fat16.c ****         return 0;
 272              	ov	r3, r1, asl #16
 273              		mov	r3, r3, lsr #16
 274              		sub	sp, sp, #4
 275              	.LCFI2:
 276              		.loc 1 701 0
 277 0220 04E02DE5 		mov	r2, #2
 278              		.loc 1 696 0
 279 0224 0138A0E1 		cmp	r0, #0
 280 0228 2338A0E1 		cmpne	r3, #1
 281 022c 04D04DE2 		.loc 1 701 0
 282              		add	r1, sp, r2
 696:../lib/fat16.c ****  ((uint16_t) fat_entry[1] << 8);
 697:../lib/fat16.c **** 	///*
 698:../lib/fat16.c ****     if(cluster_num == FAT16_CLUSTER_FREE ||
 699:../lib/fat16.c ****         cluster_num == FAT16_CLUSTER_BAD ||
 700:../lib/fat16.c ****        (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX) ||
 701:../lib/fat16.c ****        (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 283              	oc 1 696 0
 284 0230 0220A0E3 		mov	ip, r0
 285              		bls	.L36
 286 0234 000050E3 	.LVL24:
 287 0238 01005313 		.loc 1 701 0
 288              		ldr	r0, [r0, #8]
 289 023c 02108DE0 		mla	r0, r3, r2, r0
 290              		ldr	r3, [ip, #0]
 291              	.LVL25:
 292 0240 00C0A0E1 		ldr	ip, [r3, #0]
 293 0244 1A00009A 		mov	lr, pc
 294              		bx	ip
 295              	.LVL26:
 296 0248 080090E5 		cmp	r0, #0
 297 024c 930220E0 		.loc 1 708 0
 298 0250 00309CE5 		ldr	r1, .L43
 299              		.loc 1 701 0
 300 0254 00C093E5 		beq	.L36
 301 0258 0FE0A0E1 		.loc 1 705 0
 302 025c 1CFF2FE1 		ldrb	r2, [sp, #2]	@ zero_extendqisi2
 303              		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 304 0260 000050E3 		.loc 1 708 0
 702:../lib/fat16.c **** */
 703:../lib/fat16.c **** 	return 0;
 704:../lib/fat16.c **** 
 705:../lib/fat16.c ****     return cluster_num;
 706:../lib/fat16.c **** }
 707:../lib/fat16.c **** 
 708:../lib/fat16.c **** /**
 305              	#8
 306 0264 58109FE5 	.LVL27:
 307              		movne	r3, #0
 308 0268 1100000A 		moveq	r3, #1
 309              		cmp	r0, r1
 310 026c 0220DDE5 		orreq	r3, r3, #1
 311 0270 0330DDE5 		add	r2, r0, #16
 312              		cmp	r3, #0
 313 0274 030492E1 		mov	r2, r2, asl #16
 314              		bne	.L36
 315 0278 0030A013 		cmp	r0, r1
 316 027c 0130A003 		movls	r3, #0
 317 0280 010050E1 		movhi	r3, #1
 318 0284 01308303 		cmp	r2, #393216
 319 0288 102080E2 		orrls	r3, r3, #1
 320 028c 000053E3 		cmp	r3, #0
 321 0290 0228A0E1 		beq	.L41
 322 0294 0600001A 	.LVL28:
 323 0298 010050E1 	.L36:
 324 029c 0030A093 		.loc 1 715 0
 325 02a0 0130A083 		mov	r0, #0
 326 02a4 060852E3 	.LVL29:
 327 02a8 01308393 	.L41:
 328 02ac 000053E3 	.LVL30:
 329 02b0 0000000A 		.loc 1 716 0
 330              		add	sp, sp, #4
 331              		ldr	lr, [sp], #4
 709:../lib/fat16.c **** roup fat16_fs
 710:../lib/fat16.c ****  * Appends a new cluster chain to an existing one.
 711:../lib/fat16.c ****  *
 712:../lib/fat16.c ****  * Set cluster_num to zero to create a completely new one.
 713:../lib/fat16.c ****  *
 714:../lib/fat16.c ****  * \param[in] fs The file system on which to operate.
 715:../lib/fat16.c ****  * \param[in] cluster_num The cluster to which to append the new chain.
 332              	:
 333 02b4 0000A0E3 		.word	65527
 334              	.LFE11:
 336              		.align	2
 716:../lib/fat16.c **** am[in] count The number of clusters to allocate.
 337              	e	fat16_free_clusters, %function
 338 02b8 04D08DE2 	fat16_free_clusters:
 339 02bc 04E09DE4 	.LFB13:
 340 02c0 1EFF2FE1 		.loc 1 823 0
 341              		@ Function supports interworking.
 342              		@ args = 0, pretend = 0, frame = 4
 343              		@ frame_needed = 0, uses_anonymous_args = 0
 344 02c4 F7FF0000 	.LVL31:
 345              		stmfd	sp!, {r4, r5, r6, r7, lr}
 346              	.LCFI3:
 347              		mov	r1, r1, asl #16
 348              	.LVL32:
 349              		mov	r3, r1, lsr #16
 350              	.LVL33:
 717:../lib/fat16.c **** * \returns 0 on failure, the number of the first new cluster on success.
 718:../lib/fat16.c ****  */
 719:../lib/fat16.c **** uint16_t fat16_append_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num, uint16_t cou
 720:../lib/fat16.c **** {
 721:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 722:../lib/fat16.c ****         if(!fs)
 723:../lib/fat16.c ****             return 0;
 724:../lib/fat16.c ****     
 725:../lib/fat16.c ****         device_read_t device_read = fs->partition->device_read;
 726:../lib/fat16.c ****         device_write_t device_write = fs->partition->device_write;
 727:../lib/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 728:../lib/fat16.c ****         uint16_t cluster_max = fs->header.fat_size / 2;
 729:../lib/fat16.c ****         uint16_t cluster_next = 0;
 730:../lib/fat16.c ****         uint16_t count_left = count;
 731:../lib/fat16.c ****         uint8_t buffer[2];
 732:../lib/fat16.c ****         uint16_t cluster_new;
 733:../lib/fat16.c ****         for(cluster_new = 0; cluster_new < cluster_max; ++cluster_new)
 734:../lib/fat16.c ****         {
 735:../lib/fat16.c ****             if(!device_read(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 736:../lib/fat16.c ****                 return 0;
 737:../lib/fat16.c ****     
 738:../lib/fat16.c ****             /* check if this is a free cluster */
 739:../lib/fat16.c ****             if(buffer[0] == (FAT16_CLUSTER_FREE & 0xff) &&
 740:../lib/fat16.c ****                 buffer[1] == ((FAT16_CLUSTER_FREE >> 8) & 0xff))
 741:../lib/fat16.c ****             {
 742:../lib/fat16.c ****                 /* allocate cluster */
 743:../lib/fat16.c ****                 if(count_left == count)
 744:../lib/fat16.c ****                 {
 745:../lib/fat16.c ****                     buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 746:../lib/fat16.c ****                     buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 747:../lib/fat16.c ****                 }
 748:../lib/fat16.c ****                 else
 749:../lib/fat16.c ****                 {
 750:../lib/fat16.c ****                     buffer[0] = cluster_next & 0xff;
 751:../lib/fat16.c ****                     buffer[1] = (cluster_next >> 8) & 0xff;
 752:../lib/fat16.c ****                 }
 753:../lib/fat16.c ****     
 754:../lib/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_new, buffer, sizeof(buffer)))
 755:../lib/fat16.c ****                     break;
 756:../lib/fat16.c ****     
 757:../lib/fat16.c ****                 cluster_next = cluster_new;
 758:../lib/fat16.c ****                 if(--count_left == 0)
 759:../lib/fat16.c ****                     break;
 760:../lib/fat16.c ****             }
 761:../lib/fat16.c ****         }
 762:../lib/fat16.c ****     
 763:../lib/fat16.c ****         do
 764:../lib/fat16.c ****         {
 765:../lib/fat16.c ****             if(count_left > 0)
 766:../lib/fat16.c ****                 break;
 767:../lib/fat16.c ****     
 768:../lib/fat16.c ****             /* We allocated a new cluster chain. Now join
 769:../lib/fat16.c ****                                              * it with the existing one.
 770:../lib/fat16.c ****                                              */
 771:../lib/fat16.c ****             if(cluster_num >= 2)
 772:../lib/fat16.c ****             {
 773:../lib/fat16.c ****                 buffer[0] = cluster_next & 0xff;
 774:../lib/fat16.c ****                 buffer[1] = (cluster_next >> 8) & 0xff;
 775:../lib/fat16.c ****                 if(!device_write(fat_offset + 2 * cluster_num, buffer, sizeof(buffer)))
 776:../lib/fat16.c ****                     break;
 777:../lib/fat16.c ****             }
 778:../lib/fat16.c ****     
 779:../lib/fat16.c ****             return cluster_next;
 780:../lib/fat16.c ****     
 781:../lib/fat16.c ****         }
 782:../lib/fat16.c ****         while(0);
 783:../lib/fat16.c ****     
 784:../lib/fat16.c ****         /* No space left on device or writing error.
 785:../lib/fat16.c ****                              * Free up all clusters already allocated.
 786:../lib/fat16.c ****                              */
 787:../lib/fat16.c ****         fat16_free_clusters(fs, cluster_next);
 788:../lib/fat16.c ****     
 789:../lib/fat16.c ****         return 0;
 790:../lib/fat16.c ****     #else
 791:../lib/fat16.c ****         return 0;
 792:../lib/fat16.c ****     #endif
 793:../lib/fat16.c **** }
 794:../lib/fat16.c **** 
 795:../lib/fat16.c **** /**
 796:../lib/fat16.c ****  * \ingroup fat16_fs
 797:../lib/fat16.c ****  * Frees a cluster chain, or a part thereof.
 798:../lib/fat16.c ****  *
 799:../lib/fat16.c ****  * Marks the specified cluster and all clusters which are sequentially
 800:../lib/fat16.c ****  * referenced by it as free. They may then be used again for future
 801:../lib/fat16.c ****  * file allocations.
 802:../lib/fat16.c ****  *
 803:../lib/fat16.c ****  * \note If this function is used for freeing just a part of a cluster
 804:../lib/fat16.c ****  *       chain, the new end of the chain is not correctly terminated
 805:../lib/fat16.c ****  *       within the FAT. Use fat16_terminate_clusters() instead.
 806:../lib/fat16.c ****  *
 807:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 808:../lib/fat16.c ****  * \param[in] cluster_num The starting cluster of the chain which to free.
 809:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 810:../lib/fat16.c ****  * \see fat16_terminate_clusters
 811:../lib/fat16.c ****  */
 812:../lib/fat16.c **** uint8_t fat16_free_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 813:../lib/fat16.c **** {
 814:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 815:../lib/fat16.c ****         if(!fs || cluster_num < 2)
 816:../lib/fat16.c ****             return 0;
 817:../lib/fat16.c ****     
 818:../lib/fat16.c ****         uint32_t fat_offset = fs->header.fat_offset;
 819:../lib/fat16.c ****         uint8_t buffer[2];
 820:../lib/fat16.c ****         while(cluster_num)
 821:../lib/fat16.c ****         {
 822:../lib/fat16.c ****             if(!fs->partition->device_read(fat_offset + 2 * cluster_num, buffer, 2))
 823:../lib/fat16.c ****                 return 0;
 351              		cmp	r0, #0
 352              		cmpne	r3, #1
 353              		.loc 1 823 0
 354              		sub	sp, sp, #4
 355              	.LCFI4:
 356 02c8 F0402DE9 		.loc 1 825 0
 357              		mov	r5, r0
 358 02cc 0118A0E1 		.loc 1 828 0
 359              		ldrhi	r7, [r0, #8]
 360 02d0 2138A0E1 	.LVL34:
 361              		.loc 1 825 0
 824:../lib/fat16.c **** 6_t cluster_num_next = ((uint16_t) buffer[0]) |
 825:../lib/fat16.c ****             ((uint16_t) buffer[1] << 8);
 362              	b	.L46
 363 02d4 000050E3 	.LVL35:
 364 02d8 01005313 	.L49:
 365              	.LBB14:
 366 02dc 04D04DE2 		.loc 1 832 0
 367              		ldr	r3, [r5, #0]
 368              	.LVL36:
 369 02e0 0050A0E1 		ldr	ip, [r3, #0]
 826:../lib/fat16.c ****   
 827:../lib/fat16.c ****             if(cluster_num_next == FAT16_CLUSTER_FREE)
 828:../lib/fat16.c ****                 return 1;
 370              	 pc
 371 02e4 08709085 		bx	ip
 372              		.loc 1 855 0
 373              		mov	lr, #0
 374 02e8 1D00008A 		.loc 1 832 0
 375 02ec 240000EA 		cmp	r0, lr
 376              		.loc 1 857 0
 377              		mov	r1, r6
 378              		mov	r2, #2
 829:../lib/fat16.c ****          if(cluster_num_next == FAT16_CLUSTER_BAD ||
 830:../lib/fat16.c ****                 (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
 831:../lib/fat16.c ****                cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
 832:../lib/fat16.c ****                )
 379              	r4
 380 02f0 003095E5 		.loc 1 832 0
 381              		beq	.L46
 382 02f4 00C093E5 		.loc 1 837 0
 383 02f8 0FE0A0E1 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 384 02fc 1CFF2FE1 		ldrb	ip, [sp, #3]	@ zero_extendqisi2
 833:../lib/fat16.c ****            )
 834:../lib/fat16.c ****             return 0;
 835:../lib/fat16.c **** 			///*
 836:../lib/fat16.c ****             if((cluster_num_next >= FAT16_CLUSTER_LAST_MIN) &&
 837:../lib/fat16.c ****                 (cluster_num_next <= FAT16_CLUSTER_LAST_MAX)
 838:../lib/fat16.c ****                )
 839:../lib/fat16.c **** 			//*/
 840:../lib/fat16.c ****             cluster_num_next = 0;
 841:../lib/fat16.c ****     
 842:../lib/fat16.c ****             /* free cluster */
 843:../lib/fat16.c ****             buffer[0] = FAT16_CLUSTER_FREE & 0xff;
 844:../lib/fat16.c ****             buffer[1] = (FAT16_CLUSTER_FREE >> 8) & 0xff;
 845:../lib/fat16.c ****             fs->partition->device_write(fat_offset + 2 * cluster_num, buffer, 2);
 846:../lib/fat16.c ****     
 847:../lib/fat16.c ****             /* We continue in any case here, even if freeing the cluster failed.
 848:../lib/fat16.c ****                                              * The cluster is lost, but maybe we can still free up 
 849:../lib/fat16.c ****                                              */
 850:../lib/fat16.c ****     
 851:../lib/fat16.c ****             cluster_num = cluster_num_next;
 852:../lib/fat16.c ****         }
 853:../lib/fat16.c ****     
 854:../lib/fat16.c ****         return 1;
 855:../lib/fat16.c ****     #else
 385              	1 839 0
 386 0300 00E0A0E3 		orrs	r3, r3, ip, asl #8
 387              		.loc 1 837 0
 388 0304 0E0050E1 		mov	r4, r3
 856:../lib/fat16.c **** endif
 857:../lib/fat16.c **** }
 389              	37:
 390 0308 0610A0E1 		.loc 1 841 0
 391 030c 0220A0E3 		add	r3, r3, #16
 392 0310 0400A0E1 		mov	r3, r3, asl #16
 393              		.loc 1 839 0
 394 0314 1A00000A 		beq	.L51
 395              		.loc 1 841 0
 396 0318 0230DDE5 		cmp	r3, #458752
 397 031c 03C0DDE5 		bls	.L46
 398              		.loc 1 848 0
 399 0320 0C3493E1 		ldr	r3, .L58
 400              		.loc 1 856 0
 401 0324 0340A0E1 		strb	lr, [sp, #3]
 402              		.loc 1 855 0
 403              		strb	lr, [sp, #2]
 404 0328 103083E2 		.loc 1 848 0
 405 032c 0338A0E1 		cmp	r4, r3
 406              		movhi	r4, lr
 407 0330 1500000A 		.loc 1 857 0
 408              		ldr	r3, [r5, #0]
 409 0334 070853E3 		ldr	ip, [r3, #8]
 410 0338 1100009A 		mov	lr, pc
 411              		bx	ip
 412 033c 58309FE5 		mov	r3, r4
 413              	.LVL38:
 414 0340 03E0CDE5 	.L48:
 415              		.loc 1 832 0
 416 0344 02E0CDE5 		add	r4, r7, r3, asl #1
 417              	.LVL39:
 418 0348 030054E1 		add	r6, sp, #2
 419 034c 0E40A081 	.LBE14:
 420              		.loc 1 830 0
 421 0350 003095E5 		cmp	r3, #0
 422 0354 08C093E5 	.LBB15:
 423 0358 0FE0A0E1 		.loc 1 832 0
 424 035c 1CFF2FE1 		mov	r1, r6
 425 0360 0430A0E1 		mov	r2, #2
 426              		mov	r0, r4
 427              	.LBE15:
 428              		.loc 1 830 0
 429 0364 834087E0 		bne	.L49
 430              		b	.L51
 431 0368 02608DE2 	.LVL40:
 432              	.L46:
 433              		mov	r0, #0
 434 036c 000053E3 		b	.L56
 435              	.L51:
 436              		mov	r0, #1
 437 0370 0610A0E1 	.L56:
 438 0374 0220A0E3 		.loc 1 870 0
 439 0378 0400A0E1 		add	sp, sp, #4
 440              		ldmfd	sp!, {r4, r5, r6, r7, lr}
 441              		bx	lr
 442 037c DBFFFF1A 	.L59:
 443 0380 010000EA 		.align	2
 444              	.L58:
 445              		.word	65527
 446 0384 0000A0E3 	.LFE13:
 448              		.align	2
 450              	fat16_append_clusters:
 858:../lib/fat16.c **** **
 859:../lib/fat16.c ****  * \ingroup fat16_fs
 860:../lib/fat16.c ****  * Frees a part of a cluster chain and correctly terminates the rest.
 861:../lib/fat16.c ****  *
 862:../lib/fat16.c ****  * Marks the specified cluster as the new end of a cluster chain and
 863:../lib/fat16.c ****  * frees all following clusters.
 864:../lib/fat16.c ****  *
 865:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 866:../lib/fat16.c ****  * \param[in] cluster_num The new end of the cluster chain.
 867:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
 868:../lib/fat16.c ****  * \see fat16_free_clusters
 869:../lib/fat16.c ****  */
 870:../lib/fat16.c **** uint8_t fat16_terminate_clusters(const struct fat16_fs_struct* fs, uint16_t cluster_num)
 451              	gs = 0, pretend = 0, frame = 20
 452 0390 04D08DE2 		@ frame_needed = 0, uses_anonymous_args = 0
 453 0394 F040BDE8 	.LVL41:
 454 0398 1EFF2FE1 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 455              	.LCFI5:
 456              		mov	r1, r1, asl #16
 457              	.LVL42:
 458 039c F7FF0000 		sub	sp, sp, #20
 459              	.LCFI6:
 460              		.loc 1 730 0
 461              		mov	r2, r2, asl #16
 462              	.LVL43:
 463              		mov	r1, r1, lsr #16
 464              		.loc 1 732 0
 465              		subs	r7, r0, #0
 466              		.loc 1 730 0
 467              		str	r1, [sp, #0]
 468              	.LVL44:
 469              		mov	r9, r2, lsr #16
 470 03a0 F04F2DE9 	.LVL45:
 471              		.loc 1 732 0
 472 03a4 0118A0E1 		beq	.L61
 473              	.LVL46:
 474 03a8 14D04DE2 		.loc 1 735 0
 475              		ldr	r2, [r7, #0]
 476              		.loc 1 738 0
 477 03ac 0228A0E1 		ldr	r3, [r7, #12]
 478              		.loc 1 736 0
 479 03b0 2118A0E1 		ldr	r1, [r2, #8]
 480              		.loc 1 738 0
 481 03b4 007050E2 		mov	r3, r3, asl #15
 482              		mov	r4, #0
 483 03b8 00108DE5 	.LVL47:
 484              		.loc 1 735 0
 485 03bc 2298A0E1 		ldr	r2, [r2, #0]
 486              		.loc 1 737 0
 487              		ldr	fp, [r7, #8]
 488 03c0 4E00000A 	.LVL48:
 489              		.loc 1 738 0
 490              		mov	r3, r3, lsr #16
 491 03c4 002097E5 		mov	r5, r9
 492              	.LVL49:
 493 03c8 0C3097E5 		mov	sl, r4
 494              		.loc 1 736 0
 495 03cc 081092E5 		str	r1, [sp, #8]
 496              	.LVL50:
 497 03d0 8337A0E1 		.loc 1 735 0
 498 03d4 0040A0E3 		str	r2, [sp, #4]
 499              	.LVL51:
 500              		.loc 1 738 0
 501 03d8 002092E5 		str	r3, [sp, #12]
 502              	.LVL52:
 503 03dc 08B097E5 		b	.L63
 504              	.LVL53:
 505              	.L64:
 506 03e0 2338A0E1 		.loc 1 745 0
 507 03e4 0950A0E1 		add	r8, fp, r6, asl #1
 508              		mov	r0, r8
 509 03e8 04A0A0E1 		add	r1, sp, #18
 510              		mov	r2, #2
 511 03ec 08108DE5 		ldr	r3, [sp, #4]
 512              		mov	lr, pc
 513              		bx	r3
 514 03f0 04208DE5 		cmp	r0, #0
 515              		beq	.L61
 516              		.loc 1 749 0
 517 03f4 0C308DE5 		ldrb	r3, [sp, #18]	@ zero_extendqisi2
 518              		cmp	r3, #0
 519 03f8 230000EA 		bne	.L66
 520              		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 521              		cmp	r3, #0
 522              		bne	.L66
 523 03fc 86808BE0 		.loc 1 753 0
 524 0400 0800A0E1 		cmp	r5, r9
 525 0404 12108DE2 		.loc 1 755 0
 526 0408 0220A0E3 		mvneq	r3, #0
 527 040c 04309DE5 		.loc 1 761 0
 528 0410 0FE0A0E1 		movne	r3, r4, lsr #8
 529 0414 13FF2FE1 		.loc 1 756 0
 530 0418 000050E3 		streqb	r3, [sp, #19]
 531 041c 3700000A 		.loc 1 755 0
 532              		streqb	r3, [sp, #18]
 533 0420 1230DDE5 		.loc 1 761 0
 534 0424 000053E3 		strneb	r3, [sp, #19]
 535 0428 1600001A 		.loc 1 760 0
 536 042c 1330DDE5 		strneb	r4, [sp, #18]
 537 0430 000053E3 		.loc 1 764 0
 538 0434 1300001A 		mov	r0, r8
 539              		add	r1, sp, #18
 540 0438 090055E1 		mov	r2, #2
 541              		ldr	r3, [sp, #8]
 542 043c 0030E003 		mov	lr, pc
 543              		bx	r3
 544 0440 2434A011 		cmp	r0, #0
 545              		beq	.L72
 546 0444 1330CD05 		.loc 1 768 0
 547              		sub	r3, r5, #1
 548 0448 1230CD05 		mov	r3, r3, asl #16
 549              		movs	r5, r3, lsr #16
 550 044c 1330CD15 		beq	.L82
 551              		mov	r4, r6
 552 0450 1240CD15 	.L66:
 553              		add	sl, sl, #1
 554 0454 0800A0E1 	.LVL54:
 555 0458 12108DE2 	.L63:
 556 045c 0220A0E3 		.loc 1 743 0
 557 0460 08309DE5 		ldr	r1, [sp, #12]
 558 0464 0FE0A0E1 		.loc 1 768 0
 559 0468 13FF2FE1 		mov	r3, sl, asl #16
 560 046c 000050E3 		.loc 1 743 0
 561 0470 0A00000A 		cmp	sl, r1
 562              		.loc 1 768 0
 563 0474 013045E2 		mov	r6, r3, lsr #16
 564 0478 0338A0E1 		.loc 1 743 0
 565 047c 2358B0E1 		bne	.L64
 566 0480 1900000A 	.L72:
 567 0484 0640A0E1 		.loc 1 775 0
 568              		cmp	r5, #0
 569 0488 01A08AE2 		bne	.L77
 570              	.L76:
 571              		.loc 1 781 0
 572              		ldr	r3, [sp, #0]
 573 048c 0C109DE5 		cmp	r3, #1
 574              		bls	.L78
 575 0490 0A38A0E1 		.loc 1 785 0
 576              		ldr	r1, [sp, #0]
 577 0494 01005AE1 		.loc 1 784 0
 578              		mov	r3, r4, lsr #8
 579 0498 2368A0E1 		strb	r3, [sp, #19]
 580              		.loc 1 785 0
 581 049c D6FFFF1A 		add	r0, fp, r1, asl #1
 582              		.loc 1 783 0
 583              		strb	r4, [sp, #18]
 584 04a0 000055E3 		.loc 1 785 0
 585 04a4 1200001A 		add	r1, sp, #18
 586              		mov	r2, #2
 587              		ldr	r3, [sp, #8]
 588 04a8 00309DE5 		mov	lr, pc
 589 04ac 010053E3 		bx	r3
 590 04b0 0B00009A 		cmp	r0, #0
 591              		beq	.L77
 592 04b4 00109DE5 	.LVL55:
 593              	.L78:
 594 04b8 2434A0E1 		.loc 1 789 0
 595 04bc 1330CDE5 		mov	r0, r4
 596              		b	.L80
 597 04c0 81008BE0 	.L82:
 598              		.loc 1 768 0
 599 04c4 1240CDE5 		mov	r4, r6
 600              		b	.L76
 601 04c8 12108DE2 	.LVL56:
 602 04cc 0220A0E3 	.L77:
 603 04d0 08309DE5 		.loc 1 797 0
 604 04d4 0FE0A0E1 		mov	r0, r7
 605 04d8 13FF2FE1 		mov	r1, r4
 606 04dc 000050E3 		bl	fat16_free_clusters
 607 04e0 0300000A 	.LVL57:
 608              	.L61:
 609              		.loc 1 799 0
 610              		mov	r0, #0
 611 04e4 0400A0E1 	.L80:
 612 04e8 050000EA 		.loc 1 803 0
 613              		add	sp, sp, #20
 614              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 615 04ec 0640A0E1 		bx	lr
 616 04f0 ECFFFFEA 	.LFE12:
 618              		.global	__umodsi3
 619              		.align	2
 620 04f4 0700A0E1 		.global	fat16_read_file
 622 04fc 71FFFFEB 	fat16_read_file:
 623              	.LFB17:
 624              		.loc 1 962 0
 625              		@ Function supports interworking.
 626 0500 0000A0E3 		@ args = 0, pretend = 0, frame = 0
 627              		@ frame_needed = 0, uses_anonymous_args = 0
 628              	.LVL58:
 629 0504 14D08DE2 		mov	r2, r2, asl #16
 630 0508 F04FBDE8 	.LVL59:
 631 050c 1EFF2FE1 		.loc 1 964 0
 632              		cmp	r1, #0
 633              		cmpne	r0, #0
 634              		.loc 1 962 0
 635              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 636              	.LCFI7:
 637              		.loc 1 964 0
 638              		mov	r6, r0
 639              		mov	fp, r1
 871:../lib/fat16.c **** 16_WRITE_SUPPORT
 872:../lib/fat16.c ****         if(!fs || cluster_num < 2)
 873:../lib/fat16.c ****             return 0;
 874:../lib/fat16.c ****     
 875:../lib/fat16.c ****         /* fetch next cluster before overwriting the cluster entry */
 876:../lib/fat16.c ****         uint16_t cluster_num_next = fat16_get_next_cluster(fs, cluster_num);
 877:../lib/fat16.c ****     
 878:../lib/fat16.c ****         /* mark cluster as the last one */
 879:../lib/fat16.c ****         uint8_t buffer[2];
 880:../lib/fat16.c ****         buffer[0] = FAT16_CLUSTER_LAST_MAX & 0xff;
 881:../lib/fat16.c ****         buffer[1] = (FAT16_CLUSTER_LAST_MAX >> 8) & 0xff;
 882:../lib/fat16.c ****         if(!fs->partition->device_write(fs->header.fat_offset + 2 * cluster_num, buffer, 2))
 883:../lib/fat16.c ****             return 0;
 884:../lib/fat16.c ****     
 885:../lib/fat16.c ****         /* free remaining clusters */
 886:../lib/fat16.c ****         if(cluster_num_next)
 887:../lib/fat16.c ****             return fat16_free_clusters(fs, cluster_num_next);
 888:../lib/fat16.c ****         else
 889:../lib/fat16.c ****             return 1;
 890:../lib/fat16.c ****     #else
 891:../lib/fat16.c ****         return 0;
 892:../lib/fat16.c ****     #endif
 893:../lib/fat16.c **** }
 894:../lib/fat16.c **** 
 895:../lib/fat16.c **** /**
 896:../lib/fat16.c ****  * \ingroup fat16_file
 897:../lib/fat16.c ****  * Opens a file on a FAT16 filesystem.
 898:../lib/fat16.c ****  *
 899:../lib/fat16.c ****  * \param[in] fs The filesystem on which the file to open lies.
 900:../lib/fat16.c ****  * \param[in] dir_entry The directory entry of the file to open.
 901:../lib/fat16.c ****  * \returns The file handle, or 0 on failure.
 902:../lib/fat16.c ****  * \see fat16_close_file
 903:../lib/fat16.c ****  */
 904:../lib/fat16.c **** struct fat16_file_struct* fat16_open_file(struct fat16_fs_struct* fs, const struct fat16_dir_entry_
 905:../lib/fat16.c **** {
 906:../lib/fat16.c ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT16_ATTRIB_DIR))
 907:../lib/fat16.c ****         return 0;
 908:../lib/fat16.c **** 
 909:../lib/fat16.c ****     struct fat16_file_struct* fd = malloc(sizeof(*fd));
 910:../lib/fat16.c ****     if(!fd)
 911:../lib/fat16.c ****         return 0;
 912:../lib/fat16.c **** 
 913:../lib/fat16.c ****     memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
 914:../lib/fat16.c ****     fd->fs = fs;
 915:../lib/fat16.c ****     fd->pos = 0;
 916:../lib/fat16.c ****     fd->pos_cluster = dir_entry->cluster;
 917:../lib/fat16.c **** 
 918:../lib/fat16.c ****     return fd;
 919:../lib/fat16.c **** }
 920:../lib/fat16.c **** 
 921:../lib/fat16.c **** /**
 922:../lib/fat16.c ****  * \ingroup fat16_file
 923:../lib/fat16.c ****  * Closes a file.
 924:../lib/fat16.c ****  *
 925:../lib/fat16.c ****  * \param[in] fd The file handle of the file to close.
 926:../lib/fat16.c ****  * \see fat16_open_file
 927:../lib/fat16.c ****  */
 928:../lib/fat16.c **** void fat16_close_file(struct fat16_file_struct* fd)
 929:../lib/fat16.c **** {
 930:../lib/fat16.c ****     if(fd)
 931:../lib/fat16.c ****         free(fd);
 932:../lib/fat16.c **** }
 933:../lib/fat16.c **** 
 934:../lib/fat16.c **** /**
 935:../lib/fat16.c ****  * \ingroup fat16_file
 936:../lib/fat16.c ****  * Reads data from a file.
 937:../lib/fat16.c ****  *
 938:../lib/fat16.c ****  * The data requested is read from the current file location.
 939:../lib/fat16.c ****  *
 940:../lib/fat16.c ****  * \param[in] fd The file handle of the file from which to read.
 941:../lib/fat16.c ****  * \param[out] buffer The buffer into which to write.
 942:../lib/fat16.c ****  * \param[in] buffer_len The amount of data to read.
 943:../lib/fat16.c ****  * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 944:../lib/fat16.c ****  * \see fat16_write_file
 945:../lib/fat16.c ****  */
 946:../lib/fat16.c **** int16_t fat16_read_file(struct fat16_file_struct* fd, uint8_t* buffer, uint16_t buffer_len)
 947:../lib/fat16.c **** {
 948:../lib/fat16.c ****     /* check arguments */
 949:../lib/fat16.c ****     if(!fd || !buffer || buffer_len < 1)
 950:../lib/fat16.c ****         return -1;
 951:../lib/fat16.c **** 
 952:../lib/fat16.c ****     /* determine number of bytes to read */
 953:../lib/fat16.c ****     if(fd->pos + buffer_len > fd->dir_entry.file_size)
 954:../lib/fat16.c ****         buffer_len = fd->dir_entry.file_size - fd->pos;
 955:../lib/fat16.c ****     if(buffer_len == 0)
 956:../lib/fat16.c ****         return 0;
 957:../lib/fat16.c **** 
 958:../lib/fat16.c ****     uint16_t cluster_size = fd->fs->header.cluster_size;
 959:../lib/fat16.c ****     uint16_t cluster_num = fd->pos_cluster;
 960:../lib/fat16.c ****     uint16_t buffer_left = buffer_len;
 961:../lib/fat16.c ****     uint16_t first_cluster_offset = fd->pos % cluster_size;
 962:../lib/fat16.c **** 
 640              		.L87
 641              	.LVL63:
 642              		.loc 1 969 0
 643              		rsb	r3, r7, r2
 644              		mov	r3, r3, asl #16
 645 0510 0228A0E1 		.loc 1 970 0
 646              		movs	r8, r3, lsr #16
 963:../lib/fat16.c **** num = fd->dir_entry.cluster;
 964:../lib/fat16.c **** 
 647              	89
 648 0514 000051E3 	.L87:
 649 0518 00005013 		.loc 1 974 0
 650              		ldrh	r5, [r6, #52]
 651 051c F04F2DE9 	.LVL64:
 652              		.loc 1 973 0
 653              		ldr	r3, [r6, #0]
 654 0520 0060A0E1 		.loc 1 979 0
 655 0524 01B0A0E1 		cmp	r5, #0
 656              		.loc 1 973 0
 657 0528 2288A0E1 		ldrh	r9, [r3, #18]
 658              	.LVL65:
 659              		.loc 1 979 0
 660 052c 5000000A 		bne	.L90
 661              	.LVL66:
 662 0530 000058E3 		.loc 1 981 0
 663 0534 4E00000A 		ldrh	r5, [r6, #38]
 965:../lib/fat16.c ****       if(!cluster_num)
 966:../lib/fat16.c ****         {
 967:../lib/fat16.c ****             if(!fd->pos)
 968:../lib/fat16.c ****                 return 0;
 664              	p	r5, #0
 665 0538 307090E5 		bne	.L92
 666              		.loc 1 985 0
 667 053c 282090E5 		cmp	r7, #0
 668 0540 083087E0 		beq	.L89
 669 0544 020053E1 		b	.L84
 670 0548 0300009A 	.L92:
 671              		.loc 1 991 0
 969:../lib/fat16.c ****         else
 672              	 #0
 673 054c 023067E0 		movne	r4, r7
 674 0550 0338A0E1 	.LVL67:
 970:../lib/fat16.c ****                return -1;
 675              	e	.L95
 676 0554 2388B0E1 		b	.L90
 677 0558 5000000A 	.LVL68:
 678              	.L96:
 971:../lib/fat16.c ****        }
 972:../lib/fat16.c **** 
 973:../lib/fat16.c ****         if(fd->pos)
 974:../lib/fat16.c ****         {
 679              	16:
 680 055c B453D6E1 		.loc 1 997 0
 681              		ldr	r0, [r6, #0]
 682              		bl	fat16_get_next_cluster
 683 0560 003096E5 	.LVL69:
 975:../lib/fat16.c ****         uint32_t pos = fd->pos;
 976:../lib/fat16.c ****             while(pos >= cluster_size)
 977:../lib/fat16.c ****             {
 978:../lib/fat16.c ****                 pos -= cluster_size;
 979:../lib/fat16.c ****                 cluster_num = fat16_get_next_cluster(fd->fs, cluster_num);
 684              	 1 998 0
 685 0564 000055E3 		subs	r5, r0, #0
 686              		beq	.L84
 687 0568 B291D3E1 	.LVL70:
 688              	.L95:
 689              		.loc 1 994 0
 690 056c 1100001A 		cmp	r4, r9
 691              		.loc 1 997 0
 980:../lib/fat16.c ****            if(!cluster_num)
 981:../lib/fat16.c ****                     return -1;
 692              	 r5
 693 0570 B652D6E1 		.loc 1 998 0
 982:../lib/fat16.c ****           }
 983:../lib/fat16.c ****         }
 694              	sb	r4, r9, r4
 695 0574 000055E3 		.loc 1 994 0
 696 0578 0200001A 		bcs	.L96
 984:../lib/fat16.c ****   }
 985:../lib/fat16.c **** 
 697              	L71:
 698 057c 000057E3 	.L90:
 699 0580 4600000A 	.LBE16:
 700 0584 3A0000EA 		.loc 1 976 0
 701              		mov	r0, r7
 986:../lib/fat16.c ****   /* read data */
 987:../lib/fat16.c ****     do
 988:../lib/fat16.c ****     {
 989:../lib/fat16.c ****         /* calculate data size to copy from cluster */
 990:../lib/fat16.c ****         uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
 991:../lib/fat16.c ****         (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
 702              	r1, r9
 703 0588 000057E3 		bl	__umodsi3
 704 058c 0740A011 		mov	r0, r0, asl #16
 705              		mov	sl, r0, lsr #16
 706 0590 0400001A 	.LVL72:
 707 0594 070000EA 		mov	r7, r8
 708              	.LVL73:
 709              	.LVL74:
 710              	.L98:
 992:../lib/fat16.c ****   uint16_t copy_length = cluster_size - first_cluster_offset;
 993:../lib/fat16.c ****         if(copy_length > buffer_left)
 994:../lib/fat16.c ****             copy_length = buffer_left;
 995:../lib/fat16.c **** 
 996:../lib/fat16.c ****         /* read data */
 997:../lib/fat16.c ****         if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
 711              	.loc 1 1010 0
 712 0598 000096E5 		rsb	r3, sl, r9
 713 059c 1FFFFFEB 		.loc 1 1009 0
 714              		ldr	ip, [r6, #0]
 998:../lib/fat16.c ****       return buffer_len - buffer_left;
 715              	c 1 1010 0
 716 05a0 005050E2 		mov	r3, r3, asl #16
 717 05a4 3200000A 		mov	r3, r3, lsr #16
 718              	.LVL75:
 719              		cmp	r7, r3
 720              		movcc	r3, r7
 721 05a8 090054E1 	.LVL76:
 722              		.loc 1 1015 0
 723 05ac 0510A0E1 		ldr	r2, [ip, #24]
 724              		.loc 1 1010 0
 725 05b0 044069E0 		mov	r3, r3, asl #16
 726              		mov	r4, r3, lsr #16
 727 05b4 F7FFFF2A 	.LVL77:
 728              		.loc 1 1015 0
 729              		add	r2, sl, r2
 730              		sub	r3, r5, #2
 731              		mla	r0, r9, r3, r2
 732 05b8 0700A0E1 		mov	r1, fp
 733 05bc 0910A0E1 		mov	r2, r4
 734 05c0 FEFFFFEB 		ldr	r3, [ip, #0]
 735 05c4 0008A0E1 		ldr	ip, [r3, #0]
 736 05c8 20A8A0E1 		mov	lr, pc
 737              		bx	ip
 738 05cc 0870A0E1 		.loc 1 1020 0
 739              		rsb	r3, r4, r7
 740              		.loc 1 1015 0
 741              		cmp	r0, #0
 742              		.loc 1 1026 0
 999:../lib/fat16.c ****         /* calculate new file position */
1000:../lib/fat16.c ****         buffer += copy_length;
1001:../lib/fat16.c ****         buffer_left -= copy_length;
1002:../lib/fat16.c ****         fd->pos += copy_length;
1003:../lib/fat16.c **** 
1004:../lib/fat16.c ****         if(first_cluster_offset + copy_length >= cluster_size)
1005:../lib/fat16.c ****         {
1006:../lib/fat16.c ****             /* we are on a cluster boundary, so get the next cluster */
1007:../lib/fat16.c ****             if((cluster_num = fat16_get_next_cluster(fd->fs, cluster_num)))
1008:../lib/fat16.c ****             {
1009:../lib/fat16.c ****                 first_cluster_offset = 0;
1010:../lib/fat16.c ****             }
 743              	add	fp, fp, r4
 744 05d0 09306AE0 		.loc 1 1023 0
 745              		add	r2, sl, r4
 746 05d4 00C096E5 		.loc 1 1020 0
 747              		mov	r0, r3, asl #16
 748 05d8 0338A0E1 		.loc 1 1015 0
 749 05dc 2338A0E1 		beq	.L109
 750              		.loc 1 1021 0
 751 05e0 030057E1 		ldr	r3, [r6, #48]
 752 05e4 0730A031 		.loc 1 1023 0
 753              		cmp	r2, r9
1011:../lib/fat16.c **** else
1012:../lib/fat16.c ****             {
1013:../lib/fat16.c ****                 fd->pos_cluster = 0;
1014:../lib/fat16.c ****                 return buffer_len - buffer_left;
1015:../lib/fat16.c ****             }
 754              	1 0
 755 05e8 18209CE5 		add	r3, r3, r4
 756              		str	r3, [r6, #48]
 757 05ec 0338A0E1 		.loc 1 1020 0
 758 05f0 2348A0E1 		mov	r7, r0, lsr #16
 759              		.loc 1 1023 0
 760              		blt	.L102
 761 05f4 02208AE0 		.loc 1 1026 0
 762 05f8 023045E2 		ldr	r0, [r6, #0]
 763 05fc 992320E0 		bl	fat16_get_next_cluster
 764 0600 0B10A0E1 		subs	r5, r0, #0
 765 0604 0420A0E1 		.loc 1 1033 0
 766 0608 00309CE5 		mov	sl, #0
 767 060c 00C093E5 		.loc 1 1026 0
 768 0610 0FE0A0E1 		beq	.L110
 769 0614 1CFF2FE1 	.L102:
1016:../lib/fat16.c ****    }
1017:../lib/fat16.c **** 
1018:../lib/fat16.c ****         fd->pos_cluster = cluster_num;
1019:../lib/fat16.c **** 
1020:../lib/fat16.c ****     }
 770              	1040 0
 771 0618 073064E0 		cmp	r7, #0
 772              	.LBB18:
 773 061c 000050E3 		.loc 1 1037 0
1021:../lib/fat16.c **** hile(buffer_left > 0); /* check if we are done */
1022:../lib/fat16.c **** 
1023:../lib/fat16.c ****     return buffer_len;
1024:../lib/fat16.c **** }
1025:../lib/fat16.c **** 
1026:../lib/fat16.c **** /**
 774              	h	r5, [r6, #52]	@ movhi
 775 0620 0510A0E1 	.LBE18:
 776              		.loc 1 1040 0
 777 0624 04B08BE0 		bne	.L98
 778              		.loc 1 1042 0
 779 0628 04208AE0 		mov	r3, r8, asl #16
 780              		b	.L111
 781 062c 0308A0E1 	.LVL78:
 782              	.L84:
 783 0630 1100000A 		mvn	r0, #0
 784              		b	.L101
 785 0634 303096E5 	.LVL79:
 786              	.L109:
 787 0638 090052E1 	.LBB19:
 788              		.loc 1 1016 0
 789 063c 043083E0 		rsb	r3, r7, r8
 790 0640 303086E5 		mov	r3, r3, asl #16
 791              	.L111:
 792 0644 2078A0E1 		mov	r0, r3, asr #16
 793              		b	.L101
 794 0648 040000BA 	.L110:
 795              		.loc 1 1033 0
 796 064c 000096E5 		rsb	r3, r7, r8
 797 0650 F2FEFFEB 		mov	r3, r3, asl #16
 798 0654 005050E2 		mov	r0, r3, asr #16
1027:../lib/fat16.c **** group fat16_file
1028:../lib/fat16.c ****  * Writes data to a file.
1029:../lib/fat16.c ****  *
1030:../lib/fat16.c ****  * The data is written to the current file location.
1031:../lib/fat16.c ****  *
1032:../lib/fat16.c ****  * \param[in] fd The file handle of the file to which to write.
1033:../lib/fat16.c ****  * \param[in] buffer The buffer from which to read the data to be written.
 799              	[r6, #52]	@ movhi
 800 0658 00A0A0E3 		b	.L101
 801              	.LVL80:
 802 065c 0A00000A 	.L89:
 803              	.LBE19:
 804              		.loc 1 1042 0
1034:../lib/fat16.c **** am[in] buffer_len The amount of data to write.
1035:../lib/fat16.c ****  * \returns The number of bytes written, 0 on disk full, or -1 on failure.
1036:../lib/fat16.c ****  * \see fat16_read_file
1037:../lib/fat16.c ****  */
1038:../lib/fat16.c **** int16_t fat16_write_file(struct fat16_file_struct* fd, const uint8_t* buffer, uint16_t buffer_len)
1039:../lib/fat16.c **** {
1040:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
 805              	0, #0
 806 0660 000057E3 	.LVL81:
 807              	.L101:
 808              		.loc 1 1043 0
 809 0664 B453C6E1 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 810              		bx	lr
 811              	.LFE17:
1041:../lib/fat16.c ****  /* check arguments */
1042:../lib/fat16.c ****         if(!fd || !buffer || buffer_len < 1)
 813              	2
 814 066c 0838A0E1 		.global	fat16_reset_dir
 816              	fat16_reset_dir:
 817              	.LFB24:
 818 0674 0000E0E3 		.loc 1 1431 0
 819 0678 090000EA 		@ Function supports interworking.
 820              		@ args = 0, pretend = 0, frame = 0
 821              		@ frame_needed = 0, uses_anonymous_args = 0
 822              		@ link register save eliminated.
 823              	.LVL82:
 824 067c 083067E0 		.loc 1 1432 0
 825 0680 0338A0E1 		cmp	r0, #0
 826              		mov	r3, r0
 827 0684 4308A0E1 		.loc 1 1435 0
 828 0688 050000EA 		movne	r3, #0	@ movhi
 829              		strneh	r3, [r0, #48]	@ movhi
 830              		movne	r3, #1
 831 068c 083067E0 		.loc 1 1437 0
 832 0690 0338A0E1 		mov	r0, r3
 833 0694 4308A0E1 	.LVL83:
 834              		.loc 1 1431 0
 835 0698 B453C6E1 		@ lr needed for prologue
 836 069c 000000EA 		.loc 1 1437 0
 837              		bx	lr
 838              	.LFE24:
 840              		.align	2
 841 06a0 0000A0E3 		.global	fat16_set_dir
 843              	fat16_set_dir:
1043:../lib/fat16.c ****           return -1;
 844              	ion supports interworking.
 845 06a4 F04FBDE8 		@ args = 0, pretend = 0, frame = 0
 846 06a8 1EFF2FE1 		@ frame_needed = 0, uses_anonymous_args = 0
 847              		@ link register save eliminated.
 848              	.LVL84:
 849              		.loc 1 1441 0
 850              		cmp	r0, #0
 851              		.loc 1 1440 0
 852              		mov	r1, r1, asl #16
 853              	.LVL85:
1044:../lib/fat16.c ****        if(fd->pos > fd->dir_entry.file_size)
1045:../lib/fat16.c ****             return -1;
1046:../lib/fat16.c ****     
1047:../lib/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1048:../lib/fat16.c ****         uint16_t cluster_num = fd->pos_cluster;
1049:../lib/fat16.c ****         uint16_t buffer_left = buffer_len;
1050:../lib/fat16.c ****         uint16_t first_cluster_offset = fd->pos % cluster_size;
1051:../lib/fat16.c ****     
1052:../lib/fat16.c ****         /* find cluster in which to start writing */
1053:../lib/fat16.c ****         if(!cluster_num)
1054:../lib/fat16.c ****         {
1055:../lib/fat16.c ****             cluster_num = fd->dir_entry.cluster;
1056:../lib/fat16.c ****     
1057:../lib/fat16.c ****             if(!cluster_num)
1058:../lib/fat16.c ****             {
1059:../lib/fat16.c ****                 if(!fd->pos)
1060:../lib/fat16.c ****                 {
1061:../lib/fat16.c ****                     /* empty file */
1062:../lib/fat16.c ****                     fd->dir_entry.cluster = cluster_num = fat16_append_clusters(fd->fs, 0, 1);
1063:../lib/fat16.c ****                     if(!cluster_num)
1064:../lib/fat16.c ****                         return -1;
1065:../lib/fat16.c ****                 }
1066:../lib/fat16.c ****                 else
1067:../lib/fat16.c ****                 {
1068:../lib/fat16.c ****                     return -1;
1069:../lib/fat16.c ****                 }
1070:../lib/fat16.c ****             }
1071:../lib/fat16.c ****     
1072:../lib/fat16.c ****             if(fd->pos)
1073:../lib/fat16.c ****             {
1074:../lib/fat16.c ****                 uint32_t pos = fd->pos;
1075:../lib/fat16.c ****                 uint16_t cluster_num_next;
1076:../lib/fat16.c ****                 while(pos >= cluster_size)
1077:../lib/fat16.c ****                 {
1078:../lib/fat16.c ****                     pos -= cluster_size;
1079:../lib/fat16.c ****                     cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1080:../lib/fat16.c ****                     if(!cluster_num_next && pos == 0)
1081:../lib/fat16.c ****         /* the file exactly ends on a cluster boundary, and we append to it */
1082:../lib/fat16.c ****                         cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1083:../lib/fat16.c ****                     if(!cluster_num_next)
1084:../lib/fat16.c ****                         return -1;
1085:../lib/fat16.c ****     
1086:../lib/fat16.c ****                     cluster_num = cluster_num_next;
1087:../lib/fat16.c ****                 }
1088:../lib/fat16.c ****             }
1089:../lib/fat16.c ****         }
1090:../lib/fat16.c ****     
1091:../lib/fat16.c ****         /* write data */
1092:../lib/fat16.c ****         do
1093:../lib/fat16.c ****         {
1094:../lib/fat16.c ****             /* calculate data size to write to cluster */
1095:../lib/fat16.c ****             uint32_t cluster_offset = fd->fs->header.cluster_zero_offset +
1096:../lib/fat16.c ****             (uint32_t) (cluster_num - 2) * cluster_size + first_cluster_offset;
1097:../lib/fat16.c ****             uint16_t write_length = cluster_size - first_cluster_offset;
1098:../lib/fat16.c ****             if(write_length > buffer_left)
1099:../lib/fat16.c ****                 write_length = buffer_left;
1100:../lib/fat16.c ****     
1101:../lib/fat16.c ****             /* write data which fits into the current cluster */
1102:../lib/fat16.c ****             if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
1103:../lib/fat16.c ****                 break;
1104:../lib/fat16.c ****     
1105:../lib/fat16.c ****             /* calculate new file position */
1106:../lib/fat16.c ****             buffer += write_length;
1107:../lib/fat16.c ****             buffer_left -= write_length;
1108:../lib/fat16.c ****             fd->pos += write_length;
1109:../lib/fat16.c ****     
1110:../lib/fat16.c ****             if(first_cluster_offset + write_length >= cluster_size)
1111:../lib/fat16.c ****             {
1112:../lib/fat16.c ****                 /* we are on a cluster boundary, so get the next cluster */
1113:../lib/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1114:../lib/fat16.c ****                 if(!cluster_num_next && buffer_left > 0)
1115:../lib/fat16.c ****         /* we reached the last cluster, append a new one */
1116:../lib/fat16.c ****                     cluster_num_next = fat16_append_clusters(fd->fs, cluster_num, 1);
1117:../lib/fat16.c ****                 if(!cluster_num_next)
1118:../lib/fat16.c ****                 {
1119:../lib/fat16.c ****                     fd->pos_cluster = 0;
1120:../lib/fat16.c ****                     break;
1121:../lib/fat16.c ****                 }
1122:../lib/fat16.c ****     
1123:../lib/fat16.c ****                 cluster_num = cluster_num_next;
1124:../lib/fat16.c ****                 first_cluster_offset = 0;
1125:../lib/fat16.c ****             }
1126:../lib/fat16.c ****     
1127:../lib/fat16.c ****             fd->pos_cluster = cluster_num;
1128:../lib/fat16.c ****     
1129:../lib/fat16.c ****         }
1130:../lib/fat16.c ****         while(buffer_left > 0); /* check if we are done */
1131:../lib/fat16.c ****     
1132:../lib/fat16.c ****         /* update directory entry */
1133:../lib/fat16.c ****         if(fd->pos > fd->dir_entry.file_size)
1134:../lib/fat16.c ****         {
1135:../lib/fat16.c ****             uint32_t size_old = fd->dir_entry.file_size;
1136:../lib/fat16.c ****     
1137:../lib/fat16.c ****             /* update file size */
1138:../lib/fat16.c ****             fd->dir_entry.file_size = fd->pos;
1139:../lib/fat16.c ****             /* write directory entry */
1140:../lib/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1141:../lib/fat16.c ****             {
1142:../lib/fat16.c ****                 /* We do not return an error here since we actually wrote
1143:../lib/fat16.c ****                                                              * some data to disk. So we calculate t
1144:../lib/fat16.c ****                                                              * we wrote to disk and which lies with
1145:../lib/fat16.c ****                                                              */
1146:../lib/fat16.c ****                 buffer_left = fd->pos - size_old;
1147:../lib/fat16.c ****                 fd->pos = size_old;
1148:../lib/fat16.c ****             }
1149:../lib/fat16.c ****         }
1150:../lib/fat16.c ****     
1151:../lib/fat16.c ****         return buffer_len - buffer_left;
1152:../lib/fat16.c ****     
1153:../lib/fat16.c ****     #else
1154:../lib/fat16.c ****         return -1;
1155:../lib/fat16.c ****     #endif
1156:../lib/fat16.c **** }
1157:../lib/fat16.c **** 
1158:../lib/fat16.c **** /**
1159:../lib/fat16.c ****  * \ingroup fat16_file
1160:../lib/fat16.c ****  * Repositions the read/write file offset.
1161:../lib/fat16.c ****  *
1162:../lib/fat16.c ****  * Changes the file offset where the next call to fat16_read_file()
1163:../lib/fat16.c ****  * or fat16_write_file() starts reading/writing.
1164:../lib/fat16.c ****  *
1165:../lib/fat16.c ****  * If the new offset is beyond the end of the file, fat16_resize_file()
1166:../lib/fat16.c ****  * is implicitly called, i.e. the file is expanded.
1167:../lib/fat16.c ****  *
1168:../lib/fat16.c ****  * The new offset can be given in different ways determined by
1169:../lib/fat16.c ****  * the \c whence parameter:
1170:../lib/fat16.c ****  * - \b FAT16_SEEK_SET: \c *offset is relative to the beginning of the file.
1171:../lib/fat16.c ****  * - \b FAT16_SEEK_CUR: \c *offset is relative to the current file position.
1172:../lib/fat16.c ****  * - \b FAT16_SEEK_END: \c *offset is relative to the end of the file.
1173:../lib/fat16.c ****  *
1174:../lib/fat16.c ****  * The resulting absolute offset is written to the location the \c offset
1175:../lib/fat16.c ****  * parameter points to.
1176:../lib/fat16.c ****  *
1177:../lib/fat16.c ****  * \param[in] fd The file decriptor of the file on which to seek.
1178:../lib/fat16.c ****  * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
1179:../lib/fat16.c ****  *                   parameter. The function writes the new absolute offset
1180:../lib/fat16.c ****  *                   to this location before it returns.
1181:../lib/fat16.c ****  * \param[in] whence Affects the way \c offset is interpreted, see above.
1182:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1183:../lib/fat16.c ****  */
1184:../lib/fat16.c **** uint8_t fat16_seek_file(struct fat16_file_struct* fd, int32_t* offset, uint8_t whence)
1185:../lib/fat16.c **** {
1186:../lib/fat16.c ****     if(!fd || !offset)
1187:../lib/fat16.c ****         return 0;
1188:../lib/fat16.c **** 
1189:../lib/fat16.c ****     uint32_t new_pos = fd->pos;
1190:../lib/fat16.c ****     switch(whence)
1191:../lib/fat16.c ****     {
1192:../lib/fat16.c ****         case FAT16_SEEK_SET:
1193:../lib/fat16.c ****             new_pos = *offset;
1194:../lib/fat16.c ****             break;
1195:../lib/fat16.c ****         case FAT16_SEEK_CUR:
1196:../lib/fat16.c ****             new_pos += *offset;
1197:../lib/fat16.c ****             break;
1198:../lib/fat16.c ****         case FAT16_SEEK_END:
1199:../lib/fat16.c ****             new_pos = fd->dir_entry.file_size + *offset;
1200:../lib/fat16.c ****             break;
1201:../lib/fat16.c ****         default:
1202:../lib/fat16.c ****             return 0;
1203:../lib/fat16.c ****     }
1204:../lib/fat16.c **** 
1205:../lib/fat16.c ****     if(new_pos > fd->dir_entry.file_size && !fat16_resize_file(fd, new_pos))
1206:../lib/fat16.c ****         return 0;
1207:../lib/fat16.c **** 
1208:../lib/fat16.c ****     fd->pos = new_pos;
1209:../lib/fat16.c ****     fd->pos_cluster = 0;
1210:../lib/fat16.c **** 
1211:../lib/fat16.c ****     *offset = new_pos;
1212:../lib/fat16.c ****     return 1;
1213:../lib/fat16.c **** }
1214:../lib/fat16.c **** 
1215:../lib/fat16.c **** /**
1216:../lib/fat16.c ****  * \ingroup fat16_file
1217:../lib/fat16.c ****  * Resizes a file to have a specific size.
1218:../lib/fat16.c ****  *
1219:../lib/fat16.c ****  * Enlarges or shrinks the file pointed to by the file descriptor to have
1220:../lib/fat16.c ****  * exactly the specified size.
1221:../lib/fat16.c ****  *
1222:../lib/fat16.c ****  * If the file is truncated, all bytes having an equal or larger offset
1223:../lib/fat16.c ****  * than the given size are lost. If the file is expanded, the additional
1224:../lib/fat16.c ****  * bytes are allocated.
1225:../lib/fat16.c ****  *
1226:../lib/fat16.c ****  * \note Please be aware that this function just allocates or deallocates disk
1227:../lib/fat16.c ****  * space, it does not explicitely clear it. To avoid data leakage, this
1228:../lib/fat16.c ****  * must be done manually.
1229:../lib/fat16.c ****  *
1230:../lib/fat16.c ****  * \param[in] fd The file decriptor of the file which to resize.
1231:../lib/fat16.c ****  * \param[in] size The new size of the file.
1232:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1233:../lib/fat16.c ****  */
1234:../lib/fat16.c **** uint8_t fat16_resize_file(struct fat16_file_struct* fd, uint32_t size)
1235:../lib/fat16.c **** {
1236:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1237:../lib/fat16.c ****         if(!fd)
1238:../lib/fat16.c ****             return 0;
1239:../lib/fat16.c ****     
1240:../lib/fat16.c ****         uint16_t cluster_num = fd->dir_entry.cluster;
1241:../lib/fat16.c ****         uint16_t cluster_size = fd->fs->header.cluster_size;
1242:../lib/fat16.c ****         uint32_t size_new = size;
1243:../lib/fat16.c ****     
1244:../lib/fat16.c ****         do
1245:../lib/fat16.c ****         {
1246:../lib/fat16.c ****             if(cluster_num == 0 && size_new == 0)
1247:../lib/fat16.c ****         /* the file stays empty */
1248:../lib/fat16.c ****                 break;
1249:../lib/fat16.c ****     
1250:../lib/fat16.c ****             /* seek to the next cluster as long as we need the space */
1251:../lib/fat16.c ****             while(size_new > cluster_size)
1252:../lib/fat16.c ****             {
1253:../lib/fat16.c ****                 /* get next cluster of file */
1254:../lib/fat16.c ****                 uint16_t cluster_num_next = fat16_get_next_cluster(fd->fs, cluster_num);
1255:../lib/fat16.c ****                 if(cluster_num_next)
1256:../lib/fat16.c ****                 {
1257:../lib/fat16.c ****                     cluster_num = cluster_num_next;
1258:../lib/fat16.c ****                     size_new -= cluster_size;
1259:../lib/fat16.c ****                 }
1260:../lib/fat16.c ****                 else
1261:../lib/fat16.c ****                 {
1262:../lib/fat16.c ****                     break;
1263:../lib/fat16.c ****                 }
1264:../lib/fat16.c ****             }
1265:../lib/fat16.c ****     
1266:../lib/fat16.c ****             if(size_new > cluster_size || cluster_num == 0)
1267:../lib/fat16.c ****             {
1268:../lib/fat16.c ****                 /* Allocate new cluster chain and append
1269:../lib/fat16.c ****                                                              * it to the existing one, if available
1270:../lib/fat16.c ****                                                              */
1271:../lib/fat16.c ****                 uint16_t cluster_count = size_new / cluster_size;
1272:../lib/fat16.c ****                 if((uint32_t) cluster_count * cluster_size < size_new)
1273:../lib/fat16.c ****                     ++cluster_count;
1274:../lib/fat16.c ****                 uint16_t cluster_new_chain = fat16_append_clusters(fd->fs, cluster_num, cluster_cou
1275:../lib/fat16.c ****                 if(!cluster_new_chain)
1276:../lib/fat16.c ****                     return 0;
1277:../lib/fat16.c ****     
1278:../lib/fat16.c ****                 if(!cluster_num)
1279:../lib/fat16.c ****                 {
1280:../lib/fat16.c ****                     cluster_num = cluster_new_chain;
1281:../lib/fat16.c ****                     fd->dir_entry.cluster = cluster_num;
1282:../lib/fat16.c ****                 }
1283:../lib/fat16.c ****             }
1284:../lib/fat16.c ****     
1285:../lib/fat16.c ****             /* write new directory entry */
1286:../lib/fat16.c ****             fd->dir_entry.file_size = size;
1287:../lib/fat16.c ****             if(size == 0)
1288:../lib/fat16.c ****                 fd->dir_entry.cluster = 0;
1289:../lib/fat16.c ****             if(!fat16_write_dir_entry(fd->fs, &fd->dir_entry))
1290:../lib/fat16.c ****                 return 0;
1291:../lib/fat16.c ****     
1292:../lib/fat16.c ****             if(size == 0)
1293:../lib/fat16.c ****             {
1294:../lib/fat16.c ****                 /* free all clusters of file */
1295:../lib/fat16.c ****                 fat16_free_clusters(fd->fs, cluster_num);
1296:../lib/fat16.c ****             }
1297:../lib/fat16.c ****             else if(size_new <= cluster_size)
1298:../lib/fat16.c ****             {
1299:../lib/fat16.c ****                 /* free all clusters no longer needed */
1300:../lib/fat16.c ****                 fat16_terminate_clusters(fd->fs, cluster_num);
1301:../lib/fat16.c ****             }
1302:../lib/fat16.c ****     
1303:../lib/fat16.c ****         }
1304:../lib/fat16.c ****         while(0);
1305:../lib/fat16.c ****     
1306:../lib/fat16.c ****         /* correct file position */
1307:../lib/fat16.c ****         if(size < fd->pos)
1308:../lib/fat16.c ****         {
1309:../lib/fat16.c ****             fd->pos = size;
1310:../lib/fat16.c ****             fd->pos_cluster = 0;
1311:../lib/fat16.c ****         }
1312:../lib/fat16.c ****     
1313:../lib/fat16.c ****         return 1;
1314:../lib/fat16.c ****     #else
1315:../lib/fat16.c ****         return 0;
1316:../lib/fat16.c ****     #endif
1317:../lib/fat16.c **** }
1318:../lib/fat16.c **** 
1319:../lib/fat16.c **** /**
1320:../lib/fat16.c ****  * \ingroup fat16_dir
1321:../lib/fat16.c ****  * Opens a directory.
1322:../lib/fat16.c ****  *
1323:../lib/fat16.c ****  * \param[in] fs The filesystem on which the directory to open resides.
1324:../lib/fat16.c ****  * \param[in] dir_entry The directory entry which stands for the directory to open.
1325:../lib/fat16.c ****  * \returns An opaque directory descriptor on success, 0 on failure.
1326:../lib/fat16.c ****  * \see fat16_close_dir
1327:../lib/fat16.c ****  */
1328:../lib/fat16.c **** struct fat16_dir_struct* fat16_open_dir(struct fat16_fs_struct* fs, const struct fat16_dir_entry_st
1329:../lib/fat16.c **** {
1330:../lib/fat16.c ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT16_ATTRIB_DIR))
1331:../lib/fat16.c ****         return 0;
1332:../lib/fat16.c **** 
1333:../lib/fat16.c ****     struct fat16_dir_struct* dd = malloc(sizeof(*dd));
1334:../lib/fat16.c ****     if(!dd)
1335:../lib/fat16.c ****         return 0;
1336:../lib/fat16.c **** 
1337:../lib/fat16.c ****     memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
1338:../lib/fat16.c ****     dd->fs = fs;
1339:../lib/fat16.c ****     dd->entry_next = 0;
1340:../lib/fat16.c **** 
1341:../lib/fat16.c ****     return dd;
1342:../lib/fat16.c **** }
1343:../lib/fat16.c **** 
1344:../lib/fat16.c **** /**
1345:../lib/fat16.c ****  * \ingroup fat16_dir
1346:../lib/fat16.c ****  * Closes a directory descriptor.
1347:../lib/fat16.c ****  *
1348:../lib/fat16.c ****  * This function destroys a directory descriptor which was
1349:../lib/fat16.c ****  * previously obtained by calling fat16_open_dir(). When this
1350:../lib/fat16.c ****  * function returns, the given descriptor will be invalid.
1351:../lib/fat16.c ****  *
1352:../lib/fat16.c ****  * \param[in] dd The directory descriptor to close.
1353:../lib/fat16.c ****  * \see fat16_open_dir
1354:../lib/fat16.c ****  */
1355:../lib/fat16.c **** void fat16_close_dir(struct fat16_dir_struct* dd)
1356:../lib/fat16.c **** {
1357:../lib/fat16.c ****     if(dd)
1358:../lib/fat16.c ****         free(dd);
1359:../lib/fat16.c **** }
1360:../lib/fat16.c **** 
1361:../lib/fat16.c **** /**
1362:../lib/fat16.c ****  * \ingroup fat16_dir
1363:../lib/fat16.c ****  * Reads the next directory entry contained within a parent directory.
1364:../lib/fat16.c ****  *
1365:../lib/fat16.c ****  * \param[in] dd The descriptor of the parent directory from which to read the entry.
1366:../lib/fat16.c ****  * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
1367:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1368:../lib/fat16.c ****  * \see fat16_reset_dir
1369:../lib/fat16.c ****  */
1370:../lib/fat16.c **** uint8_t fat16_read_dir(struct fat16_dir_struct* dd, struct fat16_dir_entry_struct* dir_entry)
1371:../lib/fat16.c **** {
1372:../lib/fat16.c ****     if(!dd || !dir_entry)
1373:../lib/fat16.c ****         return 0;
1374:../lib/fat16.c **** 
1375:../lib/fat16.c ****     if(dd->dir_entry.cluster == 0)
1376:../lib/fat16.c ****     {
1377:../lib/fat16.c ****         /* read entry from root directory */
1378:../lib/fat16.c ****         if(fat16_read_root_dir_entry(dd->fs, dd->entry_next, dir_entry))
1379:../lib/fat16.c ****         {
1380:../lib/fat16.c ****             ++dd->entry_next;
1381:../lib/fat16.c ****             return 1;
1382:../lib/fat16.c ****         }
1383:../lib/fat16.c ****     }
1384:../lib/fat16.c ****     else
1385:../lib/fat16.c ****     {
1386:../lib/fat16.c ****         /* read entry from a subdirectory */
1387:../lib/fat16.c ****         if(fat16_read_sub_dir_entry(dd->fs, dd->entry_next, &dd->dir_entry, dir_entry))
1388:../lib/fat16.c ****         {
1389:../lib/fat16.c ****             ++dd->entry_next;
1390:../lib/fat16.c ****             return 1;
1391:../lib/fat16.c ****         }
1392:../lib/fat16.c ****     }
1393:../lib/fat16.c **** 
1394:../lib/fat16.c ****     /* restart reading */
1395:../lib/fat16.c ****     dd->entry_next = 0;
1396:../lib/fat16.c **** 
1397:../lib/fat16.c ****     return 0;
1398:../lib/fat16.c **** }
1399:../lib/fat16.c **** 
1400:../lib/fat16.c **** /**
1401:../lib/fat16.c ****  * \ingroup fat16_dir
1402:../lib/fat16.c ****  * Resets a directory handle.
1403:../lib/fat16.c ****  *
1404:../lib/fat16.c ****  * Resets the directory handle such that reading restarts
1405:../lib/fat16.c ****  * with the first directory entry.
1406:../lib/fat16.c ****  *
1407:../lib/fat16.c ****  * \param[in] dd The directory handle to reset.
1408:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1409:../lib/fat16.c ****  * \see fat16_read_dir
1410:../lib/fat16.c ****  */
1411:../lib/fat16.c **** uint8_t fat16_reset_dir(struct fat16_dir_struct* dd)
1412:../lib/fat16.c **** {
1413:../lib/fat16.c ****     if(!dd)
1414:../lib/fat16.c ****         return 0;
1415:../lib/fat16.c **** 
1416:../lib/fat16.c ****     dd->entry_next = 0;
1417:../lib/fat16.c ****     return 1;
1418:../lib/fat16.c **** }
1419:../lib/fat16.c **** 
1420:../lib/fat16.c **** uint8_t fat16_set_dir(struct fat16_dir_struct* dd, uint16_t offset)
1421:../lib/fat16.c **** {
1422:../lib/fat16.c ****     if(!dd)
1423:../lib/fat16.c ****         return 0;
1424:../lib/fat16.c **** 
1425:../lib/fat16.c ****     dd->entry_next = offset;
1426:../lib/fat16.c ****     return 1;
1427:../lib/fat16.c **** }
1428:../lib/fat16.c **** 
1429:../lib/fat16.c **** /**
1430:../lib/fat16.c ****  * \ingroup fat16_fs
1431:../lib/fat16.c ****  * Writes a directory entry to disk.
 854              	41 0
 855              		mov	r3, r0
 856              		.loc 1 1440 0
 857              		mov	r1, r1, lsr #16
 858              	.LVL86:
 859              		.loc 1 1444 0
1432:../lib/fat16.c **** haracters are used for the filename.
 860              		r3, #1
 861 06ac 000050E3 		strneh	r1, [r0, #48]	@ movhi
 862 06b0 0030A0E1 		.loc 1 1446 0
1433:../lib/fat16.c **** * The extension, if any, is made up of the first three characters
1434:../lib/fat16.c ****  * following the last dot within the long filename. If the
1435:../lib/fat16.c ****  * filename (without the extension) is longer than eight characters,
 863              	v	r0, r3
 864 06b4 0030A013 	.LVL87:
 865 06b8 B033C011 		.loc 1 1440 0
 866 06bc 0130A013 		@ lr needed for prologue
1436:../lib/fat16.c **** the lower byte of the cluster number replaces the last two
1437:../lib/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
 867              	c 1 1446 0
 868 06c0 0300A0E1 		bx	lr
 869              	.LFE25:
 871              		.align	2
 872              		.global	fat16_delete_file
 874              	fat16_delete_file:
 875              	.LFB28:
 876              		.loc 1 1801 0
 877              		@ Function supports interworking.
 878              		@ args = 0, pretend = 0, frame = 12
 879              		@ frame_needed = 0, uses_anonymous_args = 0
 880              	.LVL88:
1438:../lib/fat16.c ****  responsibility to avoid name clashes.
1439:../lib/fat16.c ****  *
1440:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
 881              	4, r5, r6, r7, lr}
 882              	.LCFI8:
 883              		.loc 1 1803 0
 884              		cmp	r1, #0
 885              		cmpne	r0, #0
 886              		.loc 1 1801 0
1441:../lib/fat16.c **** \param[in] dir_entry The directory entry to write.
 887              	p, sp, #12
 888 06c8 000050E3 	.LCFI9:
 889              		.loc 1 1803 0
 890 06cc 0118A0E1 		mov	r6, r0
 891              		mov	r7, r1
 892              		beq	.L123
 893 06d0 0030A0E1 	.LVL89:
 894              		.loc 1 1807 0
 895 06d4 2118A0E1 		ldr	r5, [r1, #40]
 896              	.LVL90:
1442:../lib/fat16.c **** * \returns 0 on failure, 1 on success.
1443:../lib/fat16.c ****  */
1444:../lib/fat16.c **** uint8_t fat16_write_dir_entry(const struct fat16_fs_struct* fs, const struct fat16_dir_entry_struct
 897              	08 0
 898 06d8 0130A013 		cmp	r5, #0
 899 06dc B013C011 		beq	.L123
1445:../lib/fat16.c ****    #if FAT16_WRITE_SUPPORT
1446:../lib/fat16.c ****         if(!fs || !dir_entry)
 900              	32:
 901 06e0 0300A0E1 		.loc 1 1815 0
 902              		mov	r1, sp
 903              		mov	r0, r5
 904              		mov	r2, #12
 905              		ldr	r3, [r6, #0]
 906 06e4 1EFF2FE1 		ldr	ip, [r3, #0]
 907              		mov	lr, pc
 908              		bx	ip
 909              		cmp	r0, #0
 910              		mov	r4, sp
 911              		.loc 1 1822 0
 912              		mov	r0, r5
 913              		mov	r1, sp
1447:../lib/fat16.c ****           return 0;
1448:../lib/fat16.c ****     
1449:../lib/fat16.c ****         device_write_t device_write = fs->partition->device_write;
1450:../lib/fat16.c ****         uint32_t offset = dir_entry->entry_offset;
1451:../lib/fat16.c ****         uint8_t name_len = strlen(dir_entry->long_name);
1452:../lib/fat16.c ****         uint8_t lfn_entry_count = (name_len + 12) / 13;
1453:../lib/fat16.c ****         uint8_t buffer[32];
1454:../lib/fat16.c ****     
1455:../lib/fat16.c ****         /* write 8.3 entry */
1456:../lib/fat16.c ****     
1457:../lib/fat16.c ****         /* generate 8.3 file name */
1458:../lib/fat16.c ****         memset(&buffer[0], ' ', 11);
1459:../lib/fat16.c ****         char* name_ext = strrchr(dir_entry->long_name, '.');
1460:../lib/fat16.c ****         if(name_ext)
1461:../lib/fat16.c ****         {
1462:../lib/fat16.c ****             ++name_ext;
1463:../lib/fat16.c ****     
1464:../lib/fat16.c ****             uint8_t name_ext_len = strlen(name_ext);
1465:../lib/fat16.c ****             name_len -= name_ext_len + 1;
1466:../lib/fat16.c ****     
1467:../lib/fat16.c ****             if(name_ext_len > 3)
1468:../lib/fat16.c ****                 name_ext_len = 3;
1469:../lib/fat16.c ****     
1470:../lib/fat16.c ****             memcpy(&buffer[8], name_ext, name_ext_len);
1471:../lib/fat16.c ****         }
1472:../lib/fat16.c ****     
1473:../lib/fat16.c ****         if(name_len <= 8)
1474:../lib/fat16.c ****         {
1475:../lib/fat16.c ****             memcpy(buffer, dir_entry->long_name, name_len);
1476:../lib/fat16.c ****         }
1477:../lib/fat16.c ****         else
1478:../lib/fat16.c ****         {
1479:../lib/fat16.c ****             memcpy(buffer, dir_entry->long_name, 8);
1480:../lib/fat16.c ****     
1481:../lib/fat16.c ****             /* Minimize 8.3 name clashes by appending
1482:../lib/fat16.c ****                                              * the lower byte of the cluster number.
1483:../lib/fat16.c ****                                              */
1484:../lib/fat16.c ****             uint8_t num = dir_entry->cluster & 0xff;
1485:../lib/fat16.c ****     
1486:../lib/fat16.c ****             buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
1487:../lib/fat16.c ****             num &= 0x0f;
1488:../lib/fat16.c ****             buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
1489:../lib/fat16.c ****         }
1490:../lib/fat16.c ****     
1491:../lib/fat16.c ****         /* fill directory entry buffer */
1492:../lib/fat16.c ****         memset(&buffer[11], 0, sizeof(buffer) - 11);
1493:../lib/fat16.c ****         buffer[0x0b] = dir_entry->attributes;
1494:../lib/fat16.c **** 
1495:../lib/fat16.c ****         //Not used in bootloader
1496:../lib/fat16.c **** 		#ifdef MAIN_FIRMWARE
1497:../lib/fat16.c **** 			//Added modified date/time 12-26-07
1498:../lib/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1499:../lib/fat16.c **** 			char * current_time;
1500:../lib/fat16.c **** /*			current_time = GPS_get_time();
1501:../lib/fat16.c **** 			char * current_date;
1502:../lib/fat16.c **** 			current_date = GPS_get_date();
1503:../lib/fat16.c **** 			
1504:../lib/fat16.c **** 			uint16_t modified_time, modified_date;
1505:../lib/fat16.c **** 			uint8_t c_hour, c_minute, c_second;
1506:../lib/fat16.c **** 			uint8_t c_year, c_month, c_day;
1507:../lib/fat16.c **** 			
1508:../lib/fat16.c **** 			c_hour = (current_time[0] - '0') * 10;
1509:../lib/fat16.c **** 			c_hour += (current_time[1] - '0');
1510:../lib/fat16.c **** 			c_minute = (current_time[3] - '0') * 10;
1511:../lib/fat16.c **** 			c_minute += (current_time[4] - '0');
1512:../lib/fat16.c **** 			c_second = (current_time[6] - '0') * 10;
1513:../lib/fat16.c **** 			c_second += (current_time[7] - '0');
1514:../lib/fat16.c **** 			
1515:../lib/fat16.c **** 			c_day = (current_date[0] - '0') * 10;
1516:../lib/fat16.c **** 			c_day += (current_date[1] - '0');
1517:../lib/fat16.c **** 			c_month = (current_date[3] - '0') * 10;
1518:../lib/fat16.c **** 			c_month += (current_date[4] - '0');
1519:../lib/fat16.c **** 			c_year = (current_date[6] - '0') * 10;
1520:../lib/fat16.c **** 			c_year += (current_date[7] - '0');
1521:../lib/fat16.c **** 			
1522:../lib/fat16.c **** 			//Correct for 1980 = 0, 2000 = 20, year code
1523:../lib/fat16.c **** 			c_year += 20;
1524:../lib/fat16.c **** 			
1525:../lib/fat16.c **** 			modified_time = (c_hour << (16-5)) | (c_minute << (16-11)) | (c_second);
1526:../lib/fat16.c **** 			modified_date = (c_year << (16-7)) | (c_month << (16-11)) | (c_day);
1527:../lib/fat16.c **** 
1528:../lib/fat16.c **** 			//Do a little error correction
1529:../lib/fat16.c **** 			if (c_year < 26) //26 = 2006
1530:../lib/fat16.c **** 			{
1531:../lib/fat16.c **** 				modified_time = 0;
1532:../lib/fat16.c **** 				modified_date = 0;
1533:../lib/fat16.c **** 			}
1534:../lib/fat16.c **** 
1535:../lib/fat16.c **** 			//rprintf("c_time=%d, %d, %d\n", c_hour, c_minute, c_second);
1536:../lib/fat16.c **** 			//rprintf("c_date=%d, %d, %d\n", c_month, c_day, c_year);
1537:../lib/fat16.c **** 			//rprintf("mod_time=%x\n", modified_time);
1538:../lib/fat16.c **** 			//rprintf("mod_date=%x\n", modified_date);
1539:../lib/fat16.c **** 			
1540:../lib/fat16.c **** 			buffer[0x16] = (modified_time >> 0) & 0xFF;
1541:../lib/fat16.c **** 			buffer[0x17] = (modified_time >> 8) & 0xFF;
1542:../lib/fat16.c **** 			buffer[0x18] = (modified_date >> 0) & 0xFF;
1543:../lib/fat16.c **** 			buffer[0x19] = (modified_date >> 8) & 0xFF;
1544:../lib/fat16.c **** 			*/
1545:../lib/fat16.c **** 			//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1546:../lib/fat16.c **** 		#endif
1547:../lib/fat16.c **** 
1548:../lib/fat16.c ****         buffer[0x1a] = (dir_entry->cluster >> 0) & 0xff;
1549:../lib/fat16.c ****         buffer[0x1b] = (dir_entry->cluster >> 8) & 0xff;
1550:../lib/fat16.c ****         buffer[0x1c] = (dir_entry->file_size >> 0) & 0xff;
1551:../lib/fat16.c ****         buffer[0x1d] = (dir_entry->file_size >> 8) & 0xff;
1552:../lib/fat16.c ****         buffer[0x1e] = (dir_entry->file_size >> 16) & 0xff;
1553:../lib/fat16.c ****         buffer[0x1f] = (dir_entry->file_size >> 24) & 0xff;
1554:../lib/fat16.c ****     
1555:../lib/fat16.c ****         /* write to disk */
1556:../lib/fat16.c ****         if(!device_write(offset + (uint32_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
1557:../lib/fat16.c ****             return 0;
1558:../lib/fat16.c ****     
1559:../lib/fat16.c ****         /* calculate checksum of 8.3 name */
1560:../lib/fat16.c ****         uint8_t checksum = buffer[0];
1561:../lib/fat16.c ****         uint8_t i;
1562:../lib/fat16.c ****         for(i = 1; i < 11; ++i)
1563:../lib/fat16.c ****             checksum = ((checksum >> 1) | (checksum << 7)) + buffer[i];
1564:../lib/fat16.c ****     
1565:../lib/fat16.c ****         /* write lfn entries */
1566:../lib/fat16.c ****         uint8_t lfn_entry;
1567:../lib/fat16.c ****         for(lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
1568:../lib/fat16.c ****         {
1569:../lib/fat16.c ****             memset(buffer, 0, sizeof(buffer));
1570:../lib/fat16.c ****             memset(&buffer[0x01], 0xff, 10);
1571:../lib/fat16.c ****             memset(&buffer[0x0e], 0xff, 12);
1572:../lib/fat16.c ****             memset(&buffer[0x1c], 0xff, 4);
1573:../lib/fat16.c ****     
1574:../lib/fat16.c ****             buffer[0x00] = lfn_entry;
1575:../lib/fat16.c ****             if(lfn_entry == lfn_entry_count)
1576:../lib/fat16.c ****                 buffer[0x00] |= FAT16_DIRENTRY_LFNLAST;
1577:../lib/fat16.c ****     
1578:../lib/fat16.c ****             /* set file name */
1579:../lib/fat16.c ****             const char* long_name_curr = dir_entry->long_name + (lfn_entry - 1) * 13;
1580:../lib/fat16.c ****             i = 1;
1581:../lib/fat16.c ****             while(i < 0x1f)
1582:../lib/fat16.c ****             {
1583:../lib/fat16.c ****                 buffer[i++] = *long_name_curr;
1584:../lib/fat16.c ****                 buffer[i++] = 0;
1585:../lib/fat16.c ****     
1586:../lib/fat16.c ****                 switch(i)
1587:../lib/fat16.c ****                 {
1588:../lib/fat16.c ****                     case 0x0b:
1589:../lib/fat16.c ****                         i = 0x0e;
1590:../lib/fat16.c ****                         break;
1591:../lib/fat16.c ****                     case 0x1a:
1592:../lib/fat16.c ****                         i = 0x1c;
1593:../lib/fat16.c ****                         break;
1594:../lib/fat16.c ****                 }
1595:../lib/fat16.c ****     
1596:../lib/fat16.c ****                 if(!*long_name_curr++)
1597:../lib/fat16.c ****                     break;
1598:../lib/fat16.c ****             }
1599:../lib/fat16.c ****     
1600:../lib/fat16.c ****             /* mark as lfn entry */
1601:../lib/fat16.c ****             buffer[0x0b] = 0x0f;
1602:../lib/fat16.c ****     
1603:../lib/fat16.c ****             /* set checksum */
1604:../lib/fat16.c ****             buffer[0x0d] = checksum;
1605:../lib/fat16.c ****     
1606:../lib/fat16.c ****             /* write entry */
1607:../lib/fat16.c ****             device_write(offset, buffer, sizeof(buffer));
1608:../lib/fat16.c ****     
1609:../lib/fat16.c ****             offset += sizeof(buffer);
1610:../lib/fat16.c ****         }
1611:../lib/fat16.c ****     
1612:../lib/fat16.c ****         return 1;
1613:../lib/fat16.c ****     
1614:../lib/fat16.c ****     #else
1615:../lib/fat16.c ****         return 0;
1616:../lib/fat16.c ****     #endif
1617:../lib/fat16.c **** }
1618:../lib/fat16.c **** 
1619:../lib/fat16.c **** /**
1620:../lib/fat16.c ****  * \ingroup fat16_file
1621:../lib/fat16.c ****  * Creates a file.
1622:../lib/fat16.c ****  *
1623:../lib/fat16.c ****  * Creates a file and obtains the directory entry of the
1624:../lib/fat16.c ****  * new file. If the file to create already exists, the
1625:../lib/fat16.c ****  * directory entry of the existing file will be returned
1626:../lib/fat16.c ****  * within the dir_entry parameter.
1627:../lib/fat16.c ****  *
1628:../lib/fat16.c ****  * \note The file name is not checked for invalid characters.
1629:../lib/fat16.c ****  *
1630:../lib/fat16.c ****  * \note The generation of the short 8.3 file name is quite
1631:../lib/fat16.c ****  * simple. The first eight characters are used for the filename.
1632:../lib/fat16.c ****  * The extension, if any, is made up of the first three characters
1633:../lib/fat16.c ****  * following the last dot within the long filename. If the
1634:../lib/fat16.c ****  * filename (without the extension) is longer than eight characters,
1635:../lib/fat16.c ****  * the lower byte of the cluster number replaces the last two
1636:../lib/fat16.c ****  * characters to avoid name clashes. In any other case, it is your
1637:../lib/fat16.c ****  * responsibility to avoid name clashes.
1638:../lib/fat16.c ****  *
1639:../lib/fat16.c ****  * \param[in] parent The handle of the directory in which to create the file.
1640:../lib/fat16.c ****  * \param[in] file The name of the file to create.
1641:../lib/fat16.c ****  * \param[out] dir_entry The directory entry to fill for the new file.
1642:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1643:../lib/fat16.c ****  * \see fat16_delete_file
1644:../lib/fat16.c ****  */
1645:../lib/fat16.c **** uint8_t fat16_create_file(struct fat16_dir_struct* parent, const char* file, struct fat16_dir_entry
1646:../lib/fat16.c **** {
1647:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1648:../lib/fat16.c ****         if(!parent || !file || !file[0])
1649:../lib/fat16.c ****             return 0;
1650:../lib/fat16.c ****     
1651:../lib/fat16.c ****         /* check if the file already exists */
1652:../lib/fat16.c ****         while(1)
1653:../lib/fat16.c ****         {
1654:../lib/fat16.c ****             if(!fat16_read_dir(parent, dir_entry))
1655:../lib/fat16.c ****                 break;
1656:../lib/fat16.c ****     
1657:../lib/fat16.c ****             if(strcmp(file, dir_entry->long_name) == 0)
1658:../lib/fat16.c ****             {
1659:../lib/fat16.c ****                 fat16_reset_dir(parent);
1660:../lib/fat16.c ****                 return 1;
1661:../lib/fat16.c ****             }
1662:../lib/fat16.c ****         }
1663:../lib/fat16.c ****     
1664:../lib/fat16.c ****         memset(dir_entry, 0, sizeof(*dir_entry));
1665:../lib/fat16.c ****         strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
1666:../lib/fat16.c ****     
1667:../lib/fat16.c ****         /* search for a place where to write the directory entry to disk */
1668:../lib/fat16.c ****         uint8_t free_dir_entries_needed = strlen(file) / 13 + 1 + 1;
1669:../lib/fat16.c ****         uint8_t free_dir_entries_found = 0;
1670:../lib/fat16.c ****         struct fat16_fs_struct* fs = parent->fs;
1671:../lib/fat16.c ****         uint16_t cluster_num = parent->dir_entry.cluster;
1672:../lib/fat16.c ****         uint32_t dir_entry_offset = 0;
1673:../lib/fat16.c ****         uint32_t offset = 0;
1674:../lib/fat16.c ****         uint32_t offset_to = 0;
1675:../lib/fat16.c ****     
1676:../lib/fat16.c ****         if(cluster_num == 0)
1677:../lib/fat16.c ****         {
1678:../lib/fat16.c ****             /* we read/write from the root directory entry */
1679:../lib/fat16.c ****             offset = fs->header.root_dir_offset;
1680:../lib/fat16.c ****             offset_to = fs->header.cluster_zero_offset;
1681:../lib/fat16.c ****             dir_entry_offset = offset;
1682:../lib/fat16.c ****         }
1683:../lib/fat16.c ****     
1684:../lib/fat16.c ****         while(1)
1685:../lib/fat16.c ****         {
1686:../lib/fat16.c ****             if(offset == offset_to)
1687:../lib/fat16.c ****             {
1688:../lib/fat16.c ****                 if(cluster_num == 0)
1689:../lib/fat16.c **** 				/* We iterated through the whole root directory entry
1690:../lib/fat16.c ****                 * and could not find enough space for the directory entry.
1691:../lib/fat16.c ****                 */
1692:../lib/fat16.c ****                 return 0;
1693:../lib/fat16.c ****     
1694:../lib/fat16.c ****                 if(offset)
1695:../lib/fat16.c ****                 {
1696:../lib/fat16.c ****                     /* We reached a cluster boundary and have to
1697:../lib/fat16.c ****                     * switch to the next cluster.
1698:../lib/fat16.c ****                     */
1699:../lib/fat16.c ****     
1700:../lib/fat16.c ****                     uint16_t cluster_next = fat16_get_next_cluster(fs, cluster_num);
1701:../lib/fat16.c ****                     if(!cluster_next)
1702:../lib/fat16.c ****                     {
1703:../lib/fat16.c ****                         cluster_next = fat16_append_clusters(fs, cluster_num, 1);
1704:../lib/fat16.c ****                         if(!cluster_next)
1705:../lib/fat16.c ****                             return 0;
1706:../lib/fat16.c ****     
1707:../lib/fat16.c ****                         /* we appended a new cluster and know it is free */
1708:../lib/fat16.c ****                         dir_entry_offset = fs->header.cluster_zero_offset +
1709:../lib/fat16.c ****                         (uint32_t) (cluster_next - 2) * fs->header.cluster_size;
1710:../lib/fat16.c ****     
1711:../lib/fat16.c ****                         /* TODO: This cluster has to be zeroed in an efficient way, or at least
1712:../lib/fat16.c ****                         *       every 32th byte should be set to FAT16_DIRENTRY_DELETED.
1713:../lib/fat16.c ****                         */
1714:../lib/fat16.c ****                         break;
1715:../lib/fat16.c ****                     }
1716:../lib/fat16.c ****                     cluster_num = cluster_next;
1717:../lib/fat16.c ****                 }
1718:../lib/fat16.c ****     
1719:../lib/fat16.c ****                 offset = fs->header.cluster_zero_offset +
1720:../lib/fat16.c ****                 (uint32_t) (cluster_num - 2) * fs->header.cluster_size;
1721:../lib/fat16.c ****                 offset_to = offset + fs->header.cluster_size;
1722:../lib/fat16.c ****                 dir_entry_offset = offset;
1723:../lib/fat16.c ****                 free_dir_entries_found = 0;
1724:../lib/fat16.c ****             }
1725:../lib/fat16.c ****     
1726:../lib/fat16.c ****             /* read next lfn or 8.3 entry */
1727:../lib/fat16.c ****             uint8_t first_char;
1728:../lib/fat16.c ****             if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
1729:../lib/fat16.c ****                 return 0;
1730:../lib/fat16.c ****     
1731:../lib/fat16.c ****             /* check if we found a free directory entry */
1732:../lib/fat16.c ****             if(first_char == FAT16_DIRENTRY_DELETED || !first_char)
1733:../lib/fat16.c ****             {
1734:../lib/fat16.c ****                 /* check if we have the needed number of available entries */
1735:../lib/fat16.c ****                 ++free_dir_entries_found;
1736:../lib/fat16.c ****                 if(free_dir_entries_found >= free_dir_entries_needed)
1737:../lib/fat16.c ****                     break;
1738:../lib/fat16.c ****     
1739:../lib/fat16.c ****                 offset += 32;
1740:../lib/fat16.c ****             }
1741:../lib/fat16.c ****             else
1742:../lib/fat16.c ****             {
1743:../lib/fat16.c ****                 offset += 32;
1744:../lib/fat16.c ****                 dir_entry_offset = offset;
1745:../lib/fat16.c ****                 free_dir_entries_found = 0;
1746:../lib/fat16.c ****             }
1747:../lib/fat16.c ****         }
1748:../lib/fat16.c **** 
1749:../lib/fat16.c ****         /* write directory entry to disk */
1750:../lib/fat16.c ****         dir_entry->entry_offset = dir_entry_offset;
1751:../lib/fat16.c ****         if(!fat16_write_dir_entry(fs, dir_entry))
1752:../lib/fat16.c ****             return 0;
1753:../lib/fat16.c ****     
1754:../lib/fat16.c ****         return 1;
1755:../lib/fat16.c ****     
1756:../lib/fat16.c ****     #else
1757:../lib/fat16.c ****         return 0;
1758:../lib/fat16.c ****     #endif
1759:../lib/fat16.c **** }
1760:../lib/fat16.c **** 
1761:../lib/fat16.c **** /**
1762:../lib/fat16.c ****  * \ingroup fat16_file
1763:../lib/fat16.c ****  * Deletes a file or directory.
1764:../lib/fat16.c ****  *
1765:../lib/fat16.c ****  * It is not checked if the file to delete is a directory.
1766:../lib/fat16.c ****  * If a directory is deleted without first deleting its
1767:../lib/fat16.c ****  * subdirectories and files, disk space occupied by these
1768:../lib/fat16.c ****  * files will get wasted as there is no chance to release
1769:../lib/fat16.c ****  * it and mark it as free.
1770:../lib/fat16.c ****  *
1771:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1772:../lib/fat16.c ****  * \param[in] dir_entry The directory entry of the file to delete.
1773:../lib/fat16.c ****  * \returns 0 on failure, 1 on success.
1774:../lib/fat16.c ****  * \see fat16_create_file
1775:../lib/fat16.c ****  */
1776:../lib/fat16.c **** uint8_t fat16_delete_file(struct fat16_fs_struct* fs, struct fat16_dir_entry_struct* dir_entry)
1777:../lib/fat16.c **** {
1778:../lib/fat16.c ****     #if FAT16_WRITE_SUPPORT
1779:../lib/fat16.c ****         if(!fs || !dir_entry)
1780:../lib/fat16.c ****             return 0;
1781:../lib/fat16.c ****     
1782:../lib/fat16.c ****         /* get offset of the file's directory entry */
1783:../lib/fat16.c ****         uint32_t dir_entry_offset = dir_entry->entry_offset;
1784:../lib/fat16.c ****         if(!dir_entry_offset)
1785:../lib/fat16.c ****             return 0;
1786:../lib/fat16.c ****     
1787:../lib/fat16.c ****         uint8_t buffer[12];
1788:../lib/fat16.c ****         while(1)
1789:../lib/fat16.c ****         {
1790:../lib/fat16.c ****             /* read directory entry */
1791:../lib/fat16.c ****             if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
1792:../lib/fat16.c ****                 return 0;
1793:../lib/fat16.c ****     
1794:../lib/fat16.c ****             /* mark the directory entry as deleted */
1795:../lib/fat16.c ****             buffer[0] = FAT16_DIRENTRY_DELETED;
1796:../lib/fat16.c ****     
1797:../lib/fat16.c ****             /* write back entry */
1798:../lib/fat16.c ****             if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
1799:../lib/fat16.c ****                 return 0;
1800:../lib/fat16.c ****     
1801:../lib/fat16.c ****             /* check if we deleted the whole entry */
 914              	.loc 1 1829 0
 915              		add	r5, r5, #32
 916              		.loc 1 1815 0
 917              		beq	.L123
 918              		.loc 1 1819 0
 919 06e8 F0402DE9 		mvn	r3, #26
 920              		strb	r3, [sp, #0]
1802:../lib/fat16.c ****  }
1803:../lib/fat16.c ****     
 921              	 1822 0
 922 06ec 000051E3 		ldr	r3, [r6, #0]
 923 06f0 00005013 		ldr	ip, [r3, #8]
 924              		mov	lr, pc
 925 06f4 0CD04DE2 		bx	ip
 926              		cmp	r0, #0
 927              		beq	.L123
 928 06f8 0060A0E1 		.loc 1 1826 0
 929 06fc 0170A0E1 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 930 0700 1F00000A 		cmp	r3, #15
 931              		beq	.L132
1804:../lib/fat16.c **** /
1805:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1806:../lib/fat16.c ****                 break;
1807:../lib/fat16.c ****     
 932              	5 0
 933 0704 285091E5 		mov	r0, r6
 934              		ldrh	r1, [r7, #34]
1808:../lib/fat16.c ****  
 935              		fat16_free_clusters
 936 0708 000055E3 		b	.L130
 937 070c 1C00000A 	.LVL91:
 938              	.L123:
1809:../lib/fat16.c **** y */
1810:../lib/fat16.c ****             if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
1811:../lib/fat16.c ****                 return 0;
1812:../lib/fat16.c ****     
1813:../lib/fat16.c ****             /* check if we deleted the whole entry */
1814:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1815:../lib/fat16.c ****                 break;
 939              		r0, #0
 940 0710 0D10A0E1 	.L130:
 941 0714 0500A0E1 		.loc 1 1839 0
 942 0718 0C20A0E3 		add	sp, sp, #12
 943 071c 003096E5 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 944 0720 00C093E5 		bx	lr
 945 0724 0FE0A0E1 	.LFE28:
 947 072c 000050E3 		.align	2
 948 0730 0D40A0E1 		.global	fat16_get_fs_size
1816:../lib/fat16.c **** 0;
1817:../lib/fat16.c ****     
1818:../lib/fat16.c ****             /* check if we deleted the whole entry */
1819:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1820:../lib/fat16.c ****                 break;
1821:../lib/fat16.c ****     
1822:../lib/fat16.c ****             dir_entry_offset += 32;
 949              	16_get_fs_size, %function
 950 0734 0500A0E1 	fat16_get_fs_size:
 951 0738 0D10A0E1 	.LFB29:
 952 073c 0C20A0E3 		.loc 1 1849 0
1823:../lib/fat16.c **** the whole entry */
1824:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1825:../lib/fat16.c ****                 break;
1826:../lib/fat16.c ****     
1827:../lib/fat16.c ****             dir_entry_offset += 32;
1828:../lib/fat16.c ****         }
1829:../lib/fat16.c ****     
 953              	unction supports interworking.
 954 0740 205085E2 		@ args = 0, pretend = 0, frame = 0
 955              		@ frame_needed = 0, uses_anonymous_args = 0
 956 0744 0E00000A 		@ link register save eliminated.
 957              	.LVL92:
 958 0748 1A30E0E3 		.loc 1 1850 0
 959 074c 0030CDE5 		cmp	r0, #0
 960              		.loc 1 1853 0
 961 0750 003096E5 		ldrne	r3, [r0, #12]
 962 0754 08C093E5 		.loc 1 1850 0
 963 0758 0FE0A0E1 		mov	r2, r0
 964 075c 1CFF2FE1 		.loc 1 1853 0
 965 0760 000050E3 		movne	r3, r3, lsr #1
 966 0764 0600000A 		ldrneh	r2, [r0, #18]
 967              		subne	r3, r3, #2
 968 0768 0B30DDE5 		mulne	r2, r3, r2
 969 076c 0F0053E3 		.loc 1 1854 0
 970 0770 E6FFFF0A 		mov	r0, r2
1830:../lib/fat16.c **** /
1831:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1832:../lib/fat16.c ****                 break;
1833:../lib/fat16.c ****     
1834:../lib/fat16.c ****             dir_entry_offset += 32;
1835:../lib/fat16.c ****         }
 971              	49 0
 972 0774 0600A0E1 		@ lr needed for prologue
 973 0778 B212D7E1 		.loc 1 1854 0
 974 077c D1FEFFEB 		bx	lr
 975 0780 000000EA 	.LFE29:
 977              		.align	2
 978 0784 0000A0E3 		.global	fat16_get_fs_free
1836:../lib/fat16.c **** ntry */
1837:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1838:../lib/fat16.c ****                 break;
1839:../lib/fat16.c ****     
 980              	_fs_free:
 981 0788 0CD08DE2 	.LFB30:
 982 078c F040BDE8 		.loc 1 1867 0
 983 0790 1EFF2FE1 		@ Function supports interworking.
 984              		@ args = 0, pretend = 0, frame = 36
 985              		@ frame_needed = 0, uses_anonymous_args = 0
 986              	.LVL94:
 987              		stmfd	sp!, {r4, r5, r6, r7, lr}
 988              	.LCFI10:
 989              		.loc 1 1868 0
 990              		subs	r6, r0, #0
1840:../lib/fat16.c ****  
1841:../lib/fat16.c ****             /* check if we deleted the whole entry */
1842:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1843:../lib/fat16.c ****                 break;
1844:../lib/fat16.c ****     
1845:../lib/fat16.c ****             dir_entry_offset += 32;
1846:../lib/fat16.c ****         }
1847:../lib/fat16.c ****     
1848:../lib/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1849:../lib/fat16.c ****                              * marking all occupied clusters as free.
 991              	7 0
 992              		sub	sp, sp, #44
 993              	.LCFI11:
 994              		.loc 1 1868 0
 995              		beq	.L139
 996              	.LVL95:
1850:../lib/fat16.c **** he directory entry. The next thing to do is
 997              	1 1874 0
 998 0794 000050E3 		mov	r3, #32
1851:../lib/fat16.c ****          dir_entry_offset += 32;
1852:../lib/fat16.c ****         }
1853:../lib/fat16.c ****     
 999              	trb	r3, [sp, #42]
 1000 0798 0C309015 		.loc 1 1876 0
 1001              		ldr	r7, [r6, #8]
 1002 079c 0020A0E1 	.LVL96:
 1003              		.loc 1 1877 0
 1004 07a0 A330A011 		ldr	r5, [r6, #12]
 1005 07a4 B221D011 	.LVL97:
 1006 07a8 02304312 		.loc 1 1873 0
 1007 07ac 93020210 		mov	r3, #0	@ movhi
1854:../lib/fat16.c **** /
 1008              	 [sp, #40]	@ movhi
 1009 07b0 0200A0E1 		b	.L141
 1010              	.LVL98:
 1011              	.L142:
 1012              	.LBB20:
 1013              		.loc 1 1881 0
 1014 07b4 1EFF2FE1 		ldr	r3, .L150
 1015              		cmp	r5, r3
 1016              		.loc 1 1884 0
 1017              		ldr	r3, .L150+4
 1018              		.loc 1 1882 0
 1019              		movls	r4, r2, lsr #16
 1020              		.loc 1 1884 0
 1021              		ldr	ip, [r6, #0]
1855:../lib/fat16.c **** try_offset, buffer, sizeof(buffer)))
1856:../lib/fat16.c ****                 return 0;
1857:../lib/fat16.c ****     
1858:../lib/fat16.c ****             /* check if we deleted the whole entry */
1859:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1860:../lib/fat16.c ****                 break;
1861:../lib/fat16.c ****     
1862:../lib/fat16.c ****             dir_entry_offset += 32;
1863:../lib/fat16.c ****         }
1864:../lib/fat16.c ****     
1865:../lib/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1866:../lib/fat16.c ****                              * marking all occupied clusters as free.
1867:../lib/fat16.c ****                              */
 1022              	#0]
 1023              		add	r3, sp, #40
 1024              		str	r3, [sp, #4]
 1025              		mov	r0, r7
 1026              		add	r1, sp, #8
 1027 07b8 F0402DE9 		mov	r2, #32
 1028              		mov	r3, r4
1868:../lib/fat16.c **** g to do is
 1029              	, [ip, #4]
 1030 07bc 006050E2 		mov	lr, pc
 1031              		bx	ip
 1032 07c0 2CD04DE2 		cmp	r0, #0
 1033              		beq	.L139
 1034              		.loc 1 1895 0
 1035 07c4 2100000A 		rsb	r5, r4, r5
 1036              		.loc 1 1894 0
1869:../lib/fat16.c ****          dir_entry_offset += 32;
1870:../lib/fat16.c ****         }
1871:../lib/fat16.c ****     
1872:../lib/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1873:../lib/fat16.c ****                              * marking all occupied clusters as free.
1874:../lib/fat16.c ****                              */
 1037              	 r7, r4
 1038 07c8 2030A0E3 	.LVL99:
 1039 07cc 2A30CDE5 	.L141:
1875:../lib/fat16.c **** g to do is
1876:../lib/fat16.c ****                              * marking all occupied clusters as free.
 1040              	E20:
 1041 07d0 087096E5 		.loc 1 1878 0
 1042              		cmp	r5, #0
1877:../lib/fat16.c **** he directory entry. The next thing to do is
 1043              	B21:
 1044 07d4 0C5096E5 		.loc 1 1881 0
 1045              		ldr	r4, .L150+8
 1046              		.loc 1 1882 0
 1047 07d8 0030A0E3 		mov	r2, r5, asl #16
 1048 07dc B832CDE1 	.LBE21:
 1049 07e0 120000EA 		.loc 1 1878 0
 1050              		bne	.L142
 1051              		.loc 1 1898 0
 1052              		ldrh	r2, [r6, #18]
1878:../lib/fat16.c ****          dir_entry_offset += 32;
1879:../lib/fat16.c ****         }
1880:../lib/fat16.c ****     
1881:../lib/fat16.c ****         /* We deleted the directory entry. The next thing to do is
 1053              	[sp, #40]
 1054 07e4 74309FE5 		mul	r0, r2, r3
 1055 07e8 030055E1 		b	.L148
1882:../lib/fat16.c ****          dir_entry_offset += 32;
1883:../lib/fat16.c ****         }
1884:../lib/fat16.c ****     
 1056              	L100:
 1057 07ec 70309FE5 	.L139:
 1058              		mov	r0, #0
 1059 07f0 2248A091 	.L148:
 1060              		.loc 1 1899 0
 1061 07f4 00C096E5 		add	sp, sp, #44
 1062 07f8 00308DE5 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 1063 07fc 28308DE2 		bx	lr
 1064 0800 04308DE5 	.L151:
 1065 0804 0700A0E1 		.align	2
 1066 0808 08108DE2 	.L150:
 1067 080c 2020A0E3 		.word	65533
 1068 0810 0430A0E1 		.word	fat16_get_fs_free_callback
 1069 0814 04C09CE5 		.word	65534
 1070 0818 0FE0A0E1 	.LFE30:
 1072 0820 000050E3 		.align	2
1885:../lib/fat16.c **** /
1886:../lib/fat16.c ****             if(buffer[11] != 0x0f)
1887:../lib/fat16.c ****                 break;
1888:../lib/fat16.c ****     
1889:../lib/fat16.c ****             dir_entry_offset += 32;
1890:../lib/fat16.c ****         }
1891:../lib/fat16.c ****     
1892:../lib/fat16.c ****         /* We deleted the directory entry. The next thing to do is
1893:../lib/fat16.c ****                              * marking all occupied clusters as free.
1894:../lib/fat16.c ****                              */
1895:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1074              	callback:
 1075 0828 055064E0 	.LFB31:
 1076              		.loc 1 1906 0
 1077 082c 047087E0 		@ Function supports interworking.
 1078              		@ args = 0, pretend = 0, frame = 0
 1079              		@ frame_needed = 0, uses_anonymous_args = 0
 1080              	.LVL101:
 1081              		stmfd	sp!, {r4, lr}
 1082 0830 000055E3 	.LCFI12:
 1083              	.LVL102:
 1084              		.loc 1 1908 0
 1085 0834 2C409FE5 		ldrb	r4, [r2, #2]	@ zero_extendqisi2
 1086              	.LVL103:
 1087 0838 0528A0E1 	.LVL104:
 1088              		.loc 1 1906 0
 1089              		mov	ip, r2
 1090 083c E8FFFF1A 	.LVL105:
1896:../lib/fat16.c **** d clusters as free.
1897:../lib/fat16.c ****                              */
1898:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1091              	ov	r1, r0
 1092 0840 B221D6E1 	.LVL106:
 1093 0844 B832DDE1 		mov	lr, #0
 1094 0848 920300E0 		b	.L159
 1095 084c 000000EA 	.L154:
 1096              		.loc 1 1912 0
 1097              		ldrb	r3, [lr, r0]	@ zero_extendqisi2
 1098 0850 0000A0E3 		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 1099              	.LVL107:
1899:../lib/fat16.c **** d clusters as free.
 1100              	 r3, r2, asl #8
 1101 0854 2CD08DE2 		.loc 1 1913 0
 1102 0858 F040BDE8 		ldreqh	r3, [ip, #0]
 1103 085c 1EFF2FE1 		addeq	r3, r3, #1
 1104              		streqh	r3, [ip, #0]	@ movhi
 1105              		.loc 1 1915 0
 1106              		add	r1, r1, #2
 1107 0860 FDFF0000 		add	lr, lr, #2
 1108 0864 00000000 	.LVL108:
 1109 0868 FEFF0000 	.L159:
 1110              		.loc 1 1910 0
 1111              		and	r3, lr, #255
 1112              		cmp	r3, r4
 1113              		bcc	.L154
 1114              		.loc 1 1919 0
 1115              		mov	r0, #1
1900:../lib/fat16.c **** he directory entry. The next thing to do is
1901:../lib/fat16.c ****                              * marking all occupied clusters as free.
1902:../lib/fat16.c ****                              */
1903:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1904:../lib/fat16.c ****     #else
1905:../lib/fat16.c ****         return 0;
1906:../lib/fat16.c ****     #endif
 1116              	sp!, {r4, lr}
 1117              		bx	lr
 1118              	.LFE31:
 1120              		.align	2
 1121 086c 10402DE9 		.global	fat16_file_size
 1123              	fat16_file_size:
1907:../lib/fat16.c ****        */
1908:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1124              		.loc 1 1945 0
 1125 0870 0240D2E5 		@ Function supports interworking.
 1126              		@ args = 0, pretend = 0, frame = 0
 1127              		@ frame_needed = 0, uses_anonymous_args = 0
 1128              		@ link register save eliminated.
 1129 0874 02C0A0E1 	.LVL110:
 1130              		.loc 1 1947 0
 1131              		ldr	r0, [r0, #40]
 1132 0878 0010A0E1 	.LVL111:
 1133              		.loc 1 1945 0
 1134 087c 00E0A0E3 		@ lr needed for prologue
 1135 0880 070000EA 		.loc 1 1947 0
 1136              		bx	lr
1909:../lib/fat16.c **** d clusters as free.
1910:../lib/fat16.c ****                              */
1911:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1912:../lib/fat16.c ****     #else
 1137              	e	fat16_file_size, .-fat16_file_size
 1138 0884 0030DEE7 		.align	2
 1139 0888 0120D1E5 		.global	fat16_read_dir
 1141 088c 022493E1 	fat16_read_dir:
1913:../lib/fat16.c **** as free.
 1142              	3:
 1143 0890 B030DC01 		.loc 1 1390 0
 1144 0894 01308302 		@ Function supports interworking.
 1145 0898 B030CC01 		@ args = 0, pretend = 0, frame = 48
1914:../lib/fat16.c **** he directory entry. The next thing to do is
1915:../lib/fat16.c ****                              * marking all occupied clusters as free.
 1146              	rame_needed = 0, uses_anonymous_args = 0
 1147 089c 021081E2 	.LVL112:
 1148 08a0 02E08EE2 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1149              	.LCFI13:
 1150              		.loc 1 1391 0
 1151              		mov	sl, r1
 1152 08a4 FF300EE2 		rsbs	r1, r1, #1
 1153 08a8 040053E1 		movcc	r1, #0
 1154 08ac F4FFFF3A 	.LVL113:
1916:../lib/fat16.c **** he directory entry. The next thing to do is
1917:../lib/fat16.c ****                              * marking all occupied clusters as free.
1918:../lib/fat16.c ****                              */
1919:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
 1155              	#0
 1156 08b0 0100A0E3 		cmpne	r0, #0
 1157              		.loc 1 1390 0
 1158 08b4 1040BDE8 		sub	sp, sp, #56
 1159 08b8 1EFF2FE1 	.LCFI14:
 1160              		.loc 1 1391 0
 1161              		mov	r8, r0
 1162              		beq	.L184
 1163              	.LVL114:
 1164              		.loc 1 1394 0
 1165              		ldrh	r3, [r0, #38]
 1166              		cmp	r3, #0
1920:../lib/fat16.c **** d clusters as free.
1921:../lib/fat16.c ****                              */
1922:../lib/fat16.c ****         return fat16_free_clusters(fs, dir_entry->cluster);
1923:../lib/fat16.c ****     #else
1924:../lib/fat16.c ****         return 0;
1925:../lib/fat16.c ****     #endif
1926:../lib/fat16.c **** }
1927:../lib/fat16.c **** 
1928:../lib/fat16.c **** /**
1929:../lib/fat16.c ****  * \ingroup fat16_fs
1930:../lib/fat16.c ****  * Returns the amount of total storage capacity of the filesystem in bytes.
1931:../lib/fat16.c ****  *
1932:../lib/fat16.c ****  * \param[in] fs The filesystem on which to operate.
1933:../lib/fat16.c ****  * \returns 0 on failure, the filesystem size in bytes otherwise.
1934:../lib/fat16.c ****  */
1935:../lib/fat16.c **** uint32_t fat16_get_fs_size(const struct fat16_fs_struct* fs)
1936:../lib/fat16.c **** {
1937:../lib/fat16.c ****     if(!fs)
1938:../lib/fat16.c ****         return 0;
1939:../lib/fat16.c **** 
1940:../lib/fat16.c ****     return (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
1941:../lib/fat16.c **** }
1942:../lib/fat16.c **** 
1943:../lib/fat16.c **** /**
1944:../lib/fat16.c ****  * \ingroup fat16_fs
1945:../lib/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
 1167              	0, #48]
 1168              		ldr	r6, [r0, #0]
 1169              		bne	.L166
 1170              	.LVL115:
 1171              	.LBB26:
 1172              		.loc 1 358 0
1946:../lib/fat16.c **** roup fat16_fs
1947:../lib/fat16.c ****  * Returns the amount of free storage capacity on the filesystem in bytes.
 1173              	6, #0
 1174 08bc 280090E5 		movne	r7, r1
 1175              		orreq	r7, r1, #1
 1176              		cmp	r7, #0
 1177              		bne	.L168
 1178              	.LBB27:
 1179 08c0 1EFF2FE1 		.loc 1 363 0
 1180              		ldr	r3, [r6, #0]
 1181              		.loc 1 368 0
 1182              		add	r5, sp, #44
 1183              		.loc 1 362 0
 1184              		add	r4, r6, #4
 1185              	.LVL116:
 1186              		.loc 1 368 0
 1187              		mov	r1, r7
 1188              		mov	r2, #12
 1189              		mov	r0, r5
 1190              	.LVL117:
 1191              		.loc 1 363 0
 1192 08c4 F04F2DE9 		ldr	r6, [r3, #4]
 1193              	.LVL118:
 1194              		.loc 1 368 0
 1195 08c8 01A0A0E1 		bl	memset
 1196 08cc 011071E2 	.LBE27:
 1197 08d0 0010A033 		.loc 1 370 0
 1198              	.LBB28:
 1199 08d4 00005AE3 		add	r0, r4, #16
 1200 08d8 00005013 		ldmia	r0, {r0, r3}	@ phole ldm
 1201              	.LBE28:
 1202 08dc 38D04DE2 		ldr	r2, .L188
 1203              		rsb	r3, r0, r3
 1204              		mov	r3, r3, asl #16
 1205 08e0 0080A0E1 		add	r4, sp, #12
 1206 08e4 7600000A 	.LVL119:
 1207              		str	r2, [sp, #0]
 1208              	.LBB29:
 1209 08e8 B632D0E1 		.loc 1 369 0
 1210 08ec 000053E3 		strh	r9, [sp, #46]	@ movhi
 1211 08f0 B093D0E1 	.LBE29:
 1212 08f4 006090E5 		.loc 1 370 0
 1213 08f8 2C00001A 		str	r5, [sp, #4]
 1214              		mov	r3, r3, lsr #16
 1215              		mov	r1, r4
 1216              		mov	r2, #32
 1217 08fc 000056E3 		mov	lr, pc
 1218 0900 0170A011 		bx	r6
 1219 0904 01708103 	.LBB30:
 1220 0908 000057E3 		cmp	r0, #0
 1221 090c 6A00001A 		beq	.L168
 1222              		ldr	r3, [sp, #48]
 1223              		cmp	r3, #0
 1224 0910 003096E5 		beq	.L168
 1225              		.loc 1 381 0
 1226 0914 2C508DE2 		mov	r1, r7
 1227              		mov	r2, #44
 1228 0918 044086E2 		mov	r0, sl
 1229              		bl	memset
 1230              	.LBE30:
 1231 091c 0710A0E1 		.loc 1 382 0
 1232 0920 0C20A0E3 		ldr	r2, .L188+4
 1233 0924 0500A0E1 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 1234              		stmia	sp, {r2, sl}	@ phole stm
 1235              		mov	r1, r4
 1236 0928 046093E5 		ldr	r0, [sp, #48]
 1237              		mov	r2, #32
 1238              		mov	lr, pc
 1239 092c FEFFFFEB 		bx	r6
 1240              		b	.L187
 1241              	.LVL120:
 1242              	.L166:
 1243 0930 100084E2 	.LBE26:
 1244 0934 090090E8 	.LBB31:
 1245              	.LBB32:
 1246 0938 94219FE5 		.loc 1 406 0
 1247 093c 033060E0 		cmp	r6, #0
 1248 0940 0338A0E1 	.LBE32:
 1249 0944 0C408DE2 	.LBE31:
 1250              		.loc 1 1400 0
 1251 0948 00208DE5 		str	r9, [sp, #8]
 1252              	.LVL121:
 1253              	.LBB33:
 1254 094c BE92CDE1 	.LBB34:
 1255              		.loc 1 406 0
 1256              		beq	.L168
 1257 0950 04508DE5 		cmp	r1, #0
 1258 0954 2338A0E1 		bne	.L168
 1259 0958 0410A0E1 		add	r0, r0, #4
 1260 095c 2020A0E3 	.LVL122:
 1261 0960 0FE0A0E1 		.loc 1 410 0
 1262 0964 16FF2FE1 		ldrb	r3, [r0, #32]	@ zero_extendqisi2
 1263              		tst	r3, #16
 1264 0968 000050E3 		beq	.L168
 1265 096c 5200000A 		.loc 1 417 0
 1266 0970 30309DE5 		ldrh	r7, [r0, #34]
 1267 0974 000053E3 	.LVL123:
 1268 0978 4F00000A 		.loc 1 416 0
 1269              		ldrh	r9, [r6, #18]
 1270 097c 0710A0E1 	.LVL124:
 1271 0980 2C20A0E3 	.LVL125:
 1272 0984 0A00A0E1 	.L177:
 1273 0988 FEFFFFEB 		.loc 1 423 0
 1274              		ldr	r2, [r6, #24]
 1275              		sub	r3, r7, #2
 1276 098c 44219FE5 		mla	r5, r9, r3, r2
 1277 0990 3430DDE5 		.loc 1 426 0
 1278 0994 04048DE8 		add	r4, sp, #44
 1279 0998 0410A0E1 		mov	r1, #0
 1280 099c 30009DE5 		mov	r2, #12
 1281 09a0 2020A0E3 		mov	r0, r4
 1282 09a4 0FE0A0E1 	.LVL126:
 1283 09a8 16FF2FE1 		bl	memset
 1284 09ac 390000EA 		.loc 1 427 0
 1285              		ldr	r3, [sp, #8]
 1286              		strh	r3, [sp, #46]	@ movhi
 1287              	.LBE34:
 1288              		.loc 1 428 0
 1289              		ldr	r3, .L188
 1290              		add	fp, sp, #12
 1291 09b0 000056E3 		ldr	ip, [r6, #0]
 1292              		mov	r1, fp
 1293              		str	r3, [sp, #0]
 1294              		mov	r0, r5
 1295 09b4 08908DE5 		str	r4, [sp, #4]
 1296              		mov	r2, #32
 1297              		mov	r3, r9
 1298              		ldr	ip, [ip, #4]
 1299              		mov	lr, pc
 1300 09b8 3F00000A 		bx	ip
 1301 09bc 000051E3 	.LBB35:
 1302 09c0 3D00001A 		cmp	r0, #0
 1303 09c4 040080E2 	.LBE35:
 1304              		.loc 1 442 0
 1305              		mov	r1, r7
 1306 09c8 2030D0E5 		mov	r0, r6
 1307 09cc 100013E3 	.LVL127:
 1308 09d0 3900000A 	.LBB36:
 1309              		.loc 1 428 0
 1310 09d4 B272D0E1 		beq	.L168
 1311              		.loc 1 438 0
 1312              		ldr	r3, [sp, #48]
 1313 09d8 B291D6E1 		cmp	r3, #0
 1314              		bne	.L179
 1315              	.LBE36:
 1316              		.loc 1 442 0
 1317              		bl	fat16_get_next_cluster
 1318 09dc 182096E5 	.LVL128:
 1319 09e0 023047E2 	.LBB37:
 1320 09e4 992325E0 		subs	r7, r0, #0
 1321              		beq	.L168
 1322 09e8 2C408DE2 		b	.L177
 1323 09ec 0010A0E3 	.LVL129:
 1324 09f0 0C20A0E3 	.L179:
 1325 09f4 0400A0E1 		.loc 1 446 0
 1326              		mov	r1, #0
 1327 09f8 FEFFFFEB 		mov	r2, #44
 1328              		mov	r0, sl
 1329 09fc 08309DE5 	.LVL130:
 1330 0a00 BE32CDE1 		bl	memset
 1331              	.LBE37:
 1332              		.loc 1 449 0
 1333 0a04 C8309FE5 		ldr	r2, .L188+4
 1334 0a08 0CB08DE2 		ldr	ip, [r6, #0]
 1335 0a0c 00C096E5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 1336 0a10 0B10A0E1 		stmia	sp, {r2, sl}	@ phole stm
 1337 0a14 00308DE5 		mov	r1, fp
 1338 0a18 0500A0E1 		ldr	r0, [sp, #48]
 1339 0a1c 04408DE5 		mov	r2, #32
 1340 0a20 2020A0E3 		ldr	ip, [ip, #4]
 1341 0a24 0930A0E1 		mov	lr, pc
 1342 0a28 04C09CE5 		bx	ip
 1343 0a2c 0FE0A0E1 	.LVL131:
 1344 0a30 1CFF2FE1 	.L187:
 1345              	.LBB38:
 1346 0a34 000050E3 		cmp	r0, #0
 1347              		beq	.L168
 1348              	.LBE38:
 1349 0a38 0710A0E1 	.LBE33:
 1350 0a3c 0600A0E1 		.loc 1 1406 0
 1351              		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 1352              		cmp	r3, #0
 1353              		.loc 1 1408 0
 1354 0a40 1D00000A 		ldrneh	r3, [r8, #48]
 1355              		movne	r0, #1
 1356 0a44 30309DE5 		addne	r3, r3, #1
 1357 0a48 000053E3 		strneh	r3, [r8, #48]	@ movhi
 1358 0a4c 0300001A 		bne	.L165
 1359              	.LVL132:
 1360              	.L168:
 1361 0a50 F2FDFFEB 		.loc 1 1414 0
 1362              		mov	r3, #0	@ movhi
 1363              		strh	r3, [r8, #48]	@ movhi
 1364 0a54 007050E2 	.L184:
 1365 0a58 1700000A 		mov	r0, #0
 1366 0a5c DEFFFFEA 	.LVL133:
 1367              	.L165:
 1368              		.loc 1 1417 0
 1369              		add	sp, sp, #56
 1370 0a60 0010A0E3 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1371 0a64 2C20A0E3 		bx	lr
 1372 0a68 0A00A0E1 	.L189:
 1373              		.align	2
 1374 0a6c FEFFFFEB 	.L188:
 1375              		.word	fat16_dir_entry_seek_callback
 1376              		.word	fat16_dir_entry_read_callback
 1377 0a70 60209FE5 	.LFE23:
 1379 0a78 3430DDE5 		.align	2
 1380 0a7c 04048DE8 		.global	find_file_in_dir
 1382 0a84 30009DE5 	find_file_in_dir:
 1383 0a88 2020A0E3 	.LFB32:
 1384 0a8c 04C09CE5 		.loc 1 1922 0
 1385 0a90 0FE0A0E1 		@ Function supports interworking.
 1386 0a94 1CFF2FE1 		@ args = 0, pretend = 0, frame = 0
 1387              		@ frame_needed = 0, uses_anonymous_args = 0
 1388              	.LVL134:
 1389              		stmfd	sp!, {r4, r5, r6, lr}
 1390 0a98 000050E3 	.LCFI15:
 1391 0a9c 0600000A 		.loc 1 1922 0
 1392              		mov	r4, r1
 1393              		mov	r6, r2
 1394              		mov	r5, r3
 1395 0aa0 0030DAE5 		b	.L191
 1396 0aa4 000053E3 	.LVL135:
 1397              	.L192:
 1398 0aa8 B033D811 		.loc 1 1925 0
 1399 0aac 0100A013 		bl	strcmp
 1400 0ab0 01308312 	.LVL136:
 1401 0ab4 B033C811 		cmp	r0, #0
 1402 0ab8 0200001A 		bne	.L191
 1403              	.LBB39:
 1404              	.LBB40:
 1405              		.loc 1 1432 0
 1406 0abc 0030A0E3 		cmp	r4, #0
 1407 0ac0 B033C8E1 		moveq	r3, #1
 1408              		.loc 1 1435 0
 1409 0ac4 0000A0E3 		movne	r3, #1
 1410              		strneh	r0, [r4, #48]	@ movhi
 1411              		b	.L196
 1412              	.LVL137:
 1413 0ac8 38D08DE2 	.L191:
 1414 0acc F04FBDE8 	.LBE40:
 1415 0ad0 1EFF2FE1 	.LBE39:
 1416              		.loc 1 1923 0
 1417              		mov	r1, r5
 1418              		mov	r0, r4
 1419 0ad4 00000000 	.LVL138:
 1420 0ad8 00000000 		bl	fat16_read_dir
 1421              		subs	r3, r0, #0
 1422              		.loc 1 1925 0
 1423              		mov	r1, r6
 1424              		mov	r0, r5
 1425              		.loc 1 1923 0
 1426              		bne	.L192
 1427              	.L196:
 1428              		.loc 1 1933 0
 1429              		mov	r0, r3
 1430              		ldmfd	sp!, {r4, r5, r6, lr}
 1431              		bx	lr
 1432              	.LFE32:
 1434              		.global	__divsi3
 1435              		.align	2
 1437 0ae4 0260A0E1 	fat16_write_dir_entry:
 1438 0ae8 0350A0E1 	.LFB26:
 1439 0aec 070000EA 		.loc 1 1468 0
 1440              		@ Function supports interworking.
 1441              		@ args = 0, pretend = 0, frame = 32
 1442              		@ frame_needed = 0, uses_anonymous_args = 0
 1443 0af0 FEFFFFEB 	.LVL139:
 1444              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1445 0af4 000050E3 	.LCFI16:
 1446 0af8 0400001A 		.loc 1 1470 0
 1447              		cmp	r1, #0
 1448              		cmpne	r0, #0
 1449              		.loc 1 1468 0
 1450 0afc 000054E3 		sub	sp, sp, #32
 1451 0b00 0130A003 	.LCFI17:
 1452              		.loc 1 1470 0
 1453 0b04 0130A013 		mov	r6, r1
 1454 0b08 B003C411 		beq	.L202
 1455 0b0c 060000EA 	.LVL140:
 1456              		.loc 1 1473 0
 1457              		ldr	r3, [r0, #0]
 1458              		.loc 1 1475 0
 1459              		mov	r0, r1
 1460              	.LVL141:
 1461 0b10 0510A0E1 		.loc 1 1473 0
 1462 0b14 0400A0E1 		ldr	r9, [r3, #8]
 1463              	.LVL142:
 1464 0b18 FEFFFFEB 		.loc 1 1475 0
 1465 0b1c 003050E2 		bl	strlen
 1466              		and	r5, r0, #255
 1467 0b20 0610A0E1 	.LVL143:
 1468 0b24 0500A0E1 		.loc 1 1476 0
 1469              		mov	r1, #13
 1470 0b28 F0FFFF1A 		add	r0, r5, #12
 1471              		bl	__divsi3
 1472              		.loc 1 1482 0
 1473 0b2c 0300A0E1 		mov	r1, #32
 1474 0b30 7040BDE8 		.loc 1 1476 0
 1475 0b34 1EFF2FE1 		mov	r3, r0
 1476              		.loc 1 1482 0
 1477              		mov	r2, #11
 1478              		mov	r0, sp
 1479              		.loc 1 1476 0
 1480              		and	sl, r3, #255
 1481              	.LVL144:
 1482              		.loc 1 1474 0
 1483              		ldr	r8, [r6, #40]
 1484              	.LVL145:
 1485              		.loc 1 1482 0
 1486              		bl	memset
 1487              		.loc 1 1483 0
 1488 0b38 F0472DE9 		mov	r0, r6
 1489              		mov	r1, #46
 1490              		bl	strrchr
 1491 0b3c 000051E3 		.loc 1 1484 0
 1492 0b40 00005013 		cmp	r0, #0
 1493              		.loc 1 1482 0
 1494 0b44 20D04DE2 		mov	r7, sp
 1495              		.loc 1 1484 0
 1496              		beq	.L204
 1497 0b48 0160A0E1 	.LBB41:
 1498 0b4c 9800000A 		.loc 1 1486 0
 1499              		add	r4, r0, #1
 1500              	.LVL146:
 1501 0b50 003090E5 		.loc 1 1488 0
 1502              		mov	r0, r4
 1503 0b54 0100A0E1 		bl	strlen
 1504              		and	r2, r0, #255
 1505              	.LVL147:
 1506 0b58 089093E5 		.loc 1 1489 0
 1507              		rsb	r3, r2, r5
 1508              		sub	r3, r3, #1
 1509 0b5c FEFFFFEB 		.loc 1 1494 0
 1510 0b60 FF5000E2 		cmp	r2, #3
 1511              		movcs	r2, #3
 1512              	.LVL148:
 1513 0b64 0D10A0E3 		mov	r1, r4
 1514 0b68 0C0085E2 		add	r0, sp, #8
 1515 0b6c FEFFFFEB 		.loc 1 1489 0
 1516              		and	r5, r3, #255
 1517 0b70 2010A0E3 		.loc 1 1494 0
 1518              		bl	memcpy
 1519 0b74 0030A0E1 	.L204:
 1520              	.LBE41:
 1521 0b78 0B20A0E3 		.loc 1 1497 0
 1522 0b7c 0D00A0E1 		cmp	r5, #8
 1523              		bhi	.L206
 1524 0b80 FFA003E2 		.loc 1 1499 0
 1525              		mov	r0, sp
 1526              		mov	r2, r5
 1527 0b84 288096E5 		mov	r1, r6
 1528              		bl	memcpy
 1529              		b	.L208
 1530 0b88 FEFFFFEB 	.L206:
 1531              	.LBB42:
 1532 0b8c 0600A0E1 		.loc 1 1503 0
 1533 0b90 2E10A0E3 		mov	r2, #8
 1534 0b94 FEFFFFEB 		mov	r0, sp
 1535              		mov	r1, r6
 1536 0b98 000050E3 		bl	memcpy
 1537              		.loc 1 1508 0
 1538 0b9c 0D70A0E1 		ldrb	r3, [r6, #34]	@ zero_extendqisi2
 1539              	.LVL149:
 1540 0ba0 0B00000A 		.loc 1 1510 0
 1541              		cmp	r3, #159
 1542              		mov	r2, r3, lsr #4
 1543 0ba4 014080E2 		.loc 1 1511 0
 1544              		and	r3, r3, #15
 1545              	.LVL150:
 1546 0ba8 0400A0E1 		.loc 1 1510 0
 1547 0bac FEFFFFEB 		addls	r2, r2, #48
 1548 0bb0 FF2000E2 		addhi	r2, r2, #97
 1549              		.loc 1 1512 0
 1550              		cmp	r3, #9
 1551 0bb4 053062E0 		addls	r3, r3, #48
 1552 0bb8 013043E2 	.LVL151:
 1553              		addhi	r3, r3, #97
 1554 0bbc 030052E3 	.LVL152:
 1555 0bc0 0320A023 		.loc 1 1510 0
 1556              		strb	r2, [sp, #6]
 1557 0bc4 0410A0E1 		.loc 1 1512 0
 1558 0bc8 08008DE2 		strb	r3, [sp, #7]
 1559              	.L208:
 1560 0bcc FF5003E2 	.LBE42:
 1561              		.loc 1 1516 0
 1562 0bd0 FEFFFFEB 		mov	r1, #0
 1563              		mov	r2, #21
 1564              		add	r0, sp, #11
 1565              		bl	memset
 1566 0bd4 080055E3 		.loc 1 1517 0
 1567 0bd8 0400008A 		ldrb	r3, [r6, #32]	@ zero_extendqisi2
 1568              		strb	r3, [sp, #11]
 1569 0bdc 0D00A0E1 		.loc 1 1572 0
 1570 0be0 0520A0E1 		ldrh	r2, [r6, #34]
 1571 0be4 0610A0E1 		.loc 1 1573 0
 1572 0be8 FEFFFFEB 		mov	r3, r2, lsr #8
 1573 0bec 0E0000EA 		.loc 1 1572 0
 1574              		strb	r2, [sp, #26]
 1575              		.loc 1 1573 0
 1576              		strb	r3, [sp, #27]
 1577 0bf0 0820A0E3 		.loc 1 1574 0
 1578 0bf4 0D00A0E1 		ldr	r3, [r6, #36]
 1579 0bf8 0610A0E1 		.loc 1 1577 0
 1580 0bfc FEFFFFEB 		mov	r0, r3, lsr #24
 1581              		.loc 1 1575 0
 1582 0c00 2230D6E5 		mov	r2, r3, lsr #8
 1583              		.loc 1 1576 0
 1584              		mov	r1, r3, lsr #16
 1585 0c04 9F0053E3 		.loc 1 1575 0
 1586 0c08 2322A0E1 		strb	r2, [sp, #29]
 1587              		.loc 1 1576 0
 1588 0c0c 0F3003E2 		strb	r1, [sp, #30]
 1589              		.loc 1 1577 0
 1590              		strb	r0, [sp, #31]
 1591 0c10 30208292 		.loc 1 1574 0
 1592 0c14 61208282 		strb	r3, [sp, #28]
 1593              		.loc 1 1580 0
 1594 0c18 090053E3 		add	r0, r8, sl, asl #5
 1595 0c1c 30308392 		mov	r1, sp
 1596              		mov	r2, #32
 1597 0c20 61308382 		mov	lr, pc
 1598              		bx	r9
 1599              		cmp	r0, #0
 1600 0c24 0620CDE5 		.loc 1 1516 0
 1601              		mov	r4, sp
 1602 0c28 0730CDE5 	.LVL153:
 1603              		.loc 1 1580 0
 1604              		beq	.L202
 1605              		.loc 1 1584 0
 1606 0c2c 0010A0E3 		ldrb	r7, [sp, #0]	@ zero_extendqisi2
 1607 0c30 1520A0E3 	.LVL154:
 1608 0c34 0B008DE2 		mov	r1, sp
 1609 0c38 FEFFFFEB 	.L216:
 1610              		.loc 1 1587 0
 1611 0c3c 2030D6E5 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 1612 0c40 0B30CDE5 		mov	r3, r7, asl #7
 1613              		orr	r3, r3, r7, lsr #1
 1614 0c44 B222D6E1 		add	r3, r3, r2
 1615              		.loc 1 1586 0
 1616 0c48 2234A0E1 		add	r2, sp, #10
 1617              		cmp	r1, r2
 1618 0c4c 1A20CDE5 		.loc 1 1587 0
 1619              		and	r7, r3, #255
 1620 0c50 1B30CDE5 		.loc 1 1586 0
 1621              		bne	.L216
 1622 0c54 243096E5 		mov	r5, sl
 1623              	.LVL155:
 1624 0c58 230CA0E1 		b	.L218
 1625              	.L219:
 1626 0c5c 2324A0E1 	.LBB43:
 1627              		.loc 1 1593 0
 1628 0c60 2318A0E1 		mov	r1, #0
 1629              		mov	r2, #32
 1630 0c64 1D20CDE5 		mov	r0, sp
 1631              		bl	memset
 1632 0c68 1E10CDE5 		.loc 1 1594 0
 1633              		mov	r1, #255
 1634 0c6c 1F00CDE5 		mov	r2, #10
 1635              		add	r0, sp, #1
 1636 0c70 1C30CDE5 		bl	memset
 1637              		.loc 1 1595 0
 1638 0c74 8A0288E0 		mov	r1, #255
 1639 0c78 0D10A0E1 		mov	r2, #12
 1640 0c7c 2020A0E3 		add	r0, sp, #14
 1641 0c80 0FE0A0E1 		bl	memset
 1642 0c84 19FF2FE1 		.loc 1 1596 0
 1643 0c88 000050E3 		add	r0, sp, #28
 1644              		mov	r1, #255
 1645 0c8c 0D40A0E1 		mov	r2, #4
 1646              		bl	memset
 1647              		.loc 1 1599 0
 1648 0c90 4700000A 		cmp	r5, sl
 1649              		.loc 1 1600 0
 1650 0c94 0070DDE5 		orreq	r3, r5, #64
 1651              		.loc 1 1598 0
 1652 0c98 0D10A0E1 		strb	r5, [sp, #0]
 1653              		.loc 1 1600 0
 1654              		streqb	r3, [sp, #0]
 1655 0c9c 0120F1E5 		mov	r3, #13
 1656 0ca0 8733A0E1 		mla	lr, r5, r3, r6
 1657 0ca4 A73083E1 		mov	ip, #1
 1658 0ca8 023083E0 	.LVL156:
 1659              	.L222:
 1660 0cac 0A208DE2 		.loc 1 1607 0
 1661 0cb0 020051E1 		add	r3, ip, #1
 1662              		and	r3, r3, #255
 1663 0cb4 FF7003E2 	.LVL157:
 1664              		.loc 1 1608 0
 1665 0cb8 F7FFFF1A 		add	r2, r3, #1
 1666 0cbc 0A50A0E1 		.loc 1 1607 0
 1667              		add	r4, sp, #32
 1668 0cc0 370000EA 		ldrb	r0, [lr, #-13]	@ zero_extendqisi2
 1669              		add	r1, r4, ip
 1670              		.loc 1 1608 0
 1671              		and	ip, r2, #255
 1672 0cc4 0010A0E3 		.loc 1 1610 0
 1673 0cc8 2020A0E3 		cmp	ip, #11
 1674 0ccc 0D00A0E1 		.loc 1 1608 0
 1675 0cd0 FEFFFFEB 		add	r2, r4, r3
 1676              		mov	r3, #0
 1677 0cd4 FF10A0E3 	.LVL158:
 1678 0cd8 0A20A0E3 		.loc 1 1607 0
 1679 0cdc 01008DE2 		strb	r0, [r1, #-32]
 1680 0ce0 FEFFFFEB 		.loc 1 1610 0
 1681              		moveq	ip, #14
 1682 0ce4 FF10A0E3 		.loc 1 1608 0
 1683 0ce8 0C20A0E3 		strb	r3, [r2, #-32]
 1684 0cec 0E008DE2 		.loc 1 1610 0
 1685 0cf0 FEFFFFEB 		beq	.L223
 1686              		cmp	ip, #26
 1687 0cf4 1C008DE2 		addeq	ip, ip, #2
 1688 0cf8 FF10A0E3 	.L223:
 1689 0cfc 0420A0E3 		.loc 1 1620 0
 1690 0d00 FEFFFFEB 		ldrb	r3, [lr, #-13]	@ zero_extendqisi2
 1691              		cmp	r3, #0
 1692 0d04 0A0055E1 		.loc 1 1621 0
 1693              		add	lr, lr, #1
 1694 0d08 40308503 		.loc 1 1620 0
 1695              		beq	.L226
 1696 0d0c 0050CDE5 		.loc 1 1605 0
 1697              		cmp	ip, #30
 1698 0d10 0030CD05 		bls	.L222
 1699 0d14 0D30A0E3 	.L226:
 1700 0d18 95632EE0 		.loc 1 1625 0
 1701 0d1c 01C0A0E3 		mov	r3, #15
 1702              		strb	r3, [sp, #11]
 1703              		.loc 1 1631 0
 1704              		mov	r0, r8
 1705 0d20 01308CE2 		.loc 1 1628 0
 1706 0d24 FF3003E2 		strb	r7, [sp, #13]
 1707              		.loc 1 1631 0
 1708              		mov	r1, sp
 1709 0d28 012083E2 		mov	r2, #32
 1710              		mov	lr, pc
 1711 0d2c 20408DE2 		bx	r9
 1712 0d30 0D005EE5 	.LVL159:
 1713 0d34 0C1084E0 	.LBE43:
 1714              		.loc 1 1591 0
 1715 0d38 FFC002E2 		sub	r3, r5, #1
 1716              	.LBB44:
 1717 0d3c 0B005CE3 		.loc 1 1633 0
 1718              		add	r8, r8, #32
 1719 0d40 032084E0 	.LBE44:
 1720 0d44 0030A0E3 		.loc 1 1591 0
 1721              		and	r5, r3, #255
 1722              	.L218:
 1723 0d48 200041E5 		cmp	r5, #0
 1724              		bne	.L219
 1725 0d4c 0EC0A003 		mov	r0, #1
 1726              		b	.L229
 1727 0d50 203042E5 	.LVL160:
 1728              	.L202:
 1729 0d54 0100000A 		mov	r0, #0
 1730 0d58 1A005CE3 	.LVL161:
 1731 0d5c 02C08C02 	.L229:
 1732              		.loc 1 1641 0
 1733              		add	sp, sp, #32
 1734 0d60 0D305EE5 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1735 0d64 000053E3 		bx	lr
 1736              	.LFE26:
 1738              		.global	__udivsi3
 1739 0d6c 0100000A 		.align	2
 1740              		.global	fat16_resize_file
 1742 0d74 E9FFFF9A 	fat16_resize_file:
 1743              	.LFB20:
 1744              		.loc 1 1254 0
 1745 0d78 0F30A0E3 		@ Function supports interworking.
 1746 0d7c 0B30CDE5 		@ args = 0, pretend = 0, frame = 4
 1747              		@ frame_needed = 0, uses_anonymous_args = 0
 1748 0d80 0800A0E1 	.LVL162:
 1749              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1750 0d84 0D70CDE5 	.LCFI18:
 1751              		.loc 1 1256 0
 1752 0d88 0D10A0E1 		subs	r6, r0, #0
 1753 0d8c 2020A0E3 		.loc 1 1254 0
 1754 0d90 0FE0A0E1 		sub	sp, sp, #4
 1755 0d94 19FF2FE1 	.LCFI19:
 1756              		.loc 1 1254 0
 1757              		mov	sl, r1
 1758              		.loc 1 1256 0
 1759 0d98 013045E2 		beq	.L235
 1760              	.LVL163:
 1761              		.loc 1 1259 0
 1762 0d9c 208088E2 		ldrh	r4, [r6, #38]
 1763              	.LVL164:
 1764              		.loc 1 1260 0
 1765 0da0 FF5003E2 		ldr	r3, [r6, #0]
 1766              		.loc 1 1265 0
 1767 0da4 000055E3 		rsbs	r9, r1, #1
 1768 0da8 C5FFFF1A 		movcc	r9, #0
 1769 0dac 0100A0E3 		cmp	r4, #0
 1770 0db0 000000EA 		cmpeq	r1, #0
 1771              		.loc 1 1260 0
 1772              		ldrh	r8, [r3, #18]
 1773 0db4 0000A0E3 	.LVL165:
 1774              		.loc 1 1267 0
 1775              		movne	r7, r1
 1776              	.LVL166:
 1777 0db8 20D08DE2 		.loc 1 1265 0
 1778 0dbc F047BDE8 		bne	.L239
 1779 0dc0 1EFF2FE1 	.LVL167:
 1780              		b	.L237
 1781              	.LVL168:
 1782              	.L240:
 1783              	.LBB49:
 1784              		.loc 1 1273 0
 1785              		ldr	r0, [r6, #0]
 1786              		bl	fat16_get_next_cluster
 1787              	.LVL169:
 1788              		.loc 1 1274 0
 1789              		cmp	r0, #0
 1790              		beq	.L241
 1791              		.loc 1 1281 0
 1792              		rsb	r7, r8, r7
 1793 0dc4 F0472DE9 		mov	r4, r0
 1794              	.LVL170:
 1795              	.L239:
 1796 0dc8 006050E2 	.LBE49:
 1797              		.loc 1 1270 0
 1798 0dcc 04D04DE2 		cmp	r7, r8
 1799              	.LBB50:
 1800              		.loc 1 1273 0
 1801 0dd0 01A0A0E1 		mov	r1, r4
 1802              	.LBE50:
 1803 0dd4 5B00000A 		.loc 1 1270 0
 1804              		bhi	.L240
 1805              	.LVL171:
 1806 0dd8 B642D6E1 		.loc 1 1285 0
 1807              		rsbs	r5, r4, #1
 1808              		movcc	r5, #0
 1809 0ddc 003096E5 		cmp	r5, #0
 1810              		beq	.L244
 1811 0de0 019071E2 	.LVL172:
 1812 0de4 0090A033 	.L245:
 1813 0de8 000054E3 	.LBB51:
 1814 0dec 00005103 		.loc 1 1290 0
 1815              		mov	r1, r8
 1816 0df0 B281D3E1 		mov	r0, r7
 1817              		bl	__udivsi3
 1818              		mov	r0, r0, asl #16
 1819 0df4 0170A011 		mov	r2, r0, lsr #16
 1820              	.LVL173:
 1821              		.loc 1 1291 0
 1822 0df8 0600001A 		mul	r3, r8, r2
 1823              		cmp	r3, r7
 1824 0dfc 490000EA 		.loc 1 1292 0
 1825              		addcc	r3, r2, #1
 1826              		movcc	r3, r3, asl #16
 1827              		movcc	r2, r3, lsr #16
 1828              		.loc 1 1293 0
 1829 0e00 000096E5 		ldr	r0, [r6, #0]
 1830 0e04 05FDFFEB 		mov	r1, r4
 1831              		bl	fat16_append_clusters
 1832              	.LVL174:
 1833 0e08 000050E3 		.loc 1 1294 0
 1834 0e0c 4F00000A 		cmp	r0, #0
 1835              		beq	.L235
 1836 0e10 077068E0 		.loc 1 1297 0
 1837 0e14 0040A0E1 		cmp	r5, #0
 1838              		.loc 1 1300 0
 1839              		strneh	r0, [r6, #38]	@ movhi
 1840              		movne	r4, r0
 1841              	.LVL175:
 1842 0e18 080057E1 	.L244:
 1843              	.LBE51:
 1844              		.loc 1 1306 0
 1845 0e1c 0410A0E1 		cmp	r9, #0
 1846              		.loc 1 1307 0
 1847              		movne	r3, #0	@ movhi
 1848 0e20 F6FFFF8A 		strneh	r3, [r6, #38]	@ movhi
 1849              		.loc 1 1305 0
 1850              		str	sl, [r6, #40]
 1851 0e24 015074E2 		.loc 1 1308 0
 1852 0e28 0050A033 		ldr	r0, [r6, #0]
 1853 0e2c 000055E3 		add	r1, r6, #4
 1854 0e30 1100000A 		bl	fat16_write_dir_entry
 1855              		cmp	r0, #0
 1856              		beq	.L235
 1857              		.loc 1 1311 0
 1858              		cmp	r9, #0
 1859 0e34 0810A0E1 		.loc 1 1314 0
 1860 0e38 0700A0E1 		movne	r1, r4
 1861 0e3c FEFFFFEB 		ldrne	r0, [r6, #0]
 1862 0e40 0008A0E1 		.loc 1 1311 0
 1863 0e44 2028A0E1 		bne	.L263
 1864              	.LVL176:
 1865              		.loc 1 1316 0
 1866 0e48 980203E0 		cmp	r7, r8
 1867 0e4c 070053E1 		bhi	.L237
 1868              		mov	r3, r4, asl #16
 1869 0e50 01308232 		ldr	r5, [r6, #0]
 1870 0e54 0338A031 	.LVL177:
 1871 0e58 2328A031 		mov	r4, r3, lsr #16
 1872              	.LVL178:
 1873 0e5c 000096E5 	.LBB52:
 1874 0e60 0410A0E1 		.loc 1 887 0
 1875 0e64 4DFDFFEB 		cmp	r5, #0
 1876              		cmpne	r4, #1
 1877              		bls	.L237
 1878 0e68 000050E3 		.loc 1 891 0
 1879 0e6c 3500000A 		mov	r1, r4
 1880              	.LVL179:
 1881 0e70 000055E3 		mov	r0, r5
 1882              		bl	fat16_get_next_cluster
 1883 0e74 B602C611 	.LBB53:
 1884 0e78 0040A011 		.loc 1 895 0
 1885              		mvn	r3, #0
 1886              		.loc 1 896 0
 1887              		strb	r3, [sp, #3]
 1888              		.loc 1 895 0
 1889 0e7c 000059E3 		strb	r3, [sp, #2]
 1890              	.LBE53:
 1891 0e80 0030A013 		.loc 1 891 0
 1892 0e84 B632C611 		mov	r7, r0
 1893              	.LVL180:
 1894 0e88 28A086E5 		.loc 1 897 0
 1895              		ldr	r0, [r5, #8]
 1896 0e8c 000096E5 		ldr	r3, [r5, #0]
 1897 0e90 041086E2 		add	r0, r0, r4, asl #1
 1898 0e94 27FFFFEB 		add	r1, sp, #2
 1899 0e98 000050E3 		mov	r2, #2
 1900 0e9c 2900000A 		ldr	ip, [r3, #8]
 1901              		mov	lr, pc
 1902 0ea0 000059E3 		bx	ip
 1903              	.LBB54:
 1904 0ea4 0410A011 		cmp	r0, #0
 1905 0ea8 00009615 		beq	.L237
 1906              		.loc 1 901 0
 1907 0eac 1C00001A 		cmp	r7, #0
 1908              		beq	.L237
 1909              	.LBE54:
 1910 0eb0 080057E1 		.loc 1 902 0
 1911 0eb4 1B00008A 		mov	r0, r5
 1912 0eb8 0438A0E1 		mov	r1, r7
 1913 0ebc 005096E5 	.LVL181:
 1914              	.L263:
 1915 0ec0 2348A0E1 		bl	fat16_free_clusters
 1916              	.LVL182:
 1917              	.L237:
 1918              	.LBE52:
 1919 0ec4 000055E3 		.loc 1 1326 0
 1920 0ec8 01005413 		ldr	r3, [r6, #48]
 1921 0ecc 1500009A 		cmp	sl, r3
 1922              		.loc 1 1329 0
 1923 0ed0 0410A0E1 		movcc	r3, #0	@ movhi
 1924              		.loc 1 1326 0
 1925 0ed4 0500A0E1 		movcs	r0, #1
 1926 0ed8 D0FCFFEB 		.loc 1 1329 0
 1927              		movcc	r0, #1
 1928              		.loc 1 1328 0
 1929 0edc 0030E0E3 		strcc	sl, [r6, #48]
 1930              		.loc 1 1329 0
 1931 0ee0 0330CDE5 		strcch	r3, [r6, #52]	@ movhi
 1932              		b	.L261
 1933 0ee4 0230CDE5 	.LVL183:
 1934              	.L235:
 1935              		mov	r0, #0
 1936 0ee8 0070A0E1 		b	.L261
 1937              	.LVL184:
 1938              	.L241:
 1939 0eec 080095E5 		.loc 1 1285 0
 1940 0ef0 003095E5 		rsbs	r5, r4, #1
 1941 0ef4 840080E0 		movcc	r5, #0
 1942 0ef8 02108DE2 		b	.L245
 1943 0efc 0220A0E3 	.LVL185:
 1944 0f00 08C093E5 	.L261:
 1945 0f04 0FE0A0E1 		.loc 1 1336 0
 1946 0f08 1CFF2FE1 		add	sp, sp, #4
 1947              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1948 0f0c 000050E3 		bx	lr
 1949 0f10 0400000A 	.LFE20:
 1951 0f14 000057E3 		.align	2
 1952 0f18 0200000A 		.global	fat16_seek_file
 1954              	fat16_seek_file:
 1955 0f1c 0500A0E1 	.LFB19:
 1956 0f20 0710A0E1 		.loc 1 1204 0
 1957              		@ Function supports interworking.
 1958              		@ args = 0, pretend = 0, frame = 0
 1959 0f24 E7FCFFEB 		@ frame_needed = 0, uses_anonymous_args = 0
 1960              	.LVL186:
 1961              		.loc 1 1205 0
 1962              		cmp	r1, #0
 1963              		cmpne	r0, #0
 1964 0f28 303096E5 		.loc 1 1204 0
 1965 0f2c 03005AE1 		stmfd	sp!, {r4, r5, r6, lr}
 1966              	.LCFI20:
 1967 0f30 0030A033 		.loc 1 1204 0
 1968              		and	r2, r2, #255
 1969 0f34 0100A023 		.loc 1 1205 0
 1970              		mov	r5, r0
 1971 0f38 0100A033 		mov	r6, r1
 1972              		beq	.L265
 1973 0f3c 30A08635 	.LVL187:
 1974              		.loc 1 1209 0
 1975 0f40 B433C631 		cmp	r2, #1
 1976 0f44 040000EA 		.loc 1 1208 0
 1977              		ldr	r1, [r0, #48]
 1978              	.LVL188:
 1979 0f48 0000A0E3 		.loc 1 1209 0
 1980 0f4c 020000EA 		beq	.L268
 1981              	.LVL189:
 1982              		.loc 1 1212 0
 1983              		ldrcc	r4, [r6, #0]
 1984 0f50 015074E2 	.LVL190:
 1985 0f54 0050A033 		.loc 1 1209 0
 1986 0f58 B5FFFFEA 		bcc	.L270
 1987              		cmp	r2, #2
 1988              		bne	.L265
 1989              		b	.L269
 1990 0f5c 04D08DE2 	.LVL191:
 1991 0f60 F047BDE8 	.L268:
 1992 0f64 1EFF2FE1 		.loc 1 1215 0
 1993              		ldr	r3, [r6, #0]
 1994              		add	r4, r1, r3
 1995              	.LVL192:
 1996              		b	.L270
 1997              	.L269:
 1998              		.loc 1 1218 0
 1999              		ldr	r2, [r0, #40]
 2000              	.LVL193:
 2001              		ldr	r3, [r6, #0]
 2002              		add	r4, r2, r3
 2003              	.LVL194:
 2004              	.L270:
 2005              		.loc 1 1224 0
 2006 0f68 000051E3 		ldr	r3, [r5, #40]
 2007 0f6c 00005013 		cmp	r4, r3
 2008              		bls	.L271
 2009 0f70 70402DE9 	.LVL195:
 2010              		mov	r0, r5
 2011              		mov	r1, r4
 2012 0f74 FF2002E2 	.LVL196:
 2013              		bl	fat16_resize_file
 2014 0f78 0050A0E1 	.LVL197:
 2015 0f7c 0160A0E1 		cmp	r0, #0
 2016 0f80 1B00000A 		beq	.L265
 2017              	.LVL198:
 2018              	.L271:
 2019 0f84 010052E3 		.loc 1 1228 0
 2020              		mov	r3, #0	@ movhi
 2021 0f88 301090E5 		.loc 1 1230 0
 2022              		mov	r0, #1
 2023              		.loc 1 1227 0
 2024 0f8c 0400000A 		str	r4, [r5, #48]
 2025              		.loc 1 1228 0
 2026              		strh	r3, [r5, #52]	@ movhi
 2027 0f90 00409635 		.loc 1 1230 0
 2028              		str	r4, [r6, #0]
 2029              		b	.L273
 2030 0f94 0800003A 	.LVL199:
 2031 0f98 020052E3 	.L265:
 2032 0f9c 1400001A 		.loc 1 1231 0
 2033 0fa0 020000EA 		mov	r0, #0
 2034              	.L273:
 2035              		.loc 1 1232 0
 2036              		ldmfd	sp!, {r4, r5, r6, lr}
 2037 0fa4 003096E5 		bx	lr
 2038 0fa8 034081E0 	.LFE19:
 2040 0fac 020000EA 		.align	2
 2041              		.global	fat16_write_file
 2043 0fb0 282090E5 	fat16_write_file:
 2044              	.LFB18:
 2045 0fb4 003096E5 		.loc 1 1058 0
 2046 0fb8 034082E0 		@ Function supports interworking.
 2047              		@ args = 0, pretend = 0, frame = 4
 2048              		@ frame_needed = 0, uses_anonymous_args = 0
 2049              	.LVL200:
 2050 0fbc 283095E5 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2051 0fc0 030054E1 	.LCFI21:
 2052 0fc4 0400009A 		mov	r2, r2, asl #16
 2053              	.LVL201:
 2054 0fc8 0500A0E1 		sub	sp, sp, #4
 2055 0fcc 0410A0E1 	.LCFI22:
 2056              		.loc 1 1058 0
 2057 0fd0 FEFFFFEB 		mov	r2, r2, lsr #16
 2058              		.loc 1 1061 0
 2059 0fd4 000050E3 		cmp	r1, #0
 2060 0fd8 0500000A 		cmpne	r0, #0
 2061              		mov	r4, r0
 2062              		mov	fp, r1
 2063              		.loc 1 1058 0
 2064 0fdc 0030A0E3 		str	r2, [sp, #0]
 2065              	.LVL202:
 2066 0fe0 0100A0E3 		.loc 1 1061 0
 2067              		beq	.L276
 2068 0fe4 304085E5 	.LVL203:
 2069              		cmp	r2, #0
 2070 0fe8 B433C5E1 		beq	.L276
 2071              		.loc 1 1063 0
 2072 0fec 004086E5 		ldr	sl, [r0, #48]
 2073 0ff0 000000EA 		ldr	r3, [r0, #40]
 2074              		cmp	sl, r3
 2075              		bhi	.L276
 2076              	.LVL204:
 2077 0ff4 0000A0E3 		.loc 1 1067 0
 2078              		ldrh	r5, [r0, #52]
 2079              	.LVL205:
 2080 0ff8 7040BDE8 		.loc 1 1066 0
 2081 0ffc 1EFF2FE1 		ldr	r0, [r0, #0]
 2082              	.LVL206:
 2083              		.loc 1 1072 0
 2084              		cmp	r5, #0
 2085              		.loc 1 1066 0
 2086              		ldrh	r8, [r0, #18]
 2087              	.LVL207:
 2088              		.loc 1 1072 0
 2089              		bne	.L280
 2090              		.loc 1 1074 0
 2091              		ldrh	r5, [r4, #38]
 2092              		.loc 1 1076 0
 2093              		cmp	r5, #0
 2094 1000 F04F2DE9 		bne	.L282
 2095              		.loc 1 1078 0
 2096 1004 0228A0E1 		cmp	sl, #0
 2097              		bne	.L276
 2098 1008 04D04DE2 		.loc 1 1081 0
 2099              		mov	r1, r5
 2100              		mov	r2, #1
 2101 100c 2228A0E1 		bl	fat16_append_clusters
 2102              		.loc 1 1082 0
 2103 1010 000051E3 		cmp	r0, #0
 2104 1014 00005013 		.loc 1 1081 0
 2105 1018 0040A0E1 		mov	r5, r0
 2106 101c 01B0A0E1 		strh	r0, [r4, #38]	@ movhi
 2107              		.loc 1 1082 0
 2108 1020 00208DE5 		beq	.L276
 2109              	.LVL208:
 2110              	.L282:
 2111 1024 7700000A 		.loc 1 1091 0
 2112              		ldr	r6, [r4, #48]
 2113 1028 000052E3 	.LVL209:
 2114 102c 7500000A 		cmp	r6, #0
 2115              		rsbne	r9, r8, #0
 2116 1030 30A090E5 		rsbne	r7, r8, r6
 2117 1034 283090E5 		bne	.L286
 2118 1038 03005AE1 		b	.L280
 2119 103c 7100008A 	.LVL210:
 2120              	.L287:
 2121              	.LBB55:
 2122 1040 B453D0E1 		.loc 1 1098 0
 2123              		ldr	r0, [r4, #0]
 2124              	.LVL211:
 2125 1044 000090E5 		bl	fat16_get_next_cluster
 2126              	.LVL212:
 2127              		.loc 1 1099 0
 2128 1048 000055E3 		cmp	r0, #0
 2129              		cmpeq	r7, #0
 2130 104c B281D0E1 	.LBE55:
 2131              		.loc 1 1091 0
 2132              		add	r6, r6, r9
 2133 1050 2000001A 	.LBB56:
 2134              		.loc 1 1101 0
 2135 1054 B652D4E1 		add	r7, r7, r9
 2136              		mov	r1, r5
 2137 1058 000055E3 		mov	r2, #1
 2138 105c 0800001A 		.loc 1 1099 0
 2139              		.loc 1 1101 0
 2140 1060 00005AE3 		ldreq	r0, [r4, #0]
 2141 1064 6700001A 	.LVL213:
 2142              		bleq	fat16_append_clusters
 2143 1068 0510A0E1 	.LVL214:
 2144 106c 0120A0E3 	.L288:
 2145 1070 CAFCFFEB 		.loc 1 1102 0
 2146              		subs	r5, r0, #0
 2147 1074 000050E3 		beq	.L276
 2148              	.LVL215:
 2149 1078 0050A0E1 	.L286:
 2150 107c B602C4E1 		.loc 1 1095 0
 2151              		cmp	r6, r8
 2152 1080 6000000A 		.loc 1 1098 0
 2153              		mov	r1, r5
 2154              		.loc 1 1095 0
 2155              		bcs	.L287
 2156 1084 306094E5 	.LVL216:
 2157              	.L280:
 2158 1088 000056E3 	.LBE56:
 2159 108c 00906812 		.loc 1 1069 0
 2160 1090 06706810 		mov	r0, sl
 2161 1094 0C00001A 	.LVL217:
 2162 1098 0E0000EA 		mov	r1, r8
 2163              		bl	__umodsi3
 2164              		ldr	r7, [sp, #0]
 2165              	.LVL218:
 2166              		mov	r0, r0, asl #16
 2167 109c 000094E5 		mov	sl, r0, lsr #16
 2168              	.LVL219:
 2169 10a0 5EFCFFEB 	.LVL220:
 2170              	.L290:
 2171              	.LBB57:
 2172 10a4 000050E3 		.loc 1 1115 0
 2173 10a8 00005703 		ldr	ip, [r4, #0]
 2174              		.loc 1 1116 0
 2175              		rsb	r3, sl, r8
 2176 10ac 096086E0 		.loc 1 1121 0
 2177              		ldr	r2, [ip, #24]
 2178              		.loc 1 1116 0
 2179 10b0 097087E0 		mov	r3, r3, asl #16
 2180 10b4 0510A0E1 		mov	r3, r3, lsr #16
 2181 10b8 0120A0E3 	.LVL221:
 2182              		cmp	r7, r3
 2183              		movcc	r6, r7
 2184 10bc 00009405 		movcs	r6, r3
 2185              	.LVL222:
 2186 10c0 B6FCFF0B 		.loc 1 1121 0
 2187              		add	r2, sl, r2
 2188              		sub	r3, r5, #2
 2189              	.LVL223:
 2190 10c4 005050E2 		mla	r0, r8, r3, r2
 2191 10c8 4E00000A 	.LVL224:
 2192              		mov	r1, fp
 2193              		mov	r2, r6
 2194              		ldr	r3, [ip, #0]
 2195 10cc 080056E1 		ldr	ip, [r3, #8]
 2196              		mov	lr, pc
 2197 10d0 0510A0E1 		bx	ip
 2198              		.loc 1 1126 0
 2199 10d4 F0FFFF2A 		rsb	r3, r6, r7
 2200              		.loc 1 1121 0
 2201              		cmp	r0, #0
 2202              	.LBB58:
 2203              		.loc 1 1132 0
 2204 10d8 0A00A0E1 		mov	r1, r5
 2205              	.LBE58:
 2206 10dc 0810A0E1 		.loc 1 1125 0
 2207 10e0 FEFFFFEB 		add	fp, fp, r6
 2208 10e4 00709DE5 		.loc 1 1129 0
 2209              		add	r2, sl, r6
 2210 10e8 0008A0E1 		.loc 1 1126 0
 2211 10ec 20A8A0E1 		mov	r0, r3, asl #16
 2212              		.loc 1 1121 0
 2213              		beq	.L291
 2214              		.loc 1 1127 0
 2215              		ldr	r3, [r4, #48]
 2216              		.loc 1 1129 0
 2217 10f0 00C094E5 		cmp	r2, r8
 2218              		.loc 1 1127 0
 2219 10f4 08306AE0 		add	r3, r3, r6
 2220              		str	r3, [r4, #48]
 2221 10f8 18209CE5 		.loc 1 1126 0
 2222              		mov	r7, r0, lsr #16
 2223 10fc 0338A0E1 		.loc 1 1129 0
 2224 1100 2338A0E1 		blt	.L293
 2225              	.LBB59:
 2226 1104 030057E1 		.loc 1 1132 0
 2227 1108 0760A031 		ldr	r0, [r4, #0]
 2228 110c 0360A021 		bl	fat16_get_next_cluster
 2229              		.loc 1 1139 0
 2230              		mov	sl, #0
 2231 1110 02208AE0 	.LVL225:
 2232 1114 023045E2 		.loc 1 1133 0
 2233              		cmp	r0, sl
 2234 1118 982320E0 		movne	r3, #0
 2235              		moveq	r3, #1
 2236 111c 0B10A0E1 		cmp	r7, sl
 2237 1120 0620A0E1 		moveq	r3, #0
 2238 1124 00309CE5 		cmp	r3, sl
 2239 1128 08C093E5 		.loc 1 1135 0
 2240 112c 0FE0A0E1 		mov	r1, r5
 2241 1130 1CFF2FE1 		mov	r2, #1
 2242              		.loc 1 1133 0
 2243 1134 073066E0 		.loc 1 1135 0
 2244              		ldrne	r0, [r4, #0]
 2245 1138 000050E3 	.LVL226:
 2246              		blne	fat16_append_clusters
 2247              	.LVL227:
 2248 113c 0510A0E1 	.L295:
 2249              		.loc 1 1136 0
 2250              		cmp	r0, #0
 2251 1140 06B08BE0 		.loc 1 1139 0
 2252              		mov	r5, r0
 2253 1144 06208AE0 		.loc 1 1136 0
 2254              		beq	.L305
 2255 1148 0308A0E1 	.LVL228:
 2256              	.L293:
 2257 114c 1800000A 	.LBE59:
 2258              	.LBE57:
 2259 1150 303094E5 		.loc 1 1149 0
 2260              		cmp	r7, #0
 2261 1154 080052E1 	.LBB60:
 2262              		.loc 1 1146 0
 2263 1158 063083E0 		strh	r5, [r4, #52]	@ movhi
 2264 115c 303084E5 	.LBE60:
 2265              		.loc 1 1149 0
 2266 1160 2078A0E1 		bne	.L290
 2267              	.L291:
 2268 1164 0F0000BA 		.loc 1 1152 0
 2269              		ldr	r3, [r4, #48]
 2270              		ldr	r5, [r4, #40]
 2271 1168 000094E5 	.LVL229:
 2272 116c 2BFCFFEB 		cmp	r3, r5
 2273              		bls	.L300
 2274 1170 00A0A0E3 	.LBB61:
 2275              		.loc 1 1157 0
 2276              		str	r3, [r4, #40]
 2277 1174 0A0050E1 		.loc 1 1159 0
 2278 1178 0030A013 		ldr	r0, [r4, #0]
 2279 117c 0130A003 	.LVL230:
 2280 1180 0A0057E1 		add	r1, r4, #4
 2281 1184 0030A003 		bl	fat16_write_dir_entry
 2282 1188 0A0053E1 		cmp	r0, #0
 2283              		.loc 1 1165 0
 2284 118c 0510A0E1 		ldreq	r3, [r4, #48]
 2285 1190 0120A0E3 		rsbeq	r3, r5, r3
 2286              		moveq	r3, r3, asl #16
 2287              		.loc 1 1166 0
 2288 1194 00009415 		streq	r5, [r4, #48]
 2289              		.loc 1 1165 0
 2290 1198 80FCFF1B 		moveq	r7, r3, lsr #16
 2291              	.LVL231:
 2292              	.L300:
 2293              	.LBE61:
 2294 119c 000050E3 		.loc 1 1170 0
 2295              		ldr	r2, [sp, #0]
 2296 11a0 0050A0E1 		rsb	r3, r7, r2
 2297              		mov	r3, r3, asl #16
 2298 11a4 1500000A 		mov	r0, r3, asr #16
 2299              	.LVL232:
 2300              		b	.L303
 2301              	.LVL233:
 2302              	.L305:
 2303              	.LBB62:
 2304 11a8 000057E3 	.LBB63:
 2305              		.loc 1 1138 0
 2306              		strh	r0, [r4, #52]	@ movhi
 2307 11ac B453C4E1 		b	.L291
 2308              	.LVL234:
 2309              	.L276:
 2310 11b0 CEFFFF1A 	.LBE63:
 2311              	.LBE62:
 2312              		.loc 1 1170 0
 2313 11b4 303094E5 		mvn	r0, #0
 2314 11b8 285094E5 	.LVL235:
 2315              	.L303:
 2316 11bc 050053E1 		.loc 1 1175 0
 2317 11c0 0900009A 		add	sp, sp, #4
 2318              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2319              		bx	lr
 2320 11c4 283084E5 	.LFE18:
 2322 11c8 000094E5 		.align	2
 2323              		.global	fat16_close_dir
 2325 11d0 58FEFFEB 	fat16_close_dir:
 2326 11d4 000050E3 	.LFB22:
 2327              		.loc 1 1375 0
 2328 11d8 30309405 		@ Function supports interworking.
 2329 11dc 03306500 		@ args = 0, pretend = 0, frame = 0
 2330 11e0 0338A001 		@ frame_needed = 0, uses_anonymous_args = 0
 2331              	.LVL236:
 2332 11e4 30508405 		.loc 1 1376 0
 2333              		cmp	r0, #0
 2334 11e8 2378A001 		.loc 1 1375 0
 2335              		str	lr, [sp, #-4]!
 2336              	.LCFI23:
 2337              		.loc 1 1376 0
 2338              		.loc 1 1377 0
 2339 11ec 00209DE5 		blne	free
 2340 11f0 023067E0 	.LVL237:
 2341 11f4 0338A0E1 	.LVL238:
 2342 11f8 4308A0E1 	.L309:
 2343              		.loc 1 1378 0
 2344 11fc 020000EA 		ldr	lr, [sp], #4
 2345              		bx	lr
 2346              	.LFE22:
 2348              		.align	2
 2349              		.global	fat16_close_file
 2351 1204 EAFFFFEA 	fat16_close_file:
 2352              	.LFB16:
 2353              		.loc 1 944 0
 2354              		@ Function supports interworking.
 2355              		@ args = 0, pretend = 0, frame = 0
 2356              		@ frame_needed = 0, uses_anonymous_args = 0
 2357 1208 0000E0E3 	.LVL239:
 2358              		.loc 1 945 0
 2359              		cmp	r0, #0
 2360              		.loc 1 944 0
 2361 120c 04D08DE2 		str	lr, [sp, #-4]!
 2362 1210 F04FBDE8 	.LCFI24:
 2363 1214 1EFF2FE1 		.loc 1 945 0
 2364              		.loc 1 946 0
 2365              		blne	free
 2366              	.LVL240:
 2367              	.LVL241:
 2368              	.L313:
 2369              		.loc 1 947 0
 2370              		ldr	lr, [sp], #4
 2371              		bx	lr
 2372              	.LFE16:
 2374              		.align	2
 2375              		.global	fat16_close
 2377 1218 000050E3 	fat16_close:
 2378              	.LFB3:
 2379 121c 04E02DE5 		.loc 1 243 0
 2380              		@ Function supports interworking.
 2381              		@ args = 0, pretend = 0, frame = 0
 2382              		@ frame_needed = 0, uses_anonymous_args = 0
 2383 1220 FEFFFF1B 	.LVL242:
 2384              		.loc 1 244 0
 2385              		cmp	r0, #0
 2386              		.loc 1 243 0
 2387              		str	lr, [sp, #-4]!
 2388 1224 04E09DE4 	.LCFI25:
 2389 1228 1EFF2FE1 		.loc 1 244 0
 2390              		.loc 1 247 0
 2391              		blne	free
 2392              	.LVL243:
 2393              	.LVL244:
 2394              	.L317:
 2395              		.loc 1 248 0
 2396              		ldr	lr, [sp], #4
 2397              		bx	lr
 2398              	.LFE3:
 2400              		.align	2
 2401              		.global	fat16_open_dir
 2403 122c 000050E3 	fat16_open_dir:
 2404              	.LFB21:
 2405 1230 04E02DE5 		.loc 1 1348 0
 2406              		@ Function supports interworking.
 2407              		@ args = 0, pretend = 0, frame = 0
 2408              		@ frame_needed = 0, uses_anonymous_args = 0
 2409 1234 FEFFFF1B 	.LVL245:
 2410              		.loc 1 1349 0
 2411              		cmp	r1, #0
 2412              		cmpne	r0, #0
 2413              		.loc 1 1348 0
 2414 1238 04E09DE4 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2415 123c 1EFF2FE1 	.LCFI26:
 2416              		.loc 1 1349 0
 2417              		mov	r7, r0
 2418              		mov	r5, r1
 2419              		movne	r8, #0
 2420              		moveq	r8, #1
 2421              		beq	.L319
 2422              	.LVL246:
 2423              		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2424              		tst	r3, #16
 2425              		.loc 1 1352 0
 2426              		mov	r0, #52
 2427              		.loc 1 1349 0
 2428              		beq	.L319
 2429 1240 000050E3 	.LVL247:
 2430              		.loc 1 1352 0
 2431 1244 04E02DE5 		bl	malloc
 2432              	.LVL248:
 2433              		.loc 1 1353 0
 2434              		cmp	r0, #0
 2435 1248 FEFFFF1B 		.loc 1 1352 0
 2436              		mov	r6, r0
 2437              	.LVL249:
 2438              		.loc 1 1356 0
 2439              		add	r4, r0, #4
 2440 124c 04E09DE4 		.loc 1 1353 0
 2441 1250 1EFF2FE1 		beq	.L319
 2442              	.LVL250:
 2443              		.loc 1 1356 0
 2444              		mov	ip, r5
 2445              		ldmia	ip!, {r0, r1, r2, r3}
 2446              	.LVL251:
 2447              		mov	lr, r4
 2448              		stmia	lr!, {r0, r1, r2, r3}
 2449              		ldmia	ip!, {r0, r1, r2, r3}
 2450              		stmia	lr!, {r0, r1, r2, r3}
 2451              		ldmia	ip, {r0, r1, r2}
 2452              		.loc 1 1357 0
 2453              		str	r7, [r6, #0]
 2454              		.loc 1 1356 0
 2455 1254 000051E3 		stmia	lr, {r0, r1, r2}
 2456 1258 00005013 		.loc 1 1358 0
 2457              		strh	r8, [r6, #48]	@ movhi
 2458 125c F0412DE9 		b	.L323
 2459              	.LVL252:
 2460              	.L319:
 2461 1260 0070A0E1 		.loc 1 1360 0
 2462 1264 0150A0E1 		mov	r6, #0
 2463 1268 0080A013 	.LVL253:
 2464 126c 0180A003 	.L323:
 2465 1270 1300000A 		.loc 1 1361 0
 2466              		mov	r0, r6
 2467 1274 2030D1E5 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2468 1278 100013E3 		bx	lr
 2469              	.LFE21:
 2471              		.align	2
 2472 1280 0F00000A 		.global	fat16_open_file
 2474              	fat16_open_file:
 2475 1284 FEFFFFEB 	.LFB15:
 2476              		.loc 1 920 0
 2477              		@ Function supports interworking.
 2478 1288 000050E3 		@ args = 0, pretend = 0, frame = 0
 2479              		@ frame_needed = 0, uses_anonymous_args = 0
 2480 128c 0060A0E1 	.LVL254:
 2481              		.loc 1 921 0
 2482              		cmp	r1, #0
 2483 1290 044080E2 		cmpne	r0, #0
 2484              		.loc 1 920 0
 2485 1294 0A00000A 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2486              	.LCFI27:
 2487              		.loc 1 921 0
 2488 1298 05C0A0E1 		mov	r5, r1
 2489 129c 0F00BCE8 		mov	r7, r0
 2490              		beq	.L326
 2491 12a0 04E0A0E1 	.LVL255:
 2492 12a4 0F00AEE8 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2493 12a8 0F00BCE8 		ands	r8, r3, #16
 2494 12ac 0F00AEE8 		.loc 1 924 0
 2495 12b0 07009CE8 		mov	r0, #56
 2496              		.loc 1 921 0
 2497 12b4 007086E5 		bne	.L326
 2498              	.LVL256:
 2499 12b8 07008EE8 		.loc 1 924 0
 2500              		bl	malloc
 2501 12bc B083C6E1 	.LVL257:
 2502 12c0 000000EA 		.loc 1 925 0
 2503              		cmp	r0, #0
 2504              		.loc 1 924 0
 2505              		mov	r6, r0
 2506 12c4 0060A0E3 	.LVL258:
 2507              		.loc 1 928 0
 2508              		add	r4, r0, #4
 2509              		.loc 1 925 0
 2510 12c8 0600A0E1 		beq	.L326
 2511 12cc F041BDE8 	.LVL259:
 2512 12d0 1EFF2FE1 		.loc 1 928 0
 2513              		mov	ip, r5
 2514              		ldmia	ip!, {r0, r1, r2, r3}
 2515              	.LVL260:
 2516              		mov	lr, r4
 2517              		stmia	lr!, {r0, r1, r2, r3}
 2518              		ldmia	ip!, {r0, r1, r2, r3}
 2519              		stmia	lr!, {r0, r1, r2, r3}
 2520              		ldmia	ip, {r0, r1, r2}
 2521              		stmia	lr, {r0, r1, r2}
 2522              		.loc 1 931 0
 2523              		ldrh	r5, [r5, #34]
 2524              	.LVL261:
 2525              		.loc 1 929 0
 2526 12d4 000051E3 		str	r7, [r6, #0]
 2527 12d8 00005013 		.loc 1 930 0
 2528              		str	r8, [r6, #48]
 2529 12dc F0412DE9 		.loc 1 931 0
 2530              		strh	r5, [r6, #52]	@ movhi
 2531              		b	.L330
 2532 12e0 0150A0E1 	.LVL262:
 2533 12e4 0070A0E1 	.L326:
 2534 12e8 1500000A 		.loc 1 933 0
 2535              		mov	r6, #0
 2536 12ec 2030D1E5 	.LVL263:
 2537 12f0 108013E2 	.L330:
 2538              		.loc 1 934 0
 2539 12f4 3800A0E3 		mov	r0, r6
 2540              		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2541 12f8 1100001A 		bx	lr
 2542              	.LFE15:
 2544 12fc FEFFFFEB 		.align	2
 2545              		.global	open_file_in_dir
 2547 1300 000050E3 	open_file_in_dir:
 2548              	.LFB33:
 2549 1304 0060A0E1 		.loc 1 1936 0
 2550              		@ Function supports interworking.
 2551              		@ args = 0, pretend = 0, frame = 44
 2552 1308 044080E2 		@ frame_needed = 0, uses_anonymous_args = 0
 2553              	.LVL264:
 2554 130c 0C00000A 		stmfd	sp!, {r4, r5, lr}
 2555              	.LCFI28:
 2556              		sub	sp, sp, #44
 2557 1310 05C0A0E1 	.LCFI29:
 2558 1314 0F00BCE8 		.loc 1 1938 0
 2559              		mov	r3, sp
 2560 1318 04E0A0E1 		.loc 1 1936 0
 2561 131c 0F00AEE8 		mov	r4, r0
 2562 1320 0F00BCE8 		.loc 1 1938 0
 2563 1324 0F00AEE8 		bl	find_file_in_dir
 2564 1328 07009CE8 	.LVL265:
 2565 132c 07008EE8 		cmp	r0, #0
 2566              		mov	r3, r0
 2567 1330 B252D5E1 		mov	r5, sp
 2568              		.loc 1 1941 0
 2569              		mov	r0, r4
 2570 1334 007086E5 		mov	r1, sp
 2571              		.loc 1 1938 0
 2572 1338 308086E5 		beq	.L335
 2573              	.LVL266:
 2574 133c B453C6E1 		.loc 1 1941 0
 2575 1340 000000EA 		bl	fat16_open_file
 2576              	.LVL267:
 2577              		mov	r3, r0
 2578              	.LVL268:
 2579 1344 0060A0E3 	.L335:
 2580              		.loc 1 1942 0
 2581              		mov	r0, r3
 2582              		add	sp, sp, #44
 2583 1348 0600A0E1 		ldmfd	sp!, {r4, r5, lr}
 2584 134c F041BDE8 		bx	lr
 2585 1350 1EFF2FE1 	.LFE33:
 2587              		.align	2
 2588              		.global	fat16_get_dir_entry_of_path
 2590              	fat16_get_dir_entry_of_path:
 2591              	.LFB10:
 2592              		.loc 1 624 0
 2593              		@ Function supports interworking.
 2594              		@ args = 0, pretend = 0, frame = 0
 2595              		@ frame_needed = 0, uses_anonymous_args = 0
 2596              	.LVL269:
 2597              		.loc 1 625 0
 2598 1354 30402DE9 		cmp	r1, #0
 2599              		cmpne	r0, #0
 2600 1358 2CD04DE2 		.loc 1 624 0
 2601              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2602              	.LCFI30:
 2603 135c 0D30A0E1 		.loc 1 625 0
 2604              		mov	r9, r0
 2605 1360 0040A0E1 		mov	r4, r1
 2606              		.loc 1 624 0
 2607 1364 FEFFFFEB 		mov	r5, r2
 2608              		.loc 1 625 0
 2609 1368 000050E3 		beq	.L338
 2610 136c 0030A0E1 	.LVL270:
 2611 1370 0D50A0E1 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 2612              		cmp	r2, #0
 2613 1374 0400A0E1 		cmpne	r3, #0
 2614 1378 0D10A0E1 		movne	r1, #0
 2615              		moveq	r1, #1
 2616 137c 0100000A 		beq	.L338
 2617              	.LVL271:
 2618              		.loc 1 628 0
 2619 1380 FEFFFFEB 		cmp	r3, #47
 2620              		.loc 1 632 0
 2621 1384 0030A0E1 		mov	r0, r2
 2622              		mov	r2, #44
 2623              	.LVL272:
 2624              		.loc 1 629 0
 2625 1388 0300A0E1 		addeq	r4, r4, #1
 2626 138c 2CD08DE2 		.loc 1 632 0
 2627 1390 3040BDE8 		bl	memset
 2628 1394 1EFF2FE1 	.LVL273:
 2629              		.loc 1 633 0
 2630              		mov	r3, #16
 2631              		strb	r3, [r5, #32]
 2632              		.loc 1 635 0
 2633              		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 2634              		cmp	r3, #0
 2635              		beq	.L343
 2636              	.LVL274:
 2637              	.L361:
 2638              	.LBB64:
 2639              		.loc 1 640 0
 2640              		mov	r0, r9
 2641              		mov	r1, r5
 2642 1398 000051E3 		bl	fat16_open_dir
 2643 139c 00005013 		.loc 1 641 0
 2644              		subs	r7, r0, #0
 2645 13a0 F0472DE9 		beq	.L338
 2646              		.loc 1 645 0
 2647              		mov	r0, r4
 2648 13a4 0090A0E1 		mov	r1, #47
 2649 13a8 0140A0E1 		bl	strchr
 2650              		.loc 1 646 0
 2651 13ac 0250A0E1 		subs	r8, r0, #0
 2652              		bne	.L346
 2653 13b0 3C00000A 		.loc 1 647 0
 2654              		mov	r0, r4
 2655 13b4 0030D1E5 		bl	strlen
 2656 13b8 000052E3 		add	r8, r4, r0
 2657 13bc 00005313 	.L346:
 2658 13c0 0010A013 		.loc 1 648 0
 2659 13c4 0110A003 		rsb	r3, r4, r8
 2660 13c8 3600000A 		and	r6, r3, #255
 2661              		b	.L363
 2662              	.L349:
 2663 13cc 2F0053E3 		.loc 1 654 0
 2664              		bl	strlen
 2665 13d0 0200A0E1 		cmp	r0, r6
 2666 13d4 2C20A0E3 		mov	r1, r5
 2667              		mov	r2, r6
 2668              		mov	r0, r4
 2669 13d8 01408402 		bne	.L363
 2670              	.LVL275:
 2671 13dc FEFFFFEB 		bl	strncmp
 2672              	.LVL276:
 2673              		subs	sl, r0, #0
 2674 13e0 1030A0E3 		bne	.L363
 2675 13e4 2030C5E5 		.loc 1 658 0
 2676              		mov	r0, r7
 2677 13e8 0030D4E5 		bl	fat16_close_dir
 2678 13ec 000053E3 		.loc 1 661 0
 2679 13f0 2E00000A 		ldrb	r3, [r4, r6]	@ zero_extendqisi2
 2680              		cmp	r3, #0
 2681              		beq	.L343
 2682              		.loc 1 665 0
 2683              		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 2684 13f4 0900A0E1 		tst	r3, #16
 2685 13f8 0510A0E1 		beq	.L338
 2686 13fc FEFFFFEB 		.loc 1 668 0
 2687              		add	r4, r8, #1
 2688 1400 007050E2 		mov	r7, sl
 2689 1404 2700000A 		b	.L354
 2690              	.LVL277:
 2691 1408 0400A0E1 	.L363:
 2692 140c 2F10A0E3 		.loc 1 651 0
 2693 1410 FEFFFFEB 		mov	r1, r5
 2694              		mov	r0, r7
 2695 1414 008050E2 		bl	fat16_read_dir
 2696 1418 0200001A 		cmp	r0, #0
 2697              		.loc 1 654 0
 2698 141c 0400A0E1 		mov	r0, r5
 2699 1420 FEFFFFEB 		.loc 1 651 0
 2700 1424 008084E0 		bne	.L349
 2701              	.L354:
 2702              		.loc 1 676 0
 2703 1428 083064E0 		mov	r0, r7
 2704 142c FF6003E2 		bl	fat16_close_dir
 2705 1430 130000EA 		b	.L361
 2706              	.LVL278:
 2707              	.L338:
 2708 1434 FEFFFFEB 		.loc 1 677 0
 2709 1438 060050E1 		mov	r0, #0
 2710 143c 0510A0E1 		b	.L355
 2711 1440 0620A0E1 	.LVL279:
 2712 1444 0400A0E1 	.L343:
 2713 1448 0D00001A 		mov	r0, #1
 2714              	.LVL280:
 2715 144c FEFFFFEB 	.L355:
 2716              	.LBE64:
 2717 1450 00A050E2 		.loc 1 680 0
 2718 1454 0A00001A 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 2719              		bx	lr
 2720 1458 0700A0E1 	.LFE10:
 2722              		.section	.rodata.str1.4,"aMS",%progbits,1
 2723 1460 0630D4E7 		.align	2
 2724 1464 000053E3 	.LC0:
 2725 1468 1000000A 		.ascii	"MALLOC FAILS\012\015\000"
 2726              		.align	2
 2727 146c 2030D5E5 	.LC1:
 2728 1470 100013E3 		.ascii	"Failed Reading Header\012\015\000"
 2729 1474 0B00000A 		.text
 2730              		.align	2
 2731 1478 014088E2 		.global	fat16_open
 2733 1480 050000EA 	fat16_open:
 2734              	.LFB2:
 2735              		.loc 1 203 0
 2736              		@ Function supports interworking.
 2737 1484 0510A0E1 		@ args = 0, pretend = 0, frame = 60
 2738 1488 0700A0E1 		@ frame_needed = 0, uses_anonymous_args = 0
 2739 148c FEFFFFEB 	.LVL281:
 2740 1490 000050E3 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2741              	.LCFI31:
 2742 1494 0500A0E1 		.loc 1 204 0
 2743              		subs	r8, r0, #0
 2744 1498 E5FFFF1A 		.loc 1 203 0
 2745              		sub	sp, sp, #60
 2746              	.LCFI32:
 2747 149c 0700A0E1 		.loc 1 204 0
 2748 14a0 FEFFFFEB 		beq	.L379
 2749 14a4 D2FFFFEA 	.LVL282:
 2750              		ldr	r3, [r8, #8]
 2751              		cmp	r3, #0
 2752              		beq	.L379
 2753 14a8 0000A0E3 		.loc 1 213 0
 2754 14ac 000000EA 		mov	r0, #28
 2755              		bl	malloc
 2756              		.loc 1 214 0
 2757 14b0 0100A0E3 		subs	fp, r0, #0
 2758              		bne	.L368
 2759              		.loc 1 216 0
 2760              		ldr	r0, .L380
 2761              		bl	rprintf
 2762 14b4 F047BDE8 		mov	sl, fp
 2763 14b8 1EFF2FE1 	.LVL283:
 2764              		b	.L370
 2765              	.LVL284:
 2766              	.L368:
 2767              		.loc 1 219 0
 2768              		mov	r1, #0
 2769 0000 4D414C4C 		mov	r2, #28
 2769      4F432046 
 2769      41494C53 
 2769      0A0D00
 2770 000f 00       		bl	memset
 2771              	.LBB67:
 2772 0010 4661696C 	.LBB68:
 2772      65642052 
 2772      65616469 
 2772      6E672048 
 2772      65616465 
 2773              		.loc 1 271 0
 2774              		ldr	r3, [r8, #16]
 2775              		mov	r3, r3, asl #9
 2776              		str	r3, [sp, #8]
 2777              	.LVL285:
 2778              	.LVL286:
 2779              	.LBE68:
 2780              	.LBE67:
 2781              		.loc 1 221 0
 2782              		str	r8, [fp, #0]
 2783              	.LBB69:
 2784 14bc F04F2DE9 		.loc 1 273 0
 2785              		add	r0, r3, #11
 2786              		add	r1, sp, #35
 2787 14c0 008050E2 		mov	r2, #25
 2788              		ldr	ip, [r8, #0]
 2789 14c4 3CD04DE2 		mov	lr, pc
 2790              		bx	ip
 2791              	.LBB70:
 2792 14c8 7100000A 		cmp	r0, #0
 2793              	.LVL287:
 2794 14cc 083098E5 	.LBE70:
 2795 14d0 000053E3 	.LBE69:
 2796 14d4 6E00000A 		.loc 1 213 0
 2797              		mov	sl, fp
 2798 14d8 1C00A0E3 	.LVL288:
 2799 14dc FEFFFFEB 	.LBB71:
 2800              	.LBB72:
 2801 14e0 00B050E2 		.loc 1 273 0
 2802 14e4 0300001A 		beq	.L371
 2803              		.loc 1 287 0
 2804 14e8 B8019FE5 		ldrb	r2, [sp, #46]	@ zero_extendqisi2
 2805 14ec FEFFFFEB 		ldrb	r3, [sp, #47]	@ zero_extendqisi2
 2806 14f0 0BA0A0E1 		.loc 1 293 0
 2807              		orrs	r3, r2, r3, asl #8
 2808 14f4 670000EA 		.loc 1 277 0
 2809              		ldrb	r0, [sp, #35]	@ zero_extendqisi2
 2810              		ldrb	r2, [sp, #36]	@ zero_extendqisi2
 2811              		.loc 1 293 0
 2812 14f8 0010A0E3 		str	r3, [sp, #16]
 2813 14fc 1C20A0E3 		.loc 1 280 0
 2814 1500 FEFFFFEB 		ldrb	r6, [sp, #38]	@ zero_extendqisi2
 2815              		.loc 1 278 0
 2816              		ldrb	r3, [sp, #37]	@ zero_extendqisi2
 2817              		.loc 1 277 0
 2818 1504 103098E5 		str	r0, [sp, #28]
 2819 1508 8334A0E1 		str	r2, [sp, #24]
 2820 150c 08308DE5 		.loc 1 278 0
 2821              		str	r3, [sp, #4]
 2822              	.LVL289:
 2823              		.loc 1 280 0
 2824              		str	r6, [sp, #20]
 2825              		ldrb	r1, [sp, #39]	@ zero_extendqisi2
 2826 1510 00808BE5 		.loc 1 281 0
 2827              		ldrb	r9, [sp, #40]	@ zero_extendqisi2
 2828              	.LVL290:
 2829 1514 0B0083E2 		.loc 1 283 0
 2830 1518 23108DE2 		ldrb	r7, [sp, #41]	@ zero_extendqisi2
 2831 151c 1920A0E3 		ldrb	r5, [sp, #42]	@ zero_extendqisi2
 2832 1520 00C098E5 		.loc 1 285 0
 2833 1524 0FE0A0E1 		ldrb	r4, [sp, #43]	@ zero_extendqisi2
 2834 1528 1CFF2FE1 		ldrb	lr, [sp, #44]	@ zero_extendqisi2
 2835              		.loc 1 291 0
 2836 152c 000050E3 		ldrb	ip, [sp, #56]	@ zero_extendqisi2
 2837              		ldrb	r2, [sp, #57]	@ zero_extendqisi2
 2838              		ldrb	r3, [sp, #58]	@ zero_extendqisi2
 2839              		ldrb	r0, [sp, #59]	@ zero_extendqisi2
 2840              		.loc 1 293 0
 2841 1530 0BA0A0E1 		beq	.L371
 2842              		.loc 1 291 0
 2843              		mov	r3, r3, asl #16
 2844              		orr	r2, ip, r2, asl #8
 2845              		orr	r3, r3, r0, asl #24
 2846 1534 5200000A 		.loc 1 297 0
 2847              		orrs	r6, r2, r3
 2848 1538 2E20DDE5 	.LVL291:
 2849 153c 2F30DDE5 		bne	.L374
 2850              		.loc 1 299 0
 2851 1540 033492E1 		orrs	r2, r4, lr, asl #8
 2852              		beq	.L371
 2853 1544 2300DDE5 		.loc 1 303 0
 2854 1548 2420DDE5 		mov	r6, r2
 2855              	.L374:
 2856 154c 10308DE5 		.loc 1 310 0
 2857              		ldr	r0, [sp, #16]
 2858 1550 2660DDE5 		mul	r0, r9, r0
 2859              		.loc 1 277 0
 2860 1554 2530DDE5 		ldr	r2, [sp, #28]
 2861              		.loc 1 310 0
 2862 1558 1C008DE5 		str	r0, [sp, #12]
 2863 155c 18208DE5 		.loc 1 277 0
 2864              		ldr	r0, [sp, #24]
 2865 1560 04308DE5 		.loc 1 283 0
 2866              		orr	r3, r7, r5, asl #8
 2867              	.LVL292:
 2868 1564 14608DE5 		.loc 1 277 0
 2869 1568 2710DDE5 		orr	r5, r2, r0, asl #8
 2870              	.LVL293:
 2871 156c 2890DDE5 		.loc 1 310 0
 2872              		ldr	r2, [sp, #20]
 2873              		.loc 1 311 0
 2874 1570 2970DDE5 		mov	r3, r3, asl #5
 2875 1574 2A50DDE5 	.LVL294:
 2876              		.loc 1 310 0
 2877 1578 2B40DDE5 		orr	r9, r2, r1, asl #8
 2878 157c 2CE0DDE5 	.LVL295:
 2879              		.loc 1 311 0
 2880 1580 38C0DDE5 		str	r3, [sp, #0]
 2881 1584 3920DDE5 		add	r0, r3, r5
 2882 1588 3A30DDE5 		ldr	r3, [sp, #12]
 2883 158c 3B00DDE5 		mov	r1, r5
 2884              		sub	r0, r0, #1
 2885 1590 3B00000A 		rsb	r4, r9, r6
 2886              		rsb	r4, r3, r4
 2887 1594 0338A0E1 		bl	__divsi3
 2888 1598 02248CE1 		ldr	r1, [sp, #4]
 2889 159c 003C83E1 		rsb	r0, r0, r4
 2890              		bl	__udivsi3
 2891 15a0 036092E1 		.loc 1 312 0
 2892              		sub	r3, r0, #4080
 2893 15a4 0200001A 		sub	r3, r3, #5
 2894              		cmp	r3, #61440
 2895 15a8 0E2494E1 		.loc 1 311 0
 2896 15ac 3400000A 		mov	r7, r0
 2897              		.loc 1 312 0
 2898 15b0 0260A0E1 		bcs	.L371
 2899              		.loc 1 319 0
 2900              		add	r4, sl, #4
 2901 15b4 10009DE5 	.LVL296:
 2902 15b8 990000E0 		.loc 1 316 0
 2903              		mov	r3, #6
 2904 15bc 1C209DE5 		strb	r3, [r8, #12]
 2905              		.loc 1 320 0
 2906 15c0 0C008DE5 		mov	r1, #0
 2907              		mov	r2, #24
 2908 15c4 18009DE5 		mov	r0, r4
 2909              		bl	memset
 2910 15c8 053487E1 		.loc 1 324 0
 2911              		ldr	ip, [sp, #8]
 2912              		mla	ip, r5, r9, ip
 2913 15cc 005482E1 		.loc 1 333 0
 2914              		ldr	lr, [sp, #12]
 2915              		.loc 1 331 0
 2916 15d0 14209DE5 		ldr	r0, [sp, #4]
 2917              		.loc 1 333 0
 2918 15d4 8332A0E1 		mla	lr, r5, lr, ip
 2919              		.loc 1 322 0
 2920              		mul	r1, r5, r6
 2921 15d8 019482E1 		.loc 1 331 0
 2922              		mul	r0, r5, r0
 2923              		.loc 1 338 0
 2924 15dc 00308DE5 		ldr	r6, [sp, #0]
 2925 15e0 050083E0 	.LVL297:
 2926 15e4 0C309DE5 		.loc 1 328 0
 2927 15e8 0510A0E1 		mov	r3, r7, asl #1
 2928 15ec 010040E2 		.loc 1 338 0
 2929 15f0 064069E0 		add	r2, lr, r6
 2930 15f4 044063E0 		.loc 1 328 0
 2931 15f8 FEFFFFEB 		add	r3, r3, #4
 2932 15fc 04109DE5 		.loc 1 338 0
 2933 1600 040060E0 		str	r2, [r4, #20]
 2934 1604 FEFFFFEB 		.loc 1 322 0
 2935              		str	r1, [sl, #4]
 2936 1608 FF3E40E2 		.loc 1 328 0
 2937 160c 053043E2 		str	r3, [r4, #8]
 2938 1610 0F0A53E3 		.loc 1 331 0
 2939              		strh	r0, [r4, #14]	@ movhi
 2940 1614 0070A0E1 		.loc 1 324 0
 2941              		str	ip, [r4, #4]
 2942 1618 1900002A 		.loc 1 330 0
 2943              		strh	r5, [r4, #12]	@ movhi
 2944 161c 04408AE2 		.loc 1 333 0
 2945              		str	lr, [r4, #16]
 2946              		b	.L370
 2947 1620 0630A0E3 	.LVL298:
 2948 1624 0C30C8E5 	.L371:
 2949              	.LBE72:
 2950 1628 0010A0E3 	.LBE71:
 2951 162c 1820A0E3 		.loc 1 224 0
 2952 1630 0400A0E1 		ldr	r0, .L380+4
 2953 1634 FEFFFFEB 		bl	rprintf
 2954              		.loc 1 225 0
 2955 1638 08C09DE5 		mov	r0, fp
 2956 163c 95C92CE0 		bl	free
 2957              	.LVL299:
 2958 1640 0CE09DE5 	.L379:
 2959              		mov	sl, #0
 2960 1644 04009DE5 	.LVL300:
 2961              	.L370:
 2962 1648 95CE2EE0 		.loc 1 230 0
 2963              		mov	r0, sl
 2964 164c 950601E0 		add	sp, sp, #60
 2965              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2966 1650 950000E0 		bx	lr
 2967              	.L381:
 2968 1654 00609DE5 		.align	2
 2969              	.L380:
 2970              		.word	.LC0
 2971 1658 8730A0E1 		.word	.LC1
 2972              	.LFE2:
 2974              		.align	2
 2975 1660 043083E2 		.global	fat16_create_file
 2977 1664 142084E5 	fat16_create_file:
 2978              	.LFB27:
 2979 1668 04108AE5 		.loc 1 1670 0
 2980              		@ Function supports interworking.
 2981 166c 083084E5 		@ args = 0, pretend = 0, frame = 4
 2982              		@ frame_needed = 0, uses_anonymous_args = 0
 2983 1670 BE00C4E1 	.LVL301:
 2984              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2985 1674 04C084E5 	.LCFI33:
 2986              		.loc 1 1672 0
 2987 1678 BC50C4E1 		rsbs	r6, r0, #1
 2988              		movcc	r6, #0
 2989 167c 10E084E5 		cmp	r0, #0
 2990 1680 040000EA 		cmpne	r1, #0
 2991              		.loc 1 1670 0
 2992              		sub	sp, sp, #4
 2993              	.LCFI34:
 2994              		.loc 1 1672 0
 2995              		mov	r5, r0
 2996 1684 20009FE5 		mov	r4, r1
 2997 1688 FEFFFFEB 		.loc 1 1670 0
 2998              		mov	r8, r2
 2999 168c 0B00A0E1 		.loc 1 1672 0
 3000 1690 FEFFFFEB 		beq	.L383
 3001              	.LVL302:
 3002              		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 3003 1694 00A0A0E3 		cmp	r3, #0
 3004              		beq	.L383
 3005              	.L413:
 3006              		.loc 1 1678 0
 3007 1698 0A00A0E1 		mov	r1, r8
 3008 169c 3CD08DE2 		mov	r0, r5
 3009 16a0 F04FBDE8 		bl	fat16_read_dir
 3010 16a4 1EFF2FE1 		subs	sl, r0, #0
 3011              		.loc 1 1681 0
 3012              		mov	r1, r8
 3013              		mov	r0, r4
 3014 16a8 00000000 		.loc 1 1678 0
 3015 16ac 10000000 		beq	.L386
 3016              	.LVL303:
 3017              		.loc 1 1681 0
 3018              		bl	strcmp
 3019              	.LVL304:
 3020              		cmp	r0, #0
 3021              		bne	.L413
 3022              	.LBB77:
 3023              	.LBB78:
 3024              		.loc 1 1432 0
 3025              		cmp	r6, #0
 3026              		addne	r0, r0, #1
 3027              		.loc 1 1435 0
 3028 16b0 F04F2DE9 		moveq	r0, #1
 3029              		streqh	r6, [r5, #48]	@ movhi
 3030              		b	.L391
 3031 16b4 016070E2 	.LVL305:
 3032 16b8 0060A033 	.L386:
 3033 16bc 000050E3 	.LBE78:
 3034 16c0 00005113 	.LBE77:
 3035              		.loc 1 1688 0
 3036 16c4 04D04DE2 		mov	r1, sl
 3037              	.LVL306:
 3038              		mov	r2, #44
 3039 16c8 0050A0E1 		mov	r0, r8
 3040 16cc 0140A0E1 	.LVL307:
 3041              		bl	memset
 3042 16d0 0280A0E1 		.loc 1 1689 0
 3043              		mov	r1, r4
 3044 16d4 6500000A 		mov	r2, #31
 3045              		mov	r0, r8
 3046 16d8 0030D1E5 		bl	strncpy
 3047 16dc 000053E3 		.loc 1 1692 0
 3048 16e0 6200000A 		mov	r0, r4
 3049              		bl	strlen
 3050              		mov	r1, #13
 3051 16e4 0810A0E1 		bl	__udivsi3
 3052 16e8 0500A0E1 		.loc 1 1695 0
 3053 16ec FEFFFFEB 		ldrh	r7, [r5, #38]
 3054 16f0 00A050E2 	.LVL308:
 3055              		.loc 1 1694 0
 3056 16f4 0810A0E1 		ldr	r5, [r5, #0]
 3057 16f8 0400A0E1 	.LVL309:
 3058              		.loc 1 1700 0
 3059 16fc 0700000A 		cmp	r7, #0
 3060              		.loc 1 1703 0
 3061              		ldreq	r4, [r5, #20]
 3062 1700 FEFFFFEB 	.LVL310:
 3063              		.loc 1 1700 0
 3064 1704 000050E3 		movne	r6, sl
 3065 1708 F5FFFF1A 	.LVL311:
 3066              		.loc 1 1692 0
 3067              		add	r0, r0, #2
 3068              		.loc 1 1704 0
 3069 170c 000056E3 		ldreq	sl, [r5, #24]
 3070 1710 01008012 	.LVL312:
 3071              		.loc 1 1692 0
 3072 1714 0100A003 		and	fp, r0, #255
 3073 1718 B063C501 	.LVL313:
 3074 171c 540000EA 		.loc 1 1700 0
 3075              		movne	r4, r6
 3076              		movne	sl, r6
 3077              		.loc 1 1704 0
 3078              		moveq	r6, r4
 3079              		mov	r9, #0
 3080 1720 0A10A0E1 	.LVL314:
 3081              	.LVL315:
 3082 1724 2C20A0E3 	.L418:
 3083 1728 0800A0E1 	.LBB79:
 3084              		.loc 1 1710 0
 3085 172c FEFFFFEB 		cmp	r4, sl
 3086              		bne	.L396
 3087 1730 0410A0E1 		.loc 1 1712 0
 3088 1734 1F20A0E3 		cmp	r7, #0
 3089 1738 0800A0E1 		beq	.L383
 3090 173c FEFFFFEB 		.loc 1 1718 0
 3091              		cmp	r4, #0
 3092 1740 0400A0E1 		beq	.L399
 3093 1744 FEFFFFEB 	.LBB80:
 3094 1748 0D10A0E3 		.loc 1 1724 0
 3095 174c FEFFFFEB 		mov	r0, r5
 3096              		mov	r1, r7
 3097 1750 B672D5E1 		bl	fat16_get_next_cluster
 3098              		.loc 1 1725 0
 3099              		cmp	r0, #0
 3100 1754 005095E5 	.LVL316:
 3101              		bne	.L401
 3102              		.loc 1 1727 0
 3103 1758 000057E3 		mov	r1, r7
 3104              		mov	r0, r5
 3105 175c 14409505 	.LVL317:
 3106              		mov	r2, #1
 3107              		bl	fat16_append_clusters
 3108 1760 0A60A011 		.loc 1 1728 0
 3109              		cmp	r0, #0
 3110              		beq	.L383
 3111 1764 020080E2 		.loc 1 1732 0
 3112              		ldrh	r1, [r5, #18]
 3113 1768 18A09505 		ldr	r2, [r5, #24]
 3114              		sub	r3, r0, #2
 3115              		mla	r6, r1, r3, r2
 3116 176c FFB000E2 		b	.L404
 3117              	.LVL318:
 3118              	.L401:
 3119 1770 0640A011 		.loc 1 1738 0
 3120 1774 06A0A011 		mov	r7, r0
 3121              	.L399:
 3122 1778 0460A001 	.LBE80:
 3123 177c 0090A0E3 		.loc 1 1743 0
 3124              		ldrh	r1, [r5, #18]
 3125              		ldr	r2, [r5, #24]
 3126              		sub	r3, r7, #2
 3127              		mla	r4, r1, r3, r2
 3128              		.loc 1 1745 0
 3129 1780 0A0054E1 		mov	r9, #0
 3130 1784 1B00001A 		add	sl, r4, r1
 3131              		mov	r6, r4
 3132 1788 000057E3 	.L396:
 3133 178c 3700000A 		.loc 1 1752 0
 3134              		ldr	r3, [r5, #0]
 3135 1790 000054E3 		mov	r0, r4
 3136 1794 1000000A 	.LVL319:
 3137              		add	r1, sp, #3
 3138              		mov	r2, #1
 3139 1798 0500A0E1 		ldr	ip, [r3, #0]
 3140 179c 0710A0E1 		mov	lr, pc
 3141 17a0 9EFAFFEB 		bx	ip
 3142              		cmp	r0, #0
 3143 17a4 000050E3 		beq	.L383
 3144              		.loc 1 1756 0
 3145 17a8 0A00001A 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 3146              		cmp	r3, #0
 3147 17ac 0710A0E1 		cmpne	r3, #229
 3148 17b0 0500A0E1 		movne	r3, #0
 3149              		moveq	r3, #1
 3150 17b4 0120A0E3 		.loc 1 1767 0
 3151 17b8 F8FAFFEB 		addne	r6, r4, #32
 3152              		movne	r9, r3
 3153 17bc 000050E3 		movne	r4, r6
 3154 17c0 2A00000A 		.loc 1 1756 0
 3155              		bne	.L418
 3156 17c4 B211D5E1 		.loc 1 1759 0
 3157 17c8 182095E5 		add	r3, r9, #1
 3158 17cc 023040E2 		and	r9, r3, #255
 3159 17d0 912326E0 		.loc 1 1760 0
 3160 17d4 1E0000EA 		cmp	r9, fp
 3161              		.loc 1 1763 0
 3162              		addcc	r4, r4, #32
 3163              		bcc	.L418
 3164 17d8 0070A0E1 	.L404:
 3165              	.LBE79:
 3166              		.loc 1 1774 0
 3167              		str	r6, [r8, #40]
 3168 17dc B211D5E1 		.loc 1 1775 0
 3169 17e0 182095E5 		mov	r0, r5
 3170 17e4 023047E2 		mov	r1, r8
 3171 17e8 912324E0 		bl	fat16_write_dir_entry
 3172              		subs	r0, r0, #0
 3173 17ec 0090A0E3 		movne	r0, #1
 3174 17f0 01A084E0 		b	.L391
 3175 17f4 0460A0E1 	.LVL320:
 3176              	.L383:
 3177              		mov	r0, #0
 3178 17f8 003095E5 	.L391:
 3179 17fc 0400A0E1 		.loc 1 1783 0
 3180              		add	sp, sp, #4
 3181 1800 03108DE2 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3182 1804 0120A0E3 		bx	lr
 3183 1808 00C093E5 	.LFE27:
 3185 1810 1CFF2FE1 		.section	.debug_frame,"",%progbits
 3186 1814 000050E3 	.Lframe0:
 3187 1818 1400000A 		.4byte	.LECIE0-.LSCIE0
 3188              	.LSCIE0:
 3189 181c 0330DDE5 		.4byte	0xffffffff
 3190 1820 000053E3 		.byte	0x1
 3191 1824 E5005313 		.ascii	"\000"
 3192 1828 0030A013 		.uleb128 0x1
 3193 182c 0130A003 		.sleb128 -4
 3194              		.byte	0xe
 3195 1830 20608412 		.byte	0xc
 3196 1834 0390A011 		.uleb128 0xd
 3197 1838 0640A011 		.uleb128 0x0
 3198              		.align	2
 3199 183c CFFFFF1A 	.LECIE0:
 3200              	.LSFDE0:
 3201 1840 013089E2 		.4byte	.LEFDE0-.LASFDE0
 3202 1844 FF9003E2 	.LASFDE0:
 3203              		.4byte	.Lframe0
 3204 1848 0B0059E1 		.4byte	.LFB7
 3205              		.4byte	.LFE7-.LFB7
 3206 184c 20408432 		.align	2
 3207 1850 CAFFFF3A 	.LEFDE0:
 3208              	.LSFDE2:
 3209              		.4byte	.LEFDE2-.LASFDE2
 3210              	.LASFDE2:
 3211 1854 286088E5 		.4byte	.Lframe0
 3212              		.4byte	.LFB8
 3213 1858 0500A0E1 		.4byte	.LFE8-.LFB8
 3214 185c 0810A0E1 		.byte	0x4
 3215 1860 B4FCFFEB 		.4byte	.LCFI0-.LFB8
 3216 1864 000050E2 		.byte	0xe
 3217 1868 0100A013 		.uleb128 0xc
 3218 186c 000000EA 		.byte	0x8e
 3219              		.uleb128 0x1
 3220              		.byte	0x85
 3221 1870 0000A0E3 		.uleb128 0x2
 3222              		.byte	0x84
 3223              		.uleb128 0x3
 3224 1874 04D08DE2 		.align	2
 3225 1878 F04FBDE8 	.LEFDE2:
 3226 187c 1EFF2FE1 	.LSFDE4:
 3227              		.4byte	.LEFDE4-.LASFDE4
 3228              	.LASFDE4:
 3862              		.4byte	0x0
DEFINED SYMBOLS
                            *ABS*:00000000 fat16.c
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:12     .text:00000000 fat16_dir_entry_seek_callback
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:22     .text:00000000 $a
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:76     .text:00000070 fat16_dir_entry_read_callback
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:270    .text:00000220 fat16_get_next_cluster
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:344    .text:000002c4 $d
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:349    .text:000002c8 fat16_free_clusters
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:356    .text:000002c8 $a
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:458    .text:0000039c $d
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:463    .text:000003a0 fat16_append_clusters
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:470    .text:000003a0 $a
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:638    .text:00000510 fat16_read_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:852    .text:000006ac fat16_reset_dir
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:879    .text:000006c8 fat16_set_dir
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:912    .text:000006e8 fat16_delete_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:989    .text:00000794 fat16_get_fs_size
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1020   .text:000007b8 fat16_get_fs_free
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1107   .text:00000860 $d
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1114   .text:0000086c fat16_get_fs_free_callback
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1121   .text:0000086c $a
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1165   .text:000008bc fat16_file_size
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1185   .text:000008c4 fat16_read_dir
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1419   .text:00000ad4 $d
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1426   .text:00000adc find_file_in_dir
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1433   .text:00000adc $a
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1481   .text:00000b38 fat16_write_dir_entry
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1786   .text:00000dc4 fat16_resize_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:1998   .text:00000f68 fat16_seek_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2087   .text:00001000 fat16_write_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2369   .text:00001218 fat16_close_dir
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2395   .text:0000122c fat16_close_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2421   .text:00001240 fat16_close
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2447   .text:00001254 fat16_open_dir
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2518   .text:000012d4 fat16_open_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2591   .text:00001354 open_file_in_dir
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2634   .text:00001398 fat16_get_dir_entry_of_path
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:2777   .text:000014bc fat16_open
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:3014   .text:000016a8 $d
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:3021   .text:000016b0 fat16_create_file
C:\Users\nancyhd\AppData\Local\Temp/ccYTaaaa.s:3028   .text:000016b0 $a

UNDEFINED SYMBOLS
__umodsi3
memset
strcmp
__divsi3
strlen
strrchr
memcpy
__udivsi3
free
malloc
strchr
strncmp
rprintf
strncpy
