   1              		.file	"sd_raw.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	sd_raw_available
  13              	sd_raw_available:
  14              	.LFB3:
  15              		.file 1 "../lib/sd_raw.c"
   1:../lib/sd_raw.c **** 
   2:../lib/sd_raw.c **** /* This program is free software; you can redistribute it and/or modify
   3:../lib/sd_raw.c ****  * it under the terms of the GNU General Public License version 2 as
   4:../lib/sd_raw.c ****  * published by the Free Software Foundation.
   5:../lib/sd_raw.c ****  */
   6:../lib/sd_raw.c **** 
   7:../lib/sd_raw.c **** #include <string.h>
   8:../lib/sd_raw.c **** #include "sd_raw.h"
   9:../lib/sd_raw.c **** #include "LPC214x.h"
  10:../lib/sd_raw.c **** #include <stdio.h>
  11:../lib/sd_raw.c **** #include "rprintf.h"
  12:../lib/sd_raw.c **** 
  13:../lib/sd_raw.c **** /**
  14:../lib/sd_raw.c ****  * \addtogroup sd_raw MMC/SD card raw access
  15:../lib/sd_raw.c ****  *
  16:../lib/sd_raw.c ****  * This module implements read and write access to MMC and
  17:../lib/sd_raw.c ****  * SD cards. It serves as a low-level driver for the higher
  18:../lib/sd_raw.c ****  * level modules such as partition and file system access.
  19:../lib/sd_raw.c ****  *
  20:../lib/sd_raw.c ****  * @{
  21:../lib/sd_raw.c ****  */
  22:../lib/sd_raw.c **** /**
  23:../lib/sd_raw.c ****  * \file
  24:../lib/sd_raw.c ****  * MMC/SD raw access implementation.
  25:../lib/sd_raw.c ****  *
  26:../lib/sd_raw.c ****  * \author Roland Riegel
  27:../lib/sd_raw.c ****  */
  28:../lib/sd_raw.c **** 
  29:../lib/sd_raw.c **** /**
  30:../lib/sd_raw.c ****  * \addtogroup sd_raw_config MMC/SD configuration
  31:../lib/sd_raw.c ****  * Preprocessor defines to configure the MMC/SD support.
  32:../lib/sd_raw.c ****  */
  33:../lib/sd_raw.c **** 
  34:../lib/sd_raw.c **** /**
  35:../lib/sd_raw.c ****  * @}
  36:../lib/sd_raw.c ****  */
  37:../lib/sd_raw.c **** 
  38:../lib/sd_raw.c **** /* commands available in SPI mode */
  39:../lib/sd_raw.c **** 
  40:../lib/sd_raw.c **** /* CMD0: response R1 */
  41:../lib/sd_raw.c **** #define CMD_GO_IDLE_STATE 0x00
  42:../lib/sd_raw.c **** /* CMD1: response R1 */
  43:../lib/sd_raw.c **** #define CMD_SEND_OP_COND 0x01
  44:../lib/sd_raw.c **** /* CMD9: response R1 */
  45:../lib/sd_raw.c **** #define CMD_SEND_CSD 0x09
  46:../lib/sd_raw.c **** /* CMD10: response R1 */
  47:../lib/sd_raw.c **** #define CMD_SEND_CID 0x0a
  48:../lib/sd_raw.c **** /* CMD12: response R1 */
  49:../lib/sd_raw.c **** #define CMD_STOP_TRANSMISSION 0x0c
  50:../lib/sd_raw.c **** /* CMD13: response R2 */
  51:../lib/sd_raw.c **** #define CMD_SEND_STATUS 0x0d
  52:../lib/sd_raw.c **** /* CMD16: arg0[31:0]: block length, response R1 */
  53:../lib/sd_raw.c **** #define CMD_SET_BLOCKLEN 0x10
  54:../lib/sd_raw.c **** /* CMD17: arg0[31:0]: data address, response R1 */
  55:../lib/sd_raw.c **** #define CMD_READ_SINGLE_BLOCK 0x11
  56:../lib/sd_raw.c **** /* CMD18: arg0[31:0]: data address, response R1 */
  57:../lib/sd_raw.c **** #define CMD_READ_MULTIPLE_BLOCK 0x12
  58:../lib/sd_raw.c **** /* CMD24: arg0[31:0]: data address, response R1 */
  59:../lib/sd_raw.c **** #define CMD_WRITE_SINGLE_BLOCK 0x18
  60:../lib/sd_raw.c **** /* CMD25: arg0[31:0]: data address, response R1 */
  61:../lib/sd_raw.c **** #define CMD_WRITE_MULTIPLE_BLOCK 0x19
  62:../lib/sd_raw.c **** /* CMD27: response R1 */
  63:../lib/sd_raw.c **** #define CMD_PROGRAM_CSD 0x1b
  64:../lib/sd_raw.c **** /* CMD28: arg0[31:0]: data address, response R1b */
  65:../lib/sd_raw.c **** #define CMD_SET_WRITE_PROT 0x1c
  66:../lib/sd_raw.c **** /* CMD29: arg0[31:0]: data address, response R1b */
  67:../lib/sd_raw.c **** #define CMD_CLR_WRITE_PROT 0x1d
  68:../lib/sd_raw.c **** /* CMD30: arg0[31:0]: write protect data address, response R1 */
  69:../lib/sd_raw.c **** #define CMD_SEND_WRITE_PROT 0x1e
  70:../lib/sd_raw.c **** /* CMD32: arg0[31:0]: data address, response R1 */
  71:../lib/sd_raw.c **** #define CMD_TAG_SECTOR_START 0x20
  72:../lib/sd_raw.c **** /* CMD33: arg0[31:0]: data address, response R1 */
  73:../lib/sd_raw.c **** #define CMD_TAG_SECTOR_END 0x21
  74:../lib/sd_raw.c **** /* CMD34: arg0[31:0]: data address, response R1 */
  75:../lib/sd_raw.c **** #define CMD_UNTAG_SECTOR 0x22
  76:../lib/sd_raw.c **** /* CMD35: arg0[31:0]: data address, response R1 */
  77:../lib/sd_raw.c **** #define CMD_TAG_ERASE_GROUP_START 0x23
  78:../lib/sd_raw.c **** /* CMD36: arg0[31:0]: data address, response R1 */
  79:../lib/sd_raw.c **** #define CMD_TAG_ERASE_GROUP_END 0x24
  80:../lib/sd_raw.c **** /* CMD37: arg0[31:0]: data address, response R1 */
  81:../lib/sd_raw.c **** #define CMD_UNTAG_ERASE_GROUP 0x25
  82:../lib/sd_raw.c **** /* CMD38: arg0[31:0]: stuff bits, response R1b */
  83:../lib/sd_raw.c **** #define CMD_ERASE 0x26
  84:../lib/sd_raw.c **** /* CMD42: arg0[31:0]: stuff bits, response R1b */
  85:../lib/sd_raw.c **** #define CMD_LOCK_UNLOCK 0x2a
  86:../lib/sd_raw.c **** /* CMD58: response R3 */
  87:../lib/sd_raw.c **** #define CMD_READ_OCR 0x3a
  88:../lib/sd_raw.c **** /* CMD59: arg0[31:1]: stuff bits, arg0[0:0]: crc option, response R1 */
  89:../lib/sd_raw.c **** #define CMD_CRC_ON_OFF 0x3b
  90:../lib/sd_raw.c **** 
  91:../lib/sd_raw.c **** /* command responses */
  92:../lib/sd_raw.c **** /* R1: size 1 byte */
  93:../lib/sd_raw.c **** #define R1_IDLE_STATE 0
  94:../lib/sd_raw.c **** #define R1_ERASE_RESET 1
  95:../lib/sd_raw.c **** #define R1_ILL_COMMAND 2
  96:../lib/sd_raw.c **** #define R1_COM_CRC_ERR 3
  97:../lib/sd_raw.c **** #define R1_ERASE_SEQ_ERR 4
  98:../lib/sd_raw.c **** #define R1_ADDR_ERR 5
  99:../lib/sd_raw.c **** #define R1_PARAM_ERR 6
 100:../lib/sd_raw.c **** /* R1b: equals R1, additional busy bytes */
 101:../lib/sd_raw.c **** /* R2: size 2 bytes */
 102:../lib/sd_raw.c **** #define R2_CARD_LOCKED 0
 103:../lib/sd_raw.c **** #define R2_WP_ERASE_SKIP 1
 104:../lib/sd_raw.c **** #define R2_ERR 2
 105:../lib/sd_raw.c **** #define R2_CARD_ERR 3
 106:../lib/sd_raw.c **** #define R2_CARD_ECC_FAIL 4
 107:../lib/sd_raw.c **** #define R2_WP_VIOLATION 5
 108:../lib/sd_raw.c **** #define R2_INVAL_ERASE 6
 109:../lib/sd_raw.c **** #define R2_OUT_OF_RANGE 7
 110:../lib/sd_raw.c **** #define R2_CSD_OVERWRITE 7
 111:../lib/sd_raw.c **** #define R2_IDLE_STATE (R1_IDLE_STATE + 8)
 112:../lib/sd_raw.c **** #define R2_ERASE_RESET (R1_ERASE_RESET + 8)
 113:../lib/sd_raw.c **** #define R2_ILL_COMMAND (R1_ILL_COMMAND + 8)
 114:../lib/sd_raw.c **** #define R2_COM_CRC_ERR (R1_COM_CRC_ERR + 8)
 115:../lib/sd_raw.c **** #define R2_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 8)
 116:../lib/sd_raw.c **** #define R2_ADDR_ERR (R1_ADDR_ERR + 8)
 117:../lib/sd_raw.c **** #define R2_PARAM_ERR (R1_PARAM_ERR + 8)
 118:../lib/sd_raw.c **** /* R3: size 5 bytes */
 119:../lib/sd_raw.c **** #define R3_OCR_MASK (0xffffffffUL)
 120:../lib/sd_raw.c **** #define R3_IDLE_STATE (R1_IDLE_STATE + 32)
 121:../lib/sd_raw.c **** #define R3_ERASE_RESET (R1_ERASE_RESET + 32)
 122:../lib/sd_raw.c **** #define R3_ILL_COMMAND (R1_ILL_COMMAND + 32)
 123:../lib/sd_raw.c **** #define R3_COM_CRC_ERR (R1_COM_CRC_ERR + 32)
 124:../lib/sd_raw.c **** #define R3_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 32)
 125:../lib/sd_raw.c **** #define R3_ADDR_ERR (R1_ADDR_ERR + 32)
 126:../lib/sd_raw.c **** #define R3_PARAM_ERR (R1_PARAM_ERR + 32)
 127:../lib/sd_raw.c **** /* Data Response: size 1 byte */
 128:../lib/sd_raw.c **** #define DR_STATUS_MASK 0x0e
 129:../lib/sd_raw.c **** #define DR_STATUS_ACCEPTED 0x05
 130:../lib/sd_raw.c **** #define DR_STATUS_CRC_ERR 0x0a
 131:../lib/sd_raw.c **** #define DR_STATUS_WRITE_ERR 0x0c
 132:../lib/sd_raw.c **** 
 133:../lib/sd_raw.c **** #if !SD_RAW_SAVE_RAM
 134:../lib/sd_raw.c ****     
 135:../lib/sd_raw.c ****     /* static data buffer for acceleration */
 136:../lib/sd_raw.c ****     static unsigned char raw_block[512];
 137:../lib/sd_raw.c ****     /* offset where the data within raw_block lies on the card */
 138:../lib/sd_raw.c ****     static unsigned int raw_block_address;
 139:../lib/sd_raw.c ****     #if SD_RAW_WRITE_BUFFERING
 140:../lib/sd_raw.c ****     /* flag to remember if raw_block was written to the card */
 141:../lib/sd_raw.c ****     static unsigned char raw_block_written;
 142:../lib/sd_raw.c **** #endif
 143:../lib/sd_raw.c **** 
 144:../lib/sd_raw.c **** #endif
 145:../lib/sd_raw.c **** 
 146:../lib/sd_raw.c **** /* private helper functions */
 147:../lib/sd_raw.c **** static void sd_raw_send_byte(unsigned char b);
 148:../lib/sd_raw.c **** static unsigned char sd_raw_rec_byte(void);
 149:../lib/sd_raw.c **** static unsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg);
 150:../lib/sd_raw.c **** //static unsigned short sd_raw_send_command_r2(unsigned char command, unsigned int arg);
 151:../lib/sd_raw.c **** 
 152:../lib/sd_raw.c **** /**
 153:../lib/sd_raw.c ****  * \ingroup sd_raw
 154:../lib/sd_raw.c ****  * Initializes memory card communication.
 155:../lib/sd_raw.c ****  *
 156:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 157:../lib/sd_raw.c ****  */
 158:../lib/sd_raw.c **** unsigned char sd_raw_init()
 159:../lib/sd_raw.c **** {
 160:../lib/sd_raw.c ****     /* enable inputs for reading card status */
 161:../lib/sd_raw.c ****     /*    configure_pin_available();*/
 162:../lib/sd_raw.c ****     /*    configure_pin_locked();*/
 163:../lib/sd_raw.c **** 
 164:../lib/sd_raw.c ****     /* enable outputs for MOSI, SCK, SS, input for MISO */
 165:../lib/sd_raw.c ****     configure_pin_ss();
 166:../lib/sd_raw.c ****     configure_pin_mosi();
 167:../lib/sd_raw.c ****     configure_pin_miso();
 168:../lib/sd_raw.c ****     configure_pin_sck();
 169:../lib/sd_raw.c **** 
 170:../lib/sd_raw.c ****     unselect_card();
 171:../lib/sd_raw.c **** 
 172:../lib/sd_raw.c ****     /* initialize SPI with lowest frequency; max. 400kHz during identification mode of card */
 173:../lib/sd_raw.c ****     S0SPCCR = 150;  /* Set frequency to 400kHz */
 174:../lib/sd_raw.c ****     S0SPCR = 0x38;
 175:../lib/sd_raw.c **** 
 176:../lib/sd_raw.c **** 
 177:../lib/sd_raw.c ****     /* initialization procedure */
 178:../lib/sd_raw.c **** 
 179:../lib/sd_raw.c ****     if(!sd_raw_available())
 180:../lib/sd_raw.c ****     {
 181:../lib/sd_raw.c ****         rprintf("SD RAW NOT AVAILABLE\n\r");
 182:../lib/sd_raw.c ****         return 0;
 183:../lib/sd_raw.c ****     }
 184:../lib/sd_raw.c ****     configure_pin_ss();
 185:../lib/sd_raw.c ****     unselect_card();
 186:../lib/sd_raw.c **** 
 187:../lib/sd_raw.c ****     unsigned short i;
 188:../lib/sd_raw.c ****     /* card needs 74 cycles minimum to start up */
 189:../lib/sd_raw.c ****     for(i = 0; i < 10; ++i)
 190:../lib/sd_raw.c ****     {
 191:../lib/sd_raw.c ****         /* wait 8 clock cycles */
 192:../lib/sd_raw.c ****         sd_raw_rec_byte();
 193:../lib/sd_raw.c ****     }
 194:../lib/sd_raw.c **** 
 195:../lib/sd_raw.c ****     /* address card */
 196:../lib/sd_raw.c ****     select_card();
 197:../lib/sd_raw.c **** 
 198:../lib/sd_raw.c ****     /* reset card */
 199:../lib/sd_raw.c ****     unsigned char response;
 200:../lib/sd_raw.c ****     for(i = 0; ; ++i)
 201:../lib/sd_raw.c ****     {
 202:../lib/sd_raw.c ****         response = sd_raw_send_command_r1(CMD_GO_IDLE_STATE, 0);
 203:../lib/sd_raw.c ****         if(response == (1 << R1_IDLE_STATE))
 204:../lib/sd_raw.c ****             break;
 205:../lib/sd_raw.c **** 
 206:../lib/sd_raw.c ****         if(i == 0x1ff)
 207:../lib/sd_raw.c ****         {
 208:../lib/sd_raw.c ****             rprintf("\n\rresponse: %d\n\r",response);
 209:../lib/sd_raw.c ****             unselect_card();
 210:../lib/sd_raw.c ****             return 0;
 211:../lib/sd_raw.c ****         }
 212:../lib/sd_raw.c ****     }
 213:../lib/sd_raw.c **** 
 214:../lib/sd_raw.c ****     /* wait for card to get ready */
 215:../lib/sd_raw.c ****     for(i = 0; ; ++i)
 216:../lib/sd_raw.c ****     {
 217:../lib/sd_raw.c ****         response = sd_raw_send_command_r1(CMD_SEND_OP_COND, 0);
 218:../lib/sd_raw.c ****         if(!(response & (1 << R1_IDLE_STATE)))
 219:../lib/sd_raw.c ****             break;
 220:../lib/sd_raw.c **** 
 221:../lib/sd_raw.c ****         if(i == 0x7fff)
 222:../lib/sd_raw.c ****         {
 223:../lib/sd_raw.c ****             unselect_card();
 224:../lib/sd_raw.c ****             rprintf("i = 0x7fff\n\r");
 225:../lib/sd_raw.c ****             return 0;
 226:../lib/sd_raw.c ****         }
 227:../lib/sd_raw.c ****     }
 228:../lib/sd_raw.c **** 
 229:../lib/sd_raw.c ****     /* set block size to 512 bytes */
 230:../lib/sd_raw.c ****     if(sd_raw_send_command_r1(CMD_SET_BLOCKLEN, 512))
 231:../lib/sd_raw.c ****     {
 232:../lib/sd_raw.c ****         unselect_card();
 233:../lib/sd_raw.c ****         rprintf("BLOCK SIZE SET ERR \n\r");
 234:../lib/sd_raw.c ****         return 0;
 235:../lib/sd_raw.c ****     }
 236:../lib/sd_raw.c **** 
 237:../lib/sd_raw.c ****     /* deaddress card */
 238:../lib/sd_raw.c ****     unselect_card();
 239:../lib/sd_raw.c **** 
 240:../lib/sd_raw.c ****     /* switch to highest SPI frequency possible */
 241:../lib/sd_raw.c ****     S0SPCCR = 60; /* ~1MHz-- potentially can be faster */
 242:../lib/sd_raw.c **** 
 243:../lib/sd_raw.c ****     #if !SD_RAW_SAVE_RAM
 244:../lib/sd_raw.c ****         /* the first block is likely to be accessed first, so precache it here */
 245:../lib/sd_raw.c ****         raw_block_address = 0xffffffff;
 246:../lib/sd_raw.c ****         #if SD_RAW_WRITE_BUFFERING
 247:../lib/sd_raw.c ****         raw_block_written = 1;
 248:../lib/sd_raw.c ****     #endif
 249:../lib/sd_raw.c ****     if(!sd_raw_read(0, raw_block, sizeof(raw_block)))
 250:../lib/sd_raw.c ****     {
 251:../lib/sd_raw.c ****         rprintf("sd_raw_read borks\n\r");
 252:../lib/sd_raw.c ****         return 0;
 253:../lib/sd_raw.c ****     }
 254:../lib/sd_raw.c ****     #endif
 255:../lib/sd_raw.c **** 
 256:../lib/sd_raw.c ****     return 1;
 257:../lib/sd_raw.c **** }
 258:../lib/sd_raw.c **** 
 259:../lib/sd_raw.c **** /**
 260:../lib/sd_raw.c ****  * \ingroup sd_raw
 261:../lib/sd_raw.c ****  * Checks wether a memory card is located in the slot.
 262:../lib/sd_raw.c ****  *
 263:../lib/sd_raw.c ****  * \returns 1 if the card is available, 0 if it is not.
 264:../lib/sd_raw.c ****  */
 265:../lib/sd_raw.c **** unsigned char sd_raw_available()
 266:../lib/sd_raw.c **** {
  16              	@ Function supports interworking.
  17              		@ args = 0, pretend = 0, frame = 0
  18              		@ frame_needed = 0, uses_anonymous_args = 0
  19              		@ link register save eliminated.
  20              		.loc 1 268 0
 267:../lib/sd_raw.c ****     return i == 0x00;
 268:../lib/sd_raw.c **** }
  21              	r2, .L3
  22 0000 28209FE5 		ldr	r3, [r2, #8]
  23 0004 083092E5 		bic	r3, r3, #128
  24 0008 8030C3E3 		str	r3, [r2, #8]
  25 000c 083082E5 		.loc 1 270 0
 269:../lib/sd_raw.c **** **
 270:../lib/sd_raw.c ****  * \ingroup sd_raw
  26              	r1, [r2, #0]
  27 0010 001092E5 		.loc 1 271 0
 271:../lib/sd_raw.c ****  Checks wether the memory card is locked for write access.
  28              	dr	r3, [r2, #8]
  29 0014 083092E5 		tst	r1, #128
  30 0018 800011E3 		orr	r3, r3, #128
  31 001c 803083E3 		.loc 1 273 0
 272:../lib/sd_raw.c **** *
 273:../lib/sd_raw.c ****  * \returns 1 if the card is locked, 0 if it is not.
  32              	eq	r0, #0
  33 0020 0000A003 		movne	r0, #1
  34 0024 0100A013 		.loc 1 266 0
  35              		@ lr needed for prologue
  36              		.loc 1 271 0
  37              		str	r3, [r2, #8]
  38 0028 083082E5 		.loc 1 273 0
  39              		bx	lr
  40 002c 1EFF2FE1 	.L4:
  41              		.align	2
  42              	.L3:
  43              		.word	-536707072
  44 0030 008002E0 	.LFE3:
  46              		.align	2
  47              		.global	sd_raw_locked
  49              	sd_raw_locked:
  50              	.LFB4:
  51              		.loc 1 282 0
 274:../lib/sd_raw.c **** /
 275:../lib/sd_raw.c **** unsigned char sd_raw_locked()
 276:../lib/sd_raw.c **** {
 277:../lib/sd_raw.c ****     return get_pin_locked() == 0x00;
 278:../lib/sd_raw.c **** }
 279:../lib/sd_raw.c **** 
 280:../lib/sd_raw.c **** /**
 281:../lib/sd_raw.c ****  * \ingroup sd_raw
 282:../lib/sd_raw.c ****  * Sends a raw byte to the memory card.
  52              	 interworking.
  53              		@ args = 0, pretend = 0, frame = 0
  54              		@ frame_needed = 0, uses_anonymous_args = 0
  55              		@ link register save eliminated.
  56              		.loc 1 284 0
 283:../lib/sd_raw.c **** ram[in] b The byte to sent.
 284:../lib/sd_raw.c ****  * \see sd_raw_rec_byte
  57              	r0, #1
  58 0034 0100A0E3 		.loc 1 282 0
  59              		@ lr needed for prologue
  60              		.loc 1 284 0
  61              		bx	lr
  62 0038 1EFF2FE1 	.LFE4:
  64              		.align	2
  66              	sd_raw_rec_byte:
  67              	.LFB6:
  68              		.loc 1 308 0
 285:../lib/sd_raw.c **** /
 286:../lib/sd_raw.c **** void sd_raw_send_byte(unsigned char b)
 287:../lib/sd_raw.c **** {
 288:../lib/sd_raw.c ****     S0SPDR = b;
 289:../lib/sd_raw.c ****     /* wait for byte to be shifted out */
 290:../lib/sd_raw.c ****     while(!(S0SPSR & 0x80));
 291:../lib/sd_raw.c **** }
 292:../lib/sd_raw.c **** 
 293:../lib/sd_raw.c **** /**
 294:../lib/sd_raw.c ****  * \ingroup sd_raw
 295:../lib/sd_raw.c ****  * Receives a raw byte from the memory card.
 296:../lib/sd_raw.c ****  *
 297:../lib/sd_raw.c ****  * \returns The byte which should be read.
 298:../lib/sd_raw.c ****  * \see sd_raw_send_byte
 299:../lib/sd_raw.c ****  */
 300:../lib/sd_raw.c **** unsigned char sd_raw_rec_byte(void)
 301:../lib/sd_raw.c **** {
 302:../lib/sd_raw.c ****     /* send dummy data for receiving some */
 303:../lib/sd_raw.c ****     S0SPDR = 0xff;
 304:../lib/sd_raw.c ****     while(!(S0SPSR & 0x80));
 305:../lib/sd_raw.c **** 
 306:../lib/sd_raw.c ****     return S0SPDR;
 307:../lib/sd_raw.c **** }
 308:../lib/sd_raw.c **** 
  69              	supports interworking.
  70              		@ args = 0, pretend = 0, frame = 0
  71              		@ frame_needed = 0, uses_anonymous_args = 0
  72              		@ link register save eliminated.
  73              		.loc 1 310 0
 309:../lib/sd_raw.c **** * Send a command to the memory card which responses with a R1 response.
 310:../lib/sd_raw.c ****  *
  74              	r3, .L13
  75 003c 20309FE5 		mov	r2, #255
  76 0040 FF20A0E3 		str	r2, [r3, #8]
  77 0044 082083E5 		.loc 1 308 0
  78              		@ lr needed for prologue
  79              	.L8:
  80              		.loc 1 311 0
 311:../lib/sd_raw.c ****  \param[in] command The command to send.
  81              	, .L13
  82 0048 14209FE5 		ldr	r3, [r2, #4]
  83 004c 043092E5 		tst	r3, #128
  84 0050 800013E3 		beq	.L8
  85 0054 FBFFFF0A 		.loc 1 313 0
 312:../lib/sd_raw.c **** * \param[in] arg The argument for command.
 313:../lib/sd_raw.c ****  * \returns The command answer.
  86              	r0, [r2, #8]
  87 0058 080092E5 		and	r0, r0, #255
  88 005c FF0000E2 		.loc 1 314 0
 314:../lib/sd_raw.c **** /
  89              		lr
  90 0060 1EFF2FE1 	.L14:
  91              		.align	2
  92              	.L13:
  93              		.word	-536739840
  94 0064 000002E0 	.LFE6:
  96              		.align	2
  98              	sd_raw_send_command_r1:
  99              	.LFB7:
 100              		.loc 1 325 0
 315:../lib/sd_raw.c **** nsigned char sd_raw_send_command_r1(unsigned char command, unsigned int arg)
 316:../lib/sd_raw.c **** {
 317:../lib/sd_raw.c ****     unsigned char response;
 318:../lib/sd_raw.c ****     unsigned char i;
 319:../lib/sd_raw.c **** 
 320:../lib/sd_raw.c ****     /* wait some clock cycles */
 321:../lib/sd_raw.c ****     sd_raw_rec_byte();
 322:../lib/sd_raw.c **** 
 323:../lib/sd_raw.c ****     /* send command via SPI */
 324:../lib/sd_raw.c ****     sd_raw_send_byte(0x40 | command);
 325:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 24) & 0xff);
 101              	supports interworking.
 102              		@ args = 0, pretend = 0, frame = 0
 103              		@ frame_needed = 0, uses_anonymous_args = 0
 104              	.LVL0:
 105              		stmfd	sp!, {r4, r5, lr}
 106 0068 30402DE9 	.LCFI0:
 107              		.loc 1 325 0
 108              		and	r5, r0, #255
 109 006c FF5000E2 		mov	r4, r1
 110 0070 0140A0E1 		.loc 1 330 0
 326:../lib/sd_raw.c **** send_byte((arg >> 16) & 0xff);
 327:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 8) & 0xff);
 328:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 0) & 0xff);
 329:../lib/sd_raw.c ****     sd_raw_send_byte((command == CMD_GO_IDLE_STATE) ? 0x95 : 0xff);
 330:../lib/sd_raw.c **** 
 111              	_rec_byte
 112 0074 F0FFFFEB 	.LVL1:
 113              	.LBB23:
 114              	.LBB24:
 115              		.loc 1 295 0
 116              		ldr	r3, .L48
 117 0078 C4309FE5 		orr	r2, r5, #64
 118 007c 402085E3 		str	r2, [r3, #8]
 119 0080 082083E5 	.L16:
 120              		.loc 1 297 0
 121              		ldr	r2, .L48
 122 0084 B8209FE5 		ldr	r3, [r2, #4]
 123 0088 043092E5 		tst	r3, #128
 124 008c 800013E3 		beq	.L16
 125 0090 FBFFFF0A 	.LBE24:
 126              	.LBE23:
 127              	.LBB25:
 128              	.LBB26:
 129              		.loc 1 295 0
 130              		mov	r3, r4, lsr #24
 131 0094 243CA0E1 		str	r3, [r2, #8]
 132 0098 083082E5 	.L18:
 133              		.loc 1 297 0
 134              		ldr	r2, .L48
 135 009c A0209FE5 		ldr	r3, [r2, #4]
 136 00a0 043092E5 		tst	r3, #128
 137 00a4 800013E3 		beq	.L18
 138 00a8 FBFFFF0A 	.LBE26:
 139              	.LBE25:
 140              	.LBB27:
 141              	.LBB28:
 142              		.loc 1 295 0
 143              		mov	r3, r4, lsr #16
 144 00ac 2438A0E1 		and	r3, r3, #255
 145 00b0 FF3003E2 		str	r3, [r2, #8]
 146 00b4 083082E5 	.L20:
 147              		.loc 1 297 0
 148              		ldr	r2, .L48
 149 00b8 84209FE5 		ldr	r3, [r2, #4]
 150 00bc 043092E5 		tst	r3, #128
 151 00c0 800013E3 		beq	.L20
 152 00c4 FBFFFF0A 	.LBE28:
 153              	.LBE27:
 154              	.LBB29:
 155              	.LBB30:
 156              		.loc 1 295 0
 157              		mov	r3, r4, lsr #8
 158 00c8 2434A0E1 		and	r3, r3, #255
 159 00cc FF3003E2 		str	r3, [r2, #8]
 160 00d0 083082E5 	.L22:
 161              		.loc 1 297 0
 162              		ldr	r2, .L48
 163 00d4 68209FE5 		ldr	r3, [r2, #4]
 164 00d8 043092E5 		tst	r3, #128
 165 00dc 800013E3 		beq	.L22
 166 00e0 FBFFFF0A 	.LBE30:
 167              	.LBE29:
 168              	.LBB31:
 169              	.LBB32:
 170              		.loc 1 295 0
 171              		and	r3, r4, #255
 172 00e4 FF3004E2 		str	r3, [r2, #8]
 173 00e8 083082E5 	.L24:
 174              		.loc 1 297 0
 175              		ldr	r2, .L48
 176 00ec 50209FE5 		ldr	r3, [r2, #4]
 177 00f0 043092E5 		tst	r3, #128
 178 00f4 800013E3 		beq	.L24
 179 00f8 FBFFFF0A 	.LBE32:
 180              	.LBE31:
 181              	.LBB33:
 182              	.LBB34:
 183              		.loc 1 295 0
 184              		cmp	r5, #0
 185 00fc 000055E3 		movne	r3, #255
 186 0100 FF30A013 		moveq	r3, #149
 187 0104 9530A003 		str	r3, [r2, #8]
 188 0108 083082E5 	.L29:
 189              		.loc 1 297 0
 190              		ldr	r3, .L48
 191 010c 30309FE5 		ldr	r3, [r3, #4]
 192 0110 043093E5 		tst	r3, #128
 193 0114 800013E3 		beq	.L29
 194 0118 FBFFFF0A 		mov	r4, #0
 195 011c 0040A0E3 	.LVL2:
 196              	.L31:
 197              	.LBE34:
 198              	.LBE33:
 199              		.loc 1 343 0
 331:../lib/sd_raw.c **** * receive response */
 332:../lib/sd_raw.c ****     for(i = 0; i < 10; ++i)
 333:../lib/sd_raw.c ****     {
 334:../lib/sd_raw.c ****         response = sd_raw_rec_byte();
 335:../lib/sd_raw.c ****         if(response != 0xff)
 336:../lib/sd_raw.c ****             break;
 337:../lib/sd_raw.c ****     }
 338:../lib/sd_raw.c **** 
 339:../lib/sd_raw.c ****     return response;
 340:../lib/sd_raw.c **** }
 341:../lib/sd_raw.c **** 
 342:../lib/sd_raw.c **** /**
 343:../lib/sd_raw.c ****  * \ingroup sd_raw
 200              	 0
 201 0120 C5FFFFEB 		and	r4, r3, #255
 202              		.loc 1 344 0
 203 0124 013084E2 		bne	.L32
 344:../lib/sd_raw.c **** mand to the memory card which responses with a R2 response.
 204              	c 1 341 0
 205 0128 FF0050E3 		cmp	r4, #10
 206              		bne	.L31
 207 012c FF4003E2 	.L32:
 208              		.loc 1 349 0
 209 0130 0100001A 		ldmfd	sp!, {r4, r5, lr}
 210              		bx	lr
 211 0134 0A0054E3 	.L49:
 212 0138 F8FFFF1A 		.align	2
 213              	.L48:
 345:../lib/sd_raw.c **** *
 346:../lib/sd_raw.c ****  * \param[in] command The command to send.
 347:../lib/sd_raw.c ****  * \param[in] arg The argument for command.
 348:../lib/sd_raw.c ****  * \returns The command answer.
 349:../lib/sd_raw.c ****  */
 214              	6739840
 215 013c 3040BDE8 	.LFE7:
 217              		.align	2
 218              		.global	SDoff
 220 0144 000002E0 	SDoff:
 221              	.LFB13:
 222              		.loc 1 873 0
 223              		@ Function supports interworking.
 224              		@ args = 0, pretend = 0, frame = 0
 225              		@ frame_needed = 0, uses_anonymous_args = 0
 226              		@ link register save eliminated.
 227              		.loc 1 874 0
 350:../lib/sd_raw.c **** signed short sd_raw_send_command_r2(unsigned char command, unsigned int arg)
 351:../lib/sd_raw.c **** {
 352:../lib/sd_raw.c ****     unsigned short response;
 353:../lib/sd_raw.c ****     unsigned char i;
 354:../lib/sd_raw.c **** 
 355:../lib/sd_raw.c ****     // wait some clock cycles
 356:../lib/sd_raw.c ****     sd_raw_rec_byte();
 357:../lib/sd_raw.c **** 
 358:../lib/sd_raw.c ****     // send command via SPI
 359:../lib/sd_raw.c ****     sd_raw_send_byte(0x40 | command);
 360:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 24) & 0xff);
 361:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 16) & 0xff);
 362:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 8) & 0xff);
 363:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 0) & 0xff);
 364:../lib/sd_raw.c ****     sd_raw_send_byte(command == CMD_GO_IDLE_STATE ? 0x95 : 0xff);
 365:../lib/sd_raw.c **** 
 366:../lib/sd_raw.c ****     // receive response
 367:../lib/sd_raw.c ****     for(i = 0; i < 10; ++i)
 368:../lib/sd_raw.c ****     {
 369:../lib/sd_raw.c ****         response = sd_raw_rec_byte();
 370:../lib/sd_raw.c ****         if(response != 0xff)
 371:../lib/sd_raw.c ****             break;
 372:../lib/sd_raw.c ****     }
 373:../lib/sd_raw.c ****     response <<= 8;
 374:../lib/sd_raw.c ****     response |= sd_raw_rec_byte();
 375:../lib/sd_raw.c **** 
 376:../lib/sd_raw.c ****     return response;
 377:../lib/sd_raw.c **** }
 378:../lib/sd_raw.c **** */
 379:../lib/sd_raw.c **** 
 380:../lib/sd_raw.c **** /**
 381:../lib/sd_raw.c ****  * \ingroup sd_raw
 382:../lib/sd_raw.c ****  * Reads raw data from the card.
 383:../lib/sd_raw.c ****  *
 384:../lib/sd_raw.c ****  * \param[in] offset The offset from which to read.
 385:../lib/sd_raw.c ****  * \param[out] buffer The buffer into which to write the data.
 386:../lib/sd_raw.c ****  * \param[in] length The number of bytes to read.
 387:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 388:../lib/sd_raw.c ****  * \see sd_raw_read_interval, sd_raw_write
 389:../lib/sd_raw.c ****  */
 390:../lib/sd_raw.c **** unsigned char sd_raw_read(unsigned int offset, unsigned char* buffer, unsigned short length)
 391:../lib/sd_raw.c **** {
 392:../lib/sd_raw.c ****     unsigned int block_address;
 393:../lib/sd_raw.c ****     unsigned short block_offset;
 394:../lib/sd_raw.c ****     unsigned short read_length;
 395:../lib/sd_raw.c ****     while(length > 0)
 396:../lib/sd_raw.c ****     {
 397:../lib/sd_raw.c ****         /* determine byte count to read at once */
 398:../lib/sd_raw.c ****         block_address = offset & 0xfffffe00;
 399:../lib/sd_raw.c ****         block_offset = offset & 0x01ff;
 400:../lib/sd_raw.c ****         read_length = 512 - block_offset; /* read up to block border */
 401:../lib/sd_raw.c ****         if(read_length > length)
 402:../lib/sd_raw.c ****             read_length = length;
 403:../lib/sd_raw.c **** 
 404:../lib/sd_raw.c ****         #if !SD_RAW_SAVE_RAM
 405:../lib/sd_raw.c ****             /* check if the requested data is cached */
 406:../lib/sd_raw.c ****             if(block_address != raw_block_address)
 407:../lib/sd_raw.c ****             #endif
 408:../lib/sd_raw.c ****         {
 409:../lib/sd_raw.c ****             #if SD_RAW_WRITE_BUFFERING
 410:../lib/sd_raw.c ****                 if(!raw_block_written)
 411:../lib/sd_raw.c ****                 {
 412:../lib/sd_raw.c ****                     if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 413:../lib/sd_raw.c ****                         return 0;
 414:../lib/sd_raw.c ****                 }
 415:../lib/sd_raw.c ****             #endif
 416:../lib/sd_raw.c **** 
 417:../lib/sd_raw.c ****             /* address card */
 418:../lib/sd_raw.c ****             select_card();
 419:../lib/sd_raw.c **** 
 420:../lib/sd_raw.c ****             /* send single block request */
 421:../lib/sd_raw.c ****             if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, block_address))
 422:../lib/sd_raw.c ****             {
 423:../lib/sd_raw.c ****                 unselect_card();
 424:../lib/sd_raw.c ****                 return 0;
 425:../lib/sd_raw.c ****             }
 426:../lib/sd_raw.c **** 
 427:../lib/sd_raw.c ****             /* wait for data block (start byte 0xfe) */
 428:../lib/sd_raw.c ****             while(sd_raw_rec_byte() != 0xfe);
 429:../lib/sd_raw.c **** 
 430:../lib/sd_raw.c ****             #if SD_RAW_SAVE_RAM
 431:../lib/sd_raw.c ****                 /* read byte block */
 432:../lib/sd_raw.c ****                 unsigned short read_to = block_offset + read_length;
 433:../lib/sd_raw.c ****                 for(unsigned short i = 0; i < 512; ++i)
 434:../lib/sd_raw.c ****                 {
 435:../lib/sd_raw.c ****                     unsigned char b = sd_raw_rec_byte();
 436:../lib/sd_raw.c ****                     if(i >= block_offset && i < read_to)
 437:../lib/sd_raw.c ****                         *buffer++ = b;
 438:../lib/sd_raw.c ****                 }
 439:../lib/sd_raw.c ****             #else
 440:../lib/sd_raw.c ****                 /* read byte block */
 441:../lib/sd_raw.c ****                 unsigned char* cache = raw_block;
 442:../lib/sd_raw.c ****                 unsigned short i;
 443:../lib/sd_raw.c ****                 for(i = 0; i < 512; ++i)
 444:../lib/sd_raw.c ****                     *cache++ = sd_raw_rec_byte();
 445:../lib/sd_raw.c ****                 raw_block_address = block_address;
 446:../lib/sd_raw.c ****     
 447:../lib/sd_raw.c ****                 memcpy(buffer, raw_block + block_offset, read_length);
 448:../lib/sd_raw.c ****                 buffer += read_length;
 449:../lib/sd_raw.c ****             #endif
 450:../lib/sd_raw.c **** 
 451:../lib/sd_raw.c ****             /* read crc16 */
 452:../lib/sd_raw.c ****             sd_raw_rec_byte();
 453:../lib/sd_raw.c ****             sd_raw_rec_byte();
 454:../lib/sd_raw.c **** 
 455:../lib/sd_raw.c ****             /* deaddress card */
 456:../lib/sd_raw.c ****             unselect_card();
 457:../lib/sd_raw.c **** 
 458:../lib/sd_raw.c ****             /* let card some time to finish */
 459:../lib/sd_raw.c ****             sd_raw_rec_byte();
 460:../lib/sd_raw.c ****         }
 461:../lib/sd_raw.c ****         #if !SD_RAW_SAVE_RAM
 462:../lib/sd_raw.c ****             else
 463:../lib/sd_raw.c ****             {
 464:../lib/sd_raw.c ****                 /* use cached data */
 465:../lib/sd_raw.c ****                 memcpy(buffer, raw_block + block_offset, read_length);
 466:../lib/sd_raw.c ****             }
 467:../lib/sd_raw.c ****         #endif
 468:../lib/sd_raw.c **** 
 469:../lib/sd_raw.c ****         length -= read_length;
 470:../lib/sd_raw.c ****         offset += read_length;
 471:../lib/sd_raw.c ****     }
 472:../lib/sd_raw.c **** 
 473:../lib/sd_raw.c ****     return 1;
 474:../lib/sd_raw.c **** }
 475:../lib/sd_raw.c **** 
 476:../lib/sd_raw.c **** /**
 477:../lib/sd_raw.c ****  * \ingroup sd_raw
 478:../lib/sd_raw.c ****  * Continuously reads units of \c interval bytes and calls a callback function.
 479:../lib/sd_raw.c ****  *
 480:../lib/sd_raw.c ****  * This function starts reading at the specified offset. Every \c interval bytes,
 481:../lib/sd_raw.c ****  * it calls the callback function with the associated data buffer.
 482:../lib/sd_raw.c ****  *
 483:../lib/sd_raw.c ****  * By returning zero, the callback may stop reading.
 484:../lib/sd_raw.c ****  *
 485:../lib/sd_raw.c ****  * \note Within the callback function, you can not start another read or
 486:../lib/sd_raw.c ****  *       write operation.
 487:../lib/sd_raw.c ****  * \note This function only works if the following conditions are met:
 488:../lib/sd_raw.c ****  *       - (offset - (offset % 512)) % interval == 0
 489:../lib/sd_raw.c ****  *       - length % interval == 0
 490:../lib/sd_raw.c ****  *
 491:../lib/sd_raw.c ****  * \param[in] offset Offset from which to start reading.
 492:../lib/sd_raw.c ****  * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 493:../lib/sd_raw.c ****  * \param[in] interval Number of bytes to read before calling the callback function.
 494:../lib/sd_raw.c ****  * \param[in] length Number of bytes to read altogether.
 495:../lib/sd_raw.c ****  * \param[in] callback The function to call every interval bytes.
 496:../lib/sd_raw.c ****  * \param[in] p An opaque pointer directly passed to the callback function.
 497:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success
 498:../lib/sd_raw.c ****  * \see sd_raw_read, sd_raw_write
 499:../lib/sd_raw.c ****  */
 500:../lib/sd_raw.c **** unsigned char sd_raw_read_interval(unsigned int offset, unsigned char* buffer, unsigned short inter
 501:../lib/sd_raw.c **** {
 502:../lib/sd_raw.c ****     if(!buffer || interval == 0 || length < interval || !callback)
 503:../lib/sd_raw.c ****         return 0;
 504:../lib/sd_raw.c **** 
 505:../lib/sd_raw.c ****     #if !SD_RAW_SAVE_RAM
 506:../lib/sd_raw.c ****         while(length >= interval)
 507:../lib/sd_raw.c ****         {
 508:../lib/sd_raw.c ****             /* as reading is now buffered, we directly
 509:../lib/sd_raw.c ****                      * hand over the request to sd_raw_read()
 510:../lib/sd_raw.c ****                      */
 511:../lib/sd_raw.c ****             if(!sd_raw_read(offset, buffer, interval))
 512:../lib/sd_raw.c ****                 return 0;
 513:../lib/sd_raw.c ****             if(!callback(buffer, offset, p))
 514:../lib/sd_raw.c ****                 break;
 515:../lib/sd_raw.c ****             offset += interval;
 516:../lib/sd_raw.c ****             length -= interval;
 517:../lib/sd_raw.c ****         }
 518:../lib/sd_raw.c ****     
 519:../lib/sd_raw.c ****         return 1;
 520:../lib/sd_raw.c ****     #else
 521:../lib/sd_raw.c ****         /* address card */
 522:../lib/sd_raw.c ****         select_card();
 523:../lib/sd_raw.c ****     
 524:../lib/sd_raw.c ****         unsigned short block_offset;
 525:../lib/sd_raw.c ****         unsigned short read_length;
 526:../lib/sd_raw.c ****         unsigned char* buffer_cur;
 527:../lib/sd_raw.c ****         unsigned char finished = 0;
 528:../lib/sd_raw.c ****         do
 529:../lib/sd_raw.c ****         {
 530:../lib/sd_raw.c ****             /* determine byte count to read at once */
 531:../lib/sd_raw.c ****             block_offset = offset & 0x01ff;
 532:../lib/sd_raw.c ****             read_length = 512 - block_offset;
 533:../lib/sd_raw.c ****     
 534:../lib/sd_raw.c ****             /* send single block request */
 535:../lib/sd_raw.c ****             if(sd_raw_send_command_r1(CMD_READ_SINGLE_BLOCK, offset & 0xfffffe00))
 536:../lib/sd_raw.c ****             {
 537:../lib/sd_raw.c ****                 unselect_card();
 538:../lib/sd_raw.c ****                 return 0;
 539:../lib/sd_raw.c ****             }
 540:../lib/sd_raw.c ****     
 541:../lib/sd_raw.c ****             /* wait for data block (start byte 0xfe) */
 542:../lib/sd_raw.c ****             while(sd_raw_rec_byte() != 0xfe);
 543:../lib/sd_raw.c ****             unsigned short i;
 544:../lib/sd_raw.c ****             /* read up to the data of interest */
 545:../lib/sd_raw.c ****             for(i = 0; i < block_offset; ++i)
 546:../lib/sd_raw.c ****                 sd_raw_rec_byte();
 547:../lib/sd_raw.c ****     
 548:../lib/sd_raw.c ****             /* read interval bytes of data and execute the callback */
 549:../lib/sd_raw.c ****             do
 550:../lib/sd_raw.c ****             {
 551:../lib/sd_raw.c ****                 if(read_length < interval || length < interval)
 552:../lib/sd_raw.c ****                     break;
 553:../lib/sd_raw.c ****     
 554:../lib/sd_raw.c ****                 buffer_cur = buffer;
 555:../lib/sd_raw.c ****                 for(i = 0; i < interval; ++i)
 556:../lib/sd_raw.c ****                     *buffer_cur++ = sd_raw_rec_byte();
 557:../lib/sd_raw.c ****     
 558:../lib/sd_raw.c ****                 if(!callback(buffer, offset + (512 - read_length), p))
 559:../lib/sd_raw.c ****                 {
 560:../lib/sd_raw.c ****                     finished = 1;
 561:../lib/sd_raw.c ****                     break;
 562:../lib/sd_raw.c ****                 }
 563:../lib/sd_raw.c ****     
 564:../lib/sd_raw.c ****                 read_length -= interval;
 565:../lib/sd_raw.c ****                 length -= interval;
 566:../lib/sd_raw.c ****     
 567:../lib/sd_raw.c ****             }
 568:../lib/sd_raw.c ****             while(read_length > 0 && length > 0);
 569:../lib/sd_raw.c ****     
 570:../lib/sd_raw.c ****             /* read rest of data block */
 571:../lib/sd_raw.c ****             while(read_length-- > 0)
 572:../lib/sd_raw.c ****                 sd_raw_rec_byte();
 573:../lib/sd_raw.c ****     
 574:../lib/sd_raw.c ****             /* read crc16 */
 575:../lib/sd_raw.c ****             sd_raw_rec_byte();
 576:../lib/sd_raw.c ****             sd_raw_rec_byte();
 577:../lib/sd_raw.c ****     
 578:../lib/sd_raw.c ****             if(length < interval)
 579:../lib/sd_raw.c ****                 break;
 580:../lib/sd_raw.c ****     
 581:../lib/sd_raw.c ****             offset = (offset & 0xfffffe00) + 512;
 582:../lib/sd_raw.c ****     
 583:../lib/sd_raw.c ****         }
 584:../lib/sd_raw.c ****         while(!finished);
 585:../lib/sd_raw.c ****     
 586:../lib/sd_raw.c ****         /* deaddress card */
 587:../lib/sd_raw.c ****         unselect_card();
 588:../lib/sd_raw.c ****     
 589:../lib/sd_raw.c ****         /* let card some time to finish */
 590:../lib/sd_raw.c ****         sd_raw_rec_byte();
 591:../lib/sd_raw.c ****     
 592:../lib/sd_raw.c ****         return 1;
 593:../lib/sd_raw.c ****     #endif
 594:../lib/sd_raw.c **** }
 595:../lib/sd_raw.c **** 
 596:../lib/sd_raw.c **** /**
 597:../lib/sd_raw.c ****  * \ingroup sd_raw
 598:../lib/sd_raw.c ****  * Writes raw data to the card.
 599:../lib/sd_raw.c ****  *
 600:../lib/sd_raw.c ****  * \note If write buffering is enabled, you might have to
 601:../lib/sd_raw.c ****  *       call sd_raw_sync() before disconnecting the card
 602:../lib/sd_raw.c ****  *       to ensure all remaining data has been written.
 603:../lib/sd_raw.c ****  *
 604:../lib/sd_raw.c ****  * \param[in] offset The offset where to start writing.
 605:../lib/sd_raw.c ****  * \param[in] buffer The buffer containing the data to be written.
 606:../lib/sd_raw.c ****  * \param[in] length The number of bytes to write.
 607:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 608:../lib/sd_raw.c ****  * \see sd_raw_read
 609:../lib/sd_raw.c ****  */
 610:../lib/sd_raw.c **** unsigned char sd_raw_write(unsigned int offset, const unsigned char* buffer, unsigned short length)
 611:../lib/sd_raw.c **** {
 612:../lib/sd_raw.c ****     #if SD_RAW_WRITE_SUPPORT
 613:../lib/sd_raw.c ****     
 614:../lib/sd_raw.c ****         if(get_pin_locked())
 615:../lib/sd_raw.c ****             return 0;
 616:../lib/sd_raw.c ****     
 617:../lib/sd_raw.c ****         unsigned int block_address;
 618:../lib/sd_raw.c ****         unsigned short block_offset;
 619:../lib/sd_raw.c ****         unsigned short write_length;
 620:../lib/sd_raw.c ****         while(length > 0)
 621:../lib/sd_raw.c ****         {
 622:../lib/sd_raw.c ****             /* determine byte count to write at once */
 623:../lib/sd_raw.c ****             block_address = offset & 0xfffffe00;
 624:../lib/sd_raw.c ****             block_offset = offset & 0x01ff;
 625:../lib/sd_raw.c ****             write_length = 512 - block_offset; /* write up to block border */
 626:../lib/sd_raw.c ****             if(write_length > length)
 627:../lib/sd_raw.c ****                 write_length = length;
 628:../lib/sd_raw.c ****     
 629:../lib/sd_raw.c ****             /* Merge the data to write with the content of the block.
 630:../lib/sd_raw.c ****                      * Use the cached block if available.
 631:../lib/sd_raw.c ****                      */
 632:../lib/sd_raw.c ****             if(block_address != raw_block_address)
 633:../lib/sd_raw.c ****             {
 634:../lib/sd_raw.c ****                 #if SD_RAW_WRITE_BUFFERING
 635:../lib/sd_raw.c ****                 if(!raw_block_written)
 636:../lib/sd_raw.c ****                 {
 637:../lib/sd_raw.c ****                     if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 638:../lib/sd_raw.c ****                         return 0;
 639:../lib/sd_raw.c ****                 }
 640:../lib/sd_raw.c ****             #endif
 641:../lib/sd_raw.c **** 
 642:../lib/sd_raw.c ****             if(block_offset || write_length < 512)
 643:../lib/sd_raw.c ****             {
 644:../lib/sd_raw.c ****                 if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
 645:../lib/sd_raw.c ****                     return 0;
 646:../lib/sd_raw.c ****             }
 647:../lib/sd_raw.c ****             raw_block_address = block_address;
 648:../lib/sd_raw.c ****         }
 649:../lib/sd_raw.c **** 
 650:../lib/sd_raw.c ****         if(buffer != raw_block)
 651:../lib/sd_raw.c ****         {
 652:../lib/sd_raw.c ****             memcpy(raw_block + block_offset, buffer, write_length);
 653:../lib/sd_raw.c **** 
 654:../lib/sd_raw.c ****             #if SD_RAW_WRITE_BUFFERING
 655:../lib/sd_raw.c ****                 raw_block_written = 0;
 656:../lib/sd_raw.c ****     
 657:../lib/sd_raw.c ****                 if(length == write_length)
 658:../lib/sd_raw.c ****                     return 1;
 659:../lib/sd_raw.c ****             #endif
 660:../lib/sd_raw.c ****         }
 661:../lib/sd_raw.c **** 
 662:../lib/sd_raw.c ****         buffer += write_length;
 663:../lib/sd_raw.c **** 
 664:../lib/sd_raw.c ****         /* address card */
 665:../lib/sd_raw.c ****         select_card();
 666:../lib/sd_raw.c **** 
 667:../lib/sd_raw.c ****         /* send single block request */
 668:../lib/sd_raw.c ****         if(sd_raw_send_command_r1(CMD_WRITE_SINGLE_BLOCK, block_address))
 669:../lib/sd_raw.c ****         {
 670:../lib/sd_raw.c ****             unselect_card();
 671:../lib/sd_raw.c ****             return 0;
 672:../lib/sd_raw.c ****         }
 673:../lib/sd_raw.c **** 
 674:../lib/sd_raw.c ****         /* send start byte */
 675:../lib/sd_raw.c ****         sd_raw_send_byte(0xfe);
 676:../lib/sd_raw.c **** 
 677:../lib/sd_raw.c ****         /* write byte block */
 678:../lib/sd_raw.c ****         unsigned char* cache = raw_block;
 679:../lib/sd_raw.c ****         unsigned short i;
 680:../lib/sd_raw.c ****         for(i = 0; i < 512; ++i)
 681:../lib/sd_raw.c ****             sd_raw_send_byte(*cache++);
 682:../lib/sd_raw.c **** 
 683:../lib/sd_raw.c ****         /* write dummy crc16 */
 684:../lib/sd_raw.c ****         sd_raw_send_byte(0xff);
 685:../lib/sd_raw.c ****         sd_raw_send_byte(0xff);
 686:../lib/sd_raw.c **** 
 687:../lib/sd_raw.c ****         /* wait while card is busy */
 688:../lib/sd_raw.c ****         while(sd_raw_rec_byte() != 0xff);
 689:../lib/sd_raw.c ****         sd_raw_rec_byte();
 690:../lib/sd_raw.c **** 
 691:../lib/sd_raw.c ****         /* deaddress card */
 692:../lib/sd_raw.c ****         unselect_card();
 693:../lib/sd_raw.c **** 
 694:../lib/sd_raw.c ****         length -= write_length;
 695:../lib/sd_raw.c ****         offset += write_length;
 696:../lib/sd_raw.c **** 
 697:../lib/sd_raw.c ****         #if SD_RAW_WRITE_BUFFERING
 698:../lib/sd_raw.c ****             raw_block_written = 1;
 699:../lib/sd_raw.c ****         #endif
 700:../lib/sd_raw.c ****     }
 701:../lib/sd_raw.c **** 
 702:../lib/sd_raw.c ****     return 1;
 703:../lib/sd_raw.c ****     #else
 704:../lib/sd_raw.c ****         return 0;
 705:../lib/sd_raw.c ****     #endif
 706:../lib/sd_raw.c **** }
 707:../lib/sd_raw.c **** 
 708:../lib/sd_raw.c **** /**
 709:../lib/sd_raw.c ****  * \ingroup sd_raw
 710:../lib/sd_raw.c ****  * Writes the write buffer's content to the card.
 711:../lib/sd_raw.c ****  *
 712:../lib/sd_raw.c ****  * \note When write buffering is enabled, you should
 713:../lib/sd_raw.c ****  *       call this function before disconnecting the
 714:../lib/sd_raw.c ****  *       card to ensure all remaining data has been
 715:../lib/sd_raw.c ****  *       written.
 716:../lib/sd_raw.c ****  *
 717:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 718:../lib/sd_raw.c ****  * \see sd_raw_write
 719:../lib/sd_raw.c ****  */
 720:../lib/sd_raw.c **** unsigned char sd_raw_sync()
 721:../lib/sd_raw.c **** {
 722:../lib/sd_raw.c ****     #if SD_RAW_WRITE_SUPPORT
 723:../lib/sd_raw.c ****         #if SD_RAW_WRITE_BUFFERING
 724:../lib/sd_raw.c ****         if(raw_block_written)
 725:../lib/sd_raw.c ****             return 1;
 726:../lib/sd_raw.c ****         if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 727:../lib/sd_raw.c ****             return 0;
 728:../lib/sd_raw.c ****     #endif
 729:../lib/sd_raw.c ****     return 1;
 730:../lib/sd_raw.c ****     #else
 731:../lib/sd_raw.c ****     return 0;
 732:../lib/sd_raw.c ****     #endif
 733:../lib/sd_raw.c **** }
 734:../lib/sd_raw.c **** 
 735:../lib/sd_raw.c **** /**
 736:../lib/sd_raw.c ****  * \ingroup sd_raw
 737:../lib/sd_raw.c ****  * Reads informational data from the card.
 738:../lib/sd_raw.c ****  *
 739:../lib/sd_raw.c ****  * This function reads and returns the card's registers
 740:../lib/sd_raw.c ****  * containing manufacturing and status information.
 741:../lib/sd_raw.c ****  *
 742:../lib/sd_raw.c ****  * \note: The information retrieved by this function is
 743:../lib/sd_raw.c ****  *        not required in any way to operate on the card,
 744:../lib/sd_raw.c ****  *        but it might be nice to display some of the data
 745:../lib/sd_raw.c ****  *        to the user.
 746:../lib/sd_raw.c ****  *
 747:../lib/sd_raw.c ****  * \param[in] info A pointer to the structure into which to save the information.
 748:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 749:../lib/sd_raw.c ****  */
 750:../lib/sd_raw.c **** unsigned char sd_raw_get_info(struct sd_raw_info* info)
 751:../lib/sd_raw.c **** {
 752:../lib/sd_raw.c ****     if(!info || !sd_raw_available())
 753:../lib/sd_raw.c ****         return 0;
 754:../lib/sd_raw.c **** 
 755:../lib/sd_raw.c ****     memset(info, 0, sizeof(*info));
 756:../lib/sd_raw.c **** 
 757:../lib/sd_raw.c ****     select_card();
 758:../lib/sd_raw.c **** 
 759:../lib/sd_raw.c ****     /* read cid register */
 760:../lib/sd_raw.c ****     if(sd_raw_send_command_r1(CMD_SEND_CID, 0))
 761:../lib/sd_raw.c ****     {
 762:../lib/sd_raw.c ****         unselect_card();
 763:../lib/sd_raw.c ****         return 0;
 764:../lib/sd_raw.c ****     }
 765:../lib/sd_raw.c ****     while(sd_raw_rec_byte() != 0xfe);
 766:../lib/sd_raw.c ****     unsigned char i;
 767:../lib/sd_raw.c ****     for(i = 0; i < 18; ++i)
 768:../lib/sd_raw.c ****     {
 769:../lib/sd_raw.c ****         unsigned char b = sd_raw_rec_byte();
 770:../lib/sd_raw.c **** 
 771:../lib/sd_raw.c ****         switch(i)
 772:../lib/sd_raw.c ****         {
 773:../lib/sd_raw.c ****             case 0:
 774:../lib/sd_raw.c ****                 info->manufacturer = b;
 775:../lib/sd_raw.c ****                 break;
 776:../lib/sd_raw.c ****             case 1:
 777:../lib/sd_raw.c ****             case 2:
 778:../lib/sd_raw.c ****                 info->oem[i - 1] = b;
 779:../lib/sd_raw.c ****                 break;
 780:../lib/sd_raw.c ****             case 3:
 781:../lib/sd_raw.c ****             case 4:
 782:../lib/sd_raw.c ****             case 5:
 783:../lib/sd_raw.c ****             case 6:
 784:../lib/sd_raw.c ****             case 7:
 785:../lib/sd_raw.c ****                 info->product[i - 3] = b;
 786:../lib/sd_raw.c ****                 break;
 787:../lib/sd_raw.c ****             case 8:
 788:../lib/sd_raw.c ****                 info->revision = b;
 789:../lib/sd_raw.c ****                 break;
 790:../lib/sd_raw.c ****             case 9:
 791:../lib/sd_raw.c ****             case 10:
 792:../lib/sd_raw.c ****             case 11:
 793:../lib/sd_raw.c ****             case 12:
 794:../lib/sd_raw.c ****                 info->serial |= (unsigned int) b << ((12 - i) * 8);
 795:../lib/sd_raw.c ****                 break;
 796:../lib/sd_raw.c ****             case 13:
 797:../lib/sd_raw.c ****                 info->manufacturing_year = b << 4;
 798:../lib/sd_raw.c ****                 break;
 799:../lib/sd_raw.c ****             case 14:
 800:../lib/sd_raw.c ****                 info->manufacturing_year |= b >> 4;
 801:../lib/sd_raw.c ****                 info->manufacturing_month = b & 0x0f;
 802:../lib/sd_raw.c ****                 break;
 803:../lib/sd_raw.c ****         }
 804:../lib/sd_raw.c ****     }
 805:../lib/sd_raw.c **** 
 806:../lib/sd_raw.c ****     /* read csd register */
 807:../lib/sd_raw.c ****     unsigned char csd_read_bl_len = 0;
 808:../lib/sd_raw.c ****     unsigned char csd_c_size_mult = 0;
 809:../lib/sd_raw.c ****     unsigned short csd_c_size = 0;
 810:../lib/sd_raw.c ****     if(sd_raw_send_command_r1(CMD_SEND_CSD, 0))
 811:../lib/sd_raw.c ****     {
 812:../lib/sd_raw.c ****         unselect_card();
 813:../lib/sd_raw.c ****         return 0;
 814:../lib/sd_raw.c ****     }
 815:../lib/sd_raw.c ****     while(sd_raw_rec_byte() != 0xfe);
 816:../lib/sd_raw.c ****     for(i = 0; i < 18; ++i)
 817:../lib/sd_raw.c ****     {
 818:../lib/sd_raw.c ****         unsigned char b = sd_raw_rec_byte();
 819:../lib/sd_raw.c **** 
 820:../lib/sd_raw.c ****         switch(i)
 821:../lib/sd_raw.c ****         {
 822:../lib/sd_raw.c ****             case 5:
 823:../lib/sd_raw.c ****                 csd_read_bl_len = b & 0x0f;
 824:../lib/sd_raw.c ****                 break;
 825:../lib/sd_raw.c ****             case 6:
 826:../lib/sd_raw.c ****                 csd_c_size = (unsigned short) (b & 0x03) << 8;
 827:../lib/sd_raw.c ****                 break;
 828:../lib/sd_raw.c ****             case 7:
 829:../lib/sd_raw.c ****                 csd_c_size |= b;
 830:../lib/sd_raw.c ****                 csd_c_size <<= 2;
 831:../lib/sd_raw.c ****                 break;
 832:../lib/sd_raw.c ****             case 8:
 833:../lib/sd_raw.c ****                 csd_c_size |= b >> 6;
 834:../lib/sd_raw.c ****                 ++csd_c_size;
 835:../lib/sd_raw.c ****                 break;
 836:../lib/sd_raw.c ****             case 9:
 837:../lib/sd_raw.c ****                 csd_c_size_mult = (b & 0x03) << 1;
 838:../lib/sd_raw.c ****                 break;
 839:../lib/sd_raw.c ****             case 10:
 840:../lib/sd_raw.c ****                 csd_c_size_mult |= b >> 7;
 841:../lib/sd_raw.c **** 
 842:../lib/sd_raw.c ****                 info->capacity = (unsigned int) csd_c_size << (csd_c_size_mult + csd_read_bl_len + 
 843:../lib/sd_raw.c **** 
 844:../lib/sd_raw.c ****                 break;
 845:../lib/sd_raw.c ****             case 14:
 846:../lib/sd_raw.c ****                 if(b & 0x40)
 847:../lib/sd_raw.c ****                     info->flag_copy = 1;
 848:../lib/sd_raw.c ****                 if(b & 0x20)
 849:../lib/sd_raw.c ****                     info->flag_write_protect = 1;
 850:../lib/sd_raw.c ****                 if(b & 0x10)
 851:../lib/sd_raw.c ****                     info->flag_write_protect_temp = 1;
 852:../lib/sd_raw.c ****                 info->format = (b & 0x0c) >> 2;
 853:../lib/sd_raw.c ****                 break;
 854:../lib/sd_raw.c ****         }
 855:../lib/sd_raw.c ****     }
 856:../lib/sd_raw.c **** 
 857:../lib/sd_raw.c ****     unselect_card();
 858:../lib/sd_raw.c **** 
 859:../lib/sd_raw.c ****     return 1;
 860:../lib/sd_raw.c **** }
 861:../lib/sd_raw.c **** 
 862:../lib/sd_raw.c **** void SDoff(void)
 863:../lib/sd_raw.c **** {
 864:../lib/sd_raw.c ****     SPI_SS_IODIR &= ~(1<<SPI_SS_PIN);
 865:../lib/sd_raw.c ****     PINSEL0 &= ~(0x1500);
 866:../lib/sd_raw.c **** }
 867:../lib/sd_raw.c **** 
 868:../lib/sd_raw.c **** //NES : 10-28-7 
 869:../lib/sd_raw.c **** //Low-level formats a 512MB card
 870:../lib/sd_raw.c **** //Assumes *many* things
 871:../lib/sd_raw.c **** //You must pass this fuction 0xAA to get it to work (safety check)
 872:../lib/sd_raw.c **** char format_card(char make_sure)
 873:../lib/sd_raw.c **** {
 228              		ldr	r3, [r2, #8]
 229              		bic	r3, r3, #128
 230              		str	r3, [r2, #8]
 231              		.loc 1 875 0
 232              		add	r2, r2, #16384
 874:../lib/sd_raw.c **** ATION + (0x200 * 512))
 233              	r3, [r2, #0]
 234 0148 1C209FE5 		bic	r3, r3, #5376
 235 014c 083092E5 		.loc 1 873 0
 236 0150 8030C3E3 		@ lr needed for prologue
 237 0154 083082E5 		.loc 1 875 0
 875:../lib/sd_raw.c **** BR_LOCATION		(MBR_LOCATION+0x80000)
 238              	r3, [r2, #0]
 239 0158 012982E2 		.loc 1 876 0
 240 015c 003092E5 		bx	lr
 241 0160 153CC3E3 	.L53:
 242              		.align	2
 243              	.L52:
 244              		.word	-536707072
 245 0164 003082E5 	.LFE13:
 876:../lib/sd_raw.c **** r make_sure)
 246              	Doff, .-SDoff
 247 0168 1EFF2FE1 		.align	2
 248              		.global	sd_raw_get_info
 250              	sd_raw_get_info:
 251 016c 008002E0 	.LFB12:
 252              		.loc 1 761 0
 253              		@ Function supports interworking.
 254              		@ args = 0, pretend = 0, frame = 0
 255              		@ frame_needed = 0, uses_anonymous_args = 0
 256              	.LVL3:
 257              		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 258              	.LCFI1:
 259              		.loc 1 762 0
 260              		subs	r4, r0, #0
 261              		beq	.L55
 262              	.LVL4:
 263              		bl	sd_raw_available
 264 0170 F0412DE9 		cmp	r0, #0
 265              		beq	.L55
 266              		.loc 1 767 0
 267 0174 004050E2 		ldr	r5, .L121
 268 0178 9700000A 		.loc 1 765 0
 269              		mov	r1, #0
 270 017c FEFFFFEB 		mov	r2, #28
 271 0180 000050E3 		mov	r0, r4
 272 0184 9400000A 		bl	memset
 273              		.loc 1 767 0
 274 0188 70529FE5 		ldr	r3, [r5, #12]
 275              		orr	r3, r3, #128
 276 018c 0010A0E3 		.loc 1 770 0
 277 0190 1C20A0E3 		mov	r0, #10
 278 0194 0400A0E1 		mov	r1, #0
 279 0198 FEFFFFEB 		.loc 1 767 0
 280              		str	r3, [r5, #12]
 281 019c 0C3095E5 		.loc 1 770 0
 282 01a0 803083E3 		bl	sd_raw_send_command_r1
 283              		cmp	r0, #0
 284 01a4 0A00A0E3 		.loc 1 772 0
 285 01a8 0010A0E3 		ldrne	r3, [r5, #4]
 286              		movne	r0, #0
 287 01ac 0C3085E5 		orrne	r3, r3, #128
 288              		strne	r3, [r5, #4]
 289 01b0 ACFFFFEB 		bne	.L60
 290 01b4 000050E3 	.L102:
 291              		.loc 1 775 0
 292 01b8 04309515 		bl	sd_raw_rec_byte
 293 01bc 0000A013 		cmp	r0, #254
 294 01c0 80308313 		bne	.L102
 295 01c4 04308515 	.LBB35:
 296 01c8 8A00001A 		.loc 1 779 0
 297              		bl	sd_raw_rec_byte
 298              		mov	r5, #0
 299 01cc 9AFFFFEB 	.LVL5:
 300 01d0 FE0050E3 		b	.L62
 301 01d4 FCFFFF1A 	.LVL6:
 302              	.L63:
 303              		bl	sd_raw_rec_byte
 304 01d8 97FFFFEB 	.LVL7:
 305 01dc 0050A0E3 		.loc 1 781 0
 306              		cmp	r5, #14
 307 01e0 120000EA 		ldrls	pc, [pc, r5, asl #2]
 308              		b	.L64
 309              		.p2align 2
 310 01e4 94FFFFEB 	.L71:
 311              		.word	.L62
 312              		.word	.L65
 313 01e8 0E0055E3 		.word	.L65
 314 01ec 05F19F97 		.word	.L66
 315 01f0 260000EA 		.word	.L66
 316              		.word	.L66
 317              		.word	.L66
 318 01f4 30020000 		.word	.L66
 319 01f8 38020000 		.word	.L67
 320 01fc 38020000 		.word	.L68
 321 0200 40020000 		.word	.L68
 322 0204 40020000 		.word	.L68
 323 0208 40020000 		.word	.L68
 324 020c 40020000 		.word	.L69
 325 0210 40020000 		.word	.L70
 326 0214 4C020000 	.L62:
 327 0218 54020000 	.LVL8:
 328 021c 54020000 		.loc 1 784 0
 329 0220 54020000 		strb	r0, [r4, #0]
 330 0224 54020000 		b	.L120
 331 0228 6C020000 	.LVL9:
 332 022c 78020000 	.L65:
 333              	.LVL10:
 334              		.loc 1 788 0
 335              		strb	r0, [r5, r4]
 336 0230 0000C4E5 		b	.L64
 337 0234 6A0000EA 	.LVL11:
 338              	.L66:
 339              		.loc 1 795 0
 340              		add	r3, r5, r4
 341              	.LVL12:
 342 0238 0400C5E7 		strb	r0, [r3, #1]
 343 023c 130000EA 		b	.L64
 344              	.LVL13:
 345              	.L67:
 346              	.LVL14:
 347 0240 043085E0 		.loc 1 798 0
 348              		strb	r0, [r4, #10]
 349 0244 0100C3E5 		b	.L120
 350 0248 100000EA 	.LVL15:
 351              	.L68:
 352              		.loc 1 804 0
 353              		ldr	r2, [r4, #12]
 354              		rsb	r3, r5, #12
 355 024c 0A00C4E5 		mov	r3, r3, asl #3
 356 0250 630000EA 	.LVL16:
 357              		orr	r2, r2, r0, asl r3
 358              		str	r2, [r4, #12]
 359              		b	.L64
 360 0254 0C2094E5 	.LVL17:
 361 0258 0C3065E2 	.L69:
 362 025c 8331A0E1 	.LVL18:
 363              		.loc 1 807 0
 364 0260 102382E1 		mov	r3, r0, asl #4
 365 0264 0C2084E5 		strb	r3, [r4, #16]
 366 0268 080000EA 		b	.L120
 367              	.LVL19:
 368              	.L70:
 369              		.loc 1 810 0
 370              		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 371 026c 0032A0E1 	.LVL20:
 372 0270 1030C4E5 		.loc 1 811 0
 373 0274 5A0000EA 		and	r2, r0, #15
 374              		.loc 1 810 0
 375              		orr	r3, r3, r0, lsr #4
 376              		strb	r3, [r4, #16]
 377 0278 1030D4E5 		.loc 1 811 0
 378              		strb	r2, [r4, #17]
 379              		b	.L120
 380 027c 0F2000E2 	.L64:
 381              	.LBE35:
 382 0280 203283E1 		.loc 1 777 0
 383 0284 1030C4E5 		add	r3, r5, #1
 384              		and	r5, r3, #255
 385 0288 1120C4E5 		cmp	r5, #17
 386 028c 540000EA 		bls	.L63
 387              		.loc 1 820 0
 388              		mov	r0, #9
 389              	.LVL21:
 390 0290 013085E2 		mov	r1, #0
 391 0294 FF5003E2 		bl	sd_raw_send_command_r1
 392 0298 110055E3 		cmp	r0, #0
 393 029c D0FFFF9A 		.loc 1 822 0
 394              		ldrne	r2, .L121
 395 02a0 0900A0E3 		ldrne	r3, [r2, #4]
 396              		movne	r0, #0
 397 02a4 0010A0E3 		orrne	r3, r3, #128
 398 02a8 6EFFFFEB 		bne	.L118
 399 02ac 000050E3 	.L103:
 400              		.loc 1 825 0
 401 02b0 48219F15 		bl	sd_raw_rec_byte
 402 02b4 04309215 		cmp	r0, #254
 403 02b8 0000A013 		bne	.L103
 404 02bc 80308313 	.LBB36:
 405 02c0 4300001A 		.loc 1 828 0
 406              		bl	sd_raw_rec_byte
 407              	.LBE36:
 408 02c4 5CFFFFEB 		.loc 1 826 0
 409 02c8 FE0050E3 		mov	r7, #0
 410 02cc FCFFFF1A 	.LVL22:
 411              		mov	r5, #1
 412              	.LVL23:
 413 02d0 59FFFFEB 		mov	r8, r7
 414              	.LVL24:
 415              		mov	r6, r7
 416 02d4 0070A0E3 	.LVL25:
 417              	.LVL26:
 418 02d8 0150A0E3 	.L119:
 419              	.LBB37:
 420 02dc 0780A0E1 		.loc 1 828 0
 421              		bl	sd_raw_rec_byte
 422 02e0 0760A0E1 	.LVL27:
 423              		.loc 1 830 0
 424              		sub	r3, r5, #5
 425              		add	r2, r5, #1
 426              		cmp	r3, #9
 427              		ldrls	pc, [pc, r3, asl #2]
 428 02e4 54FFFFEB 		b	.L78
 429              		.p2align 2
 430              	.L86:
 431 02e8 053045E2 		.word	.L79
 432 02ec 012085E2 		.word	.L80
 433 02f0 090053E3 		.word	.L81
 434 02f4 03F19F97 		.word	.L82
 435 02f8 2E0000EA 		.word	.L83
 436              		.word	.L84
 437              		.word	.L78
 438 02fc 24030000 		.word	.L78
 439 0300 2C030000 		.word	.L78
 440 0304 38030000 		.word	.L85
 441 0308 44030000 	.L79:
 442 030c 5C030000 	.LVL28:
 443 0310 68030000 		.loc 1 833 0
 444 0314 B8030000 		and	r8, r0, #15
 445 0318 B8030000 		b	.L87
 446 031c B8030000 	.LVL29:
 447 0320 84030000 	.L80:
 448              	.LVL30:
 449              		.loc 1 836 0
 450              		and	r3, r0, #3
 451 0324 0F8000E2 		mov	r6, r3, asl #8
 452 0328 300000EA 		b	.L87
 453              	.LVL31:
 454              	.L81:
 455              	.LVL32:
 456              		.loc 1 839 0
 457 032c 033000E2 		orr	r3, r6, r0
 458 0330 0364A0E1 		.loc 1 840 0
 459 0334 2D0000EA 		mov	r3, r3, asl #18
 460              		b	.L117
 461              	.LVL33:
 462              	.L82:
 463              	.LVL34:
 464 0338 003086E1 		.loc 1 843 0
 465              		mov	r3, r0, asl #18
 466 033c 0339A0E1 		orr	r3, r6, r3, lsr #24
 467 0340 030000EA 	.LVL35:
 468              		.loc 1 844 0
 469              		add	r3, r3, #1
 470              	.LVL36:
 471              		mov	r3, r3, asl #16
 472 0344 0039A0E1 	.L117:
 473 0348 233C86E1 		mov	r6, r3, lsr #16
 474              		b	.L87
 475              	.LVL37:
 476 034c 013083E2 	.L83:
 477              	.LVL38:
 478 0350 0338A0E1 		.loc 1 847 0
 479              		and	r3, r0, #3
 480 0354 2368A0E1 		mov	r7, r3, asl #1
 481 0358 240000EA 		b	.L87
 482              	.LVL39:
 483              	.L84:
 484              	.LVL40:
 485              		.loc 1 850 0
 486 035c 033000E2 		orr	r3, r7, r0, lsr #7
 487 0360 8370A0E1 		and	r7, r3, #255
 488 0364 210000EA 		.loc 1 852 0
 489              		add	r3, r8, #2
 490              		add	r3, r7, r3
 491              		mov	r3, r6, asl r3
 492              		str	r3, [r4, #20]
 493 0368 A03387E1 		b	.L87
 494 036c FF7003E2 	.LVL41:
 495              	.L85:
 496 0370 023088E2 	.LVL42:
 497 0374 033087E0 		.loc 1 856 0
 498 0378 1633A0E1 		tst	r0, #64
 499 037c 143084E5 		.loc 1 857 0
 500 0380 1A0000EA 		movne	r3, #1
 501              		strneb	r3, [r4, #24]
 502              		.loc 1 858 0
 503              		tst	r0, #32
 504              		.loc 1 859 0
 505 0384 400010E3 		movne	r3, #1
 506              		strneb	r3, [r4, #25]
 507 0388 0130A013 		.loc 1 860 0
 508 038c 1830C415 		tst	r0, #16
 509              		.loc 1 861 0
 510 0390 200010E3 		movne	r3, #1
 511              		strneb	r3, [r4, #26]
 512 0394 0130A013 		.loc 1 862 0
 513 0398 1930C415 		and	r3, r0, #12
 514              		mov	r3, r3, asr #2
 515 039c 100010E3 		strb	r3, [r4, #27]
 516              		b	.L87
 517 03a0 0130A013 	.LVL43:
 518 03a4 1A30C415 	.L78:
 519              	.LBE37:
 520 03a8 0C3000E2 		.loc 1 826 0
 521 03ac 4331A0E1 		and	r5, r2, #255
 522 03b0 1B30C4E5 		cmp	r5, #17
 523 03b4 0D0000EA 		bls	.L119
 524              		.loc 1 867 0
 525              		ldr	r2, .L121
 526              		ldr	r3, [r2, #4]
 527              		mov	r0, #1
 528 03b8 FF5002E2 		orr	r3, r3, #128
 529 03bc 110055E3 	.LVL44:
 530 03c0 C7FFFF9A 	.L118:
 531              		str	r3, [r2, #4]
 532 03c4 34209FE5 		b	.L60
 533 03c8 043092E5 	.LVL45:
 534 03cc 0100A0E3 	.L55:
 535 03d0 803083E3 		.loc 1 869 0
 536              		mov	r0, #0
 537              		b	.L60
 538 03d4 043082E5 	.LVL46:
 539 03d8 060000EA 	.L120:
 540              		.loc 1 777 0
 541              		add	r3, r5, #1
 542              		and	r5, r3, #255
 543 03dc 0000A0E3 		b	.L63
 544 03e0 040000EA 	.LVL47:
 545              	.L87:
 546              		.loc 1 826 0
 547              		and	r5, r2, #255
 548 03e4 013085E2 		b	.L119
 549 03e8 FF5003E2 	.LVL48:
 550 03ec 7CFFFFEA 	.L60:
 551              		.loc 1 870 0
 552              		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 553              		bx	lr
 554 03f0 FF5002E2 	.L122:
 555 03f4 BAFFFFEA 		.align	2
 556              	.L121:
 557              		.word	-536707072
 558              	.LFE12:
 560 03fc 1EFF2FE1 		.align	2
 561              		.global	sd_raw_read
 563              	sd_raw_read:
 564 0400 008002E0 	.LFB8:
 565              		.loc 1 401 0
 566              		@ Function supports interworking.
 567              		@ args = 0, pretend = 0, frame = 0
 568              		@ frame_needed = 0, uses_anonymous_args = 0
 569              	.LVL49:
 570              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 571              	.LCFI2:
 572              		.loc 1 401 0
 573              		mov	r2, r2, asl #16
 574              	.LVL50:
 575              		mov	r9, r0
 576              		mov	sl, r1
 577 0404 F0472DE9 		mov	r8, r2, lsr #16
 578              	.LVL51:
 579              		b	.L124
 580 0408 0228A0E1 	.LVL52:
 581              	.L125:
 582 040c 0090A0E1 		.loc 1 409 0
 583 0410 01A0A0E1 		mov	r6, r9, asl #23
 584 0414 2288A0E1 		mov	r6, r6, lsr #23
 585              		.loc 1 416 0
 586 0418 460000EA 		ldr	r3, .L145
 587              		.loc 1 410 0
 588              		rsb	r2, r6, #512
 589              		mov	r2, r2, asl #16
 590 041c 896BA0E1 		.loc 1 416 0
 591 0420 A66BA0E1 		ldr	r0, [r3, #0]
 592              		.loc 1 408 0
 593 0424 20319FE5 		bic	r5, r9, #508
 594              		bic	r5, r5, #3
 595 0428 022C66E2 		.loc 1 410 0
 596 042c 0228A0E1 		mov	r2, r2, lsr #16
 597              	.LVL53:
 598 0430 000093E5 		cmp	r8, r2
 599              		movcc	r7, r8
 600 0434 7F5FC9E3 		movcs	r7, r2
 601 0438 0350C5E3 		.loc 1 416 0
 602              		cmp	r5, r0
 603 043c 2228A0E1 		beq	.L126
 604              	.LBB38:
 605 0440 020058E1 		.loc 1 420 0
 606 0444 0870A031 		ldr	r3, .L145+4
 607 0448 0270A021 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 608              		cmp	r3, #0
 609 044c 000055E1 		bne	.L128
 610 0450 2F00000A 		.loc 1 422 0
 611              		ldr	r1, .L145+8
 612              		mov	r2, #512
 613 0454 F4309FE5 	.LVL54:
 614 0458 0030D3E5 		bl	sd_raw_write
 615 045c 000053E3 		cmp	r0, #0
 616 0460 0400001A 		beq	.L131
 617              	.LVL55:
 618 0464 E8109FE5 	.L128:
 619 0468 022CA0E3 		.loc 1 428 0
 620              		ldr	r4, .L145+12
 621 046c FEFFFFEB 		ldr	r3, [r4, #12]
 622 0470 000050E3 		orr	r3, r3, #128
 623 0474 3200000A 		.loc 1 431 0
 624              		mov	r0, #17
 625              		mov	r1, r5
 626              		.loc 1 428 0
 627 0478 D8409FE5 		str	r3, [r4, #12]
 628 047c 0C3094E5 		.loc 1 431 0
 629 0480 803083E3 		bl	sd_raw_send_command_r1
 630              	.LVL56:
 631 0484 1100A0E3 		cmp	r0, #0
 632 0488 0510A0E1 		.loc 1 433 0
 633              		ldrne	r3, [r4, #4]
 634 048c 0C3084E5 		movne	r0, #0
 635              		orrne	r3, r3, #128
 636 0490 F4FEFFEB 		strne	r3, [r4, #4]
 637              		bne	.L131
 638 0494 000050E3 	.L140:
 639              		.loc 1 438 0
 640 0498 04309415 		bl	sd_raw_rec_byte
 641 049c 0000A013 		cmp	r0, #254
 642 04a0 80308313 		bne	.L140
 643 04a4 04308415 		ldr	r4, .L145+16
 644 04a8 2500001A 	.L135:
 645              		.loc 1 454 0
 646              		bl	sd_raw_rec_byte
 647 04ac E2FEFFEB 		.loc 1 453 0
 648 04b0 FE0050E3 		ldr	r3, .L145+20
 649 04b4 FCFFFF1A 		.loc 1 454 0
 650 04b8 9C409FE5 		strb	r0, [r4, #-1]
 651              		add	r4, r4, #1
 652              		.loc 1 453 0
 653 04bc DEFEFFEB 		cmp	r4, r3
 654              		bne	.L135
 655 04c0 98309FE5 		.loc 1 455 0
 656              		ldr	r3, .L145
 657 04c4 010044E5 		.loc 1 457 0
 658 04c8 014084E2 		ldr	r1, .L145+8
 659              		mov	r2, r7
 660 04cc 030054E1 		.loc 1 455 0
 661 04d0 F9FFFF1A 		str	r5, [r3, #0]
 662              		.loc 1 457 0
 663 04d4 70309FE5 		add	r1, r6, r1
 664              		mov	r0, sl
 665 04d8 74109FE5 		bl	memcpy
 666 04dc 0720A0E1 		.loc 1 462 0
 667              		bl	sd_raw_rec_byte
 668 04e0 005083E5 		.loc 1 463 0
 669              		bl	sd_raw_rec_byte
 670 04e4 011086E0 		.loc 1 466 0
 671 04e8 0A00A0E1 		ldr	r2, .L145+12
 672 04ec FEFFFFEB 		ldr	r3, [r2, #4]
 673              		orr	r3, r3, #128
 674 04f0 D1FEFFEB 		str	r3, [r2, #4]
 675              		.loc 1 458 0
 676 04f4 D0FEFFEB 		add	sl, sl, r7
 677              		.loc 1 469 0
 678 04f8 58209FE5 		bl	sd_raw_rec_byte
 679 04fc 043092E5 		b	.L137
 680 0500 803083E3 	.LVL57:
 681 0504 043082E5 	.L126:
 682              	.LBE38:
 683 0508 07A08AE0 		.loc 1 475 0
 684              		ldr	r1, .L145+8
 685 050c CAFEFFEB 		mov	r0, sl
 686 0510 040000EA 		add	r1, r6, r1
 687              		mov	r2, r7
 688              	.LVL58:
 689              		bl	memcpy
 690              	.L137:
 691 0514 38109FE5 		.loc 1 479 0
 692 0518 0A00A0E1 		rsb	r3, r7, r8
 693 051c 011086E0 		mov	r3, r3, asl #16
 694 0520 0720A0E1 		.loc 1 480 0
 695              		add	r9, r9, r7
 696 0524 FEFFFFEB 		.loc 1 479 0
 697              		mov	r8, r3, lsr #16
 698              	.LVL59:
 699 0528 083067E0 	.L124:
 700 052c 0338A0E1 		.loc 1 405 0
 701              		cmp	r8, #0
 702 0530 079089E0 		bne	.L125
 703              		mov	r0, #1
 704 0534 2388A0E1 	.L131:
 705              		.loc 1 484 0
 706              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 707              		bx	lr
 708 0538 000058E3 	.L146:
 709 053c B6FFFF1A 		.align	2
 710 0540 0100A0E3 	.L145:
 711              		.word	raw_block_address
 712              		.word	raw_block_written
 713 0544 F047BDE8 		.word	raw_block
 714 0548 1EFF2FE1 		.word	-536707072
 715              		.word	raw_block+1
 716              		.word	raw_block+513
 717              	.LFE8:
 719 0550 04020000 		.align	2
 720 0554 00000000 		.global	sd_raw_write
 722 055c 01000000 	sd_raw_write:
 723 0560 01020000 	.LFB10:
 724              		.loc 1 621 0
 725              		@ Function supports interworking.
 726              		@ args = 0, pretend = 0, frame = 0
 727              		@ frame_needed = 0, uses_anonymous_args = 0
 728              	.LVL60:
 729              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 730              	.LCFI3:
 731              		.loc 1 621 0
 732              		mov	r2, r2, asl #16
 733              	.LVL61:
 734              		mov	sl, r0
 735              		mov	r8, r1
 736 0564 F0472DE9 		mov	r7, r2, lsr #16
 737              	.LVL62:
 738              		b	.L148
 739 0568 0228A0E1 	.LVL63:
 740              	.L149:
 741 056c 00A0A0E1 	.LBB39:
 742 0570 0180A0E1 		.loc 1 634 0
 743 0574 2278A0E1 		mov	r4, sl, asl #23
 744              	.LVL64:
 745 0578 690000EA 		mov	r4, r4, lsr #23
 746              		.loc 1 642 0
 747              		ldr	r9, .L188
 748              		.loc 1 635 0
 749              		rsb	r3, r4, #512
 750 057c 8A4BA0E1 		mov	r3, r3, asl #16
 751              		.loc 1 633 0
 752 0580 A44BA0E1 		bic	r5, sl, #508
 753              		.loc 1 642 0
 754 0584 CC919FE5 		ldr	r0, [r9, #0]
 755              		.loc 1 633 0
 756 0588 023C64E2 		bic	r5, r5, #3
 757 058c 0338A0E1 		.loc 1 635 0
 758              		mov	r3, r3, lsr #16
 759 0590 7F5FCAE3 	.LVL65:
 760              		cmp	r7, r3
 761 0594 000099E5 		movcc	r6, r7
 762              		movcs	r6, r3
 763 0598 0350C5E3 		.loc 1 642 0
 764              		cmp	r5, r0
 765 059c 2338A0E1 		beq	.L150
 766              		.loc 1 645 0
 767 05a0 030057E1 		ldr	r3, .L188+4
 768 05a4 0760A031 	.LVL66:
 769 05a8 0360A021 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 770              		cmp	r3, #0
 771 05ac 000055E1 		bne	.L152
 772 05b0 1700000A 		.loc 1 647 0
 773              		ldr	r1, .L188+8
 774 05b4 A0319FE5 		mov	r2, #512
 775              		bl	sd_raw_write
 776 05b8 0030D3E5 		cmp	r0, #0
 777 05bc 000053E3 		beq	.L154
 778 05c0 0400001A 	.LVL67:
 779              	.L152:
 780 05c4 94119FE5 		.loc 1 652 0
 781 05c8 022CA0E3 		ldr	r3, .L188+12
 782 05cc FEFFFFEB 		cmp	r6, r3
 783 05d0 000050E3 		movhi	r3, #0
 784 05d4 5500000A 		movls	r3, #1
 785              		cmp	r4, #0
 786              		orrne	r3, r3, #1
 787              		cmp	r3, #0
 788 05d8 84319FE5 		beq	.L155
 789 05dc 030056E1 		.loc 1 654 0
 790 05e0 0030A083 		mov	r0, r5
 791 05e4 0130A093 		ldr	r1, .L188+8
 792 05e8 000054E3 		mov	r2, #512
 793 05ec 01308313 		bl	sd_raw_read
 794 05f0 000053E3 		cmp	r0, #0
 795 05f4 0500000A 		beq	.L154
 796              	.LVL68:
 797 05f8 0500A0E1 	.L155:
 798 05fc 5C119FE5 		.loc 1 657 0
 799 0600 022CA0E3 		str	r5, [r9, #0]
 800 0604 FEFFFFEB 	.LVL69:
 801 0608 000050E3 	.L150:
 802 060c 4700000A 		.loc 1 660 0
 803              		ldr	r3, .L188+8
 804              	.LVL70:
 805              		cmp	r8, r3
 806 0610 005089E5 		beq	.L157
 807              		.loc 1 662 0
 808              		add	r0, r4, r3
 809              		mov	r2, r6
 810 0614 44319FE5 		mov	r1, r8
 811              		bl	memcpy
 812 0618 030058E1 		.loc 1 665 0
 813 061c 0800000A 		ldr	r3, .L188+4
 814              		mov	r2, #0
 815 0620 030084E0 		.loc 1 667 0
 816 0624 0620A0E1 		cmp	r7, r6
 817 0628 0810A0E1 		.loc 1 665 0
 818 062c FEFFFFEB 		strb	r2, [r3, #0]
 819              		.loc 1 667 0
 820 0630 24319FE5 		beq	.L159
 821 0634 0020A0E3 	.LVL71:
 822              	.L157:
 823 0638 060057E1 		.loc 1 675 0
 824              		ldr	r4, .L188+16
 825 063c 0020C3E5 	.LVL72:
 826              		ldr	r3, [r4, #12]
 827 0640 4100000A 		orr	r3, r3, #128
 828              		.loc 1 678 0
 829              		mov	r1, r5
 830              		mov	r0, #24
 831 0644 1C419FE5 		.loc 1 675 0
 832              		str	r3, [r4, #12]
 833 0648 0C3094E5 		.loc 1 678 0
 834 064c 803083E3 		bl	sd_raw_send_command_r1
 835              		cmp	r0, #0
 836 0650 0510A0E1 		bne	.L175
 837 0654 1800A0E3 	.LBB40:
 838              	.LBB41:
 839 0658 0C3084E5 		.loc 1 295 0
 840              		ldr	r3, .L188+20
 841 065c 81FEFFEB 		mov	r2, #254
 842 0660 000050E3 		str	r2, [r3, #8]
 843 0664 3300001A 	.L163:
 844              		.loc 1 297 0
 845              		ldr	r3, .L188+20
 846              		ldr	r3, [r3, #4]
 847 0668 FC309FE5 		tst	r3, #128
 848 066c FE20A0E3 		beq	.L163
 849 0670 082083E5 		ldr	r1, .L188+24
 850              	.L165:
 851              	.LBE41:
 852 0674 F0309FE5 	.LBE40:
 853 0678 043093E5 	.LBB42:
 854 067c 800013E3 	.LBB43:
 855 0680 FBFFFF0A 		.loc 1 295 0
 856 0684 E4109FE5 		ldrb	r2, [r1, #-1]	@ zero_extendqisi2
 857              		ldr	r3, .L188+20
 858              		str	r2, [r3, #8]
 859              	.L166:
 860              		.loc 1 297 0
 861              		ldr	r2, .L188+20
 862              		ldr	r3, [r2, #4]
 863 0688 012051E5 		tst	r3, #128
 864 068c D8309FE5 		beq	.L166
 865 0690 082083E5 	.LBE43:
 866              	.LBE42:
 867              		.loc 1 690 0
 868 0694 D0209FE5 		ldr	r3, .L188+28
 869 0698 043092E5 	.LBB44:
 870 069c 800013E3 	.LBB45:
 871 06a0 FBFFFF0A 		.loc 1 297 0
 872              		add	r1, r1, #1
 873              	.LBE45:
 874              	.LBE44:
 875 06a4 C8309FE5 		.loc 1 690 0
 876              		cmp	r1, r3
 877              		bne	.L165
 878              	.LBB46:
 879 06a8 011081E2 	.LBB47:
 880              		.loc 1 295 0
 881              		mov	r3, #255
 882              		str	r3, [r2, #8]
 883 06ac 030051E1 	.L169:
 884 06b0 F4FFFF1A 		.loc 1 297 0
 885              		ldr	r2, .L188+20
 886              		ldr	r3, [r2, #4]
 887              		tst	r3, #128
 888 06b4 FF30A0E3 		beq	.L169
 889 06b8 083082E5 	.LBE47:
 890              	.LBE46:
 891              	.LBB48:
 892 06bc A8209FE5 	.LBB49:
 893 06c0 043092E5 		.loc 1 295 0
 894 06c4 800013E3 		mov	r3, #255
 895 06c8 FBFFFF0A 		str	r3, [r2, #8]
 896              	.L171:
 897              		.loc 1 297 0
 898              		ldr	r3, .L188+20
 899              		ldr	r3, [r3, #4]
 900              		tst	r3, #128
 901 06cc FF30A0E3 		beq	.L171
 902 06d0 083082E5 	.L176:
 903              	.LBE49:
 904              	.LBE48:
 905 06d4 90309FE5 		.loc 1 698 0
 906 06d8 043093E5 		bl	sd_raw_rec_byte
 907 06dc 800013E3 		cmp	r0, #255
 908 06e0 FBFFFF0A 		bne	.L176
 909              		.loc 1 699 0
 910              		bl	sd_raw_rec_byte
 911              		.loc 1 702 0
 912              		ldr	r2, .L188+16
 913 06e4 54FEFFEB 		ldr	r3, [r2, #4]
 914 06e8 FF0050E3 		orr	r3, r3, #128
 915 06ec FCFFFF1A 		str	r3, [r2, #4]
 916              		.loc 1 708 0
 917 06f0 51FEFFEB 		ldr	r3, .L188+4
 918              		.loc 1 704 0
 919 06f4 6C209FE5 		rsb	r1, r6, r7
 920 06f8 043092E5 		.loc 1 708 0
 921 06fc 803083E3 		mov	r2, #1
 922 0700 043082E5 		.loc 1 704 0
 923              		mov	r1, r1, asl #16
 924 0704 50309FE5 		.loc 1 708 0
 925              		strb	r2, [r3, #0]
 926 0708 071066E0 		.loc 1 705 0
 927              		add	sl, sl, r6
 928 070c 0120A0E3 		.loc 1 672 0
 929              		add	r8, r8, r6
 930 0710 0118A0E1 		.loc 1 704 0
 931              		mov	r7, r1, lsr #16
 932 0714 0020C3E5 	.LVL73:
 933              	.L148:
 934 0718 06A08AE0 	.LBE39:
 935              		.loc 1 630 0
 936 071c 068088E0 		cmp	r7, #0
 937              		bne	.L149
 938 0720 2178A0E1 		b	.L159
 939              	.LVL74:
 940              	.L154:
 941              		mov	r0, #0
 942              		b	.L162
 943 0724 000057E3 	.LVL75:
 944 0728 93FFFF1A 	.L175:
 945 072c 060000EA 	.LBB50:
 946              		.loc 1 680 0
 947              		ldr	r3, [r4, #4]
 948 0730 0000A0E3 		mov	r0, #0
 949 0734 050000EA 		orr	r3, r3, #128
 950              		str	r3, [r4, #4]
 951              		b	.L162
 952              	.LVL76:
 953              	.L159:
 954 0738 043094E5 	.LBE50:
 955 073c 0000A0E3 		.loc 1 630 0
 956 0740 803083E3 		mov	r0, #1
 957 0744 043084E5 	.L162:
 958 0748 000000EA 		.loc 1 716 0
 959              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 960              		bx	lr
 961              	.L189:
 962              		.align	2
 963 074c 0100A0E3 	.L188:
 964              		.word	raw_block_address
 965              		.word	raw_block_written
 966 0750 F047BDE8 		.word	raw_block
 967 0754 1EFF2FE1 		.word	511
 968              		.word	-536707072
 969              		.word	-536739840
 970              		.word	raw_block+1
 971 0758 00020000 		.word	raw_block+513
 972 075c 04020000 	.LFE10:
 974 0764 FF010000 		.align	2
 975 0768 008002E0 		.global	sd_raw_sync
 977 0770 01000000 	sd_raw_sync:
 978 0774 01020000 	.LFB11:
 979              		.loc 1 731 0
 980              		@ Function supports interworking.
 981              		@ args = 0, pretend = 0, frame = 0
 982              		@ frame_needed = 0, uses_anonymous_args = 0
 983              		str	lr, [sp, #-4]!
 984              	.LCFI4:
 985              		.loc 1 734 0
 986              		ldr	r3, .L195
 987              		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 988              		cmp	r3, #0
 989              		.loc 1 736 0
 990 0778 04E02DE5 		ldr	r1, .L195+4
 991              		mov	r2, #512
 992              		.loc 1 734 0
 993 077c 30309FE5 		mov	r0, #1
 994 0780 0030D3E5 		bne	.L193
 995 0784 000053E3 		.loc 1 736 0
 996              		ldr	r3, .L195+8
 997 0788 28109FE5 		ldr	r0, [r3, #0]
 998 078c 022CA0E3 		bl	sd_raw_write
 999              		subs	r0, r0, #0
 1000 0790 0100A0E3 		movne	r0, #1
 1001 0794 0400001A 	.L193:
 1002              		.loc 1 743 0
 1003 0798 1C309FE5 		ldr	lr, [sp], #4
 1004 079c 000093E5 		bx	lr
 1005 07a0 FEFFFFEB 	.L196:
 1006 07a4 000050E2 		.align	2
 1007 07a8 0100A013 	.L195:
 1008              		.word	raw_block_written
 1009              		.word	raw_block
 1010 07ac 04E09DE4 		.word	raw_block_address
 1011 07b0 1EFF2FE1 	.LFE11:
 1013              		.align	2
 1014              		.global	sd_raw_read_interval
 1016 07b8 00000000 	sd_raw_read_interval:
 1017 07bc 00020000 	.LFB9:
 1018              		.loc 1 511 0
 1019              		@ Function supports interworking.
 1020              		@ args = 8, pretend = 0, frame = 0
 1021              		@ frame_needed = 0, uses_anonymous_args = 0
 1022              	.LVL77:
 1023              		mov	r2, r2, asl #16
 1024              	.LVL78:
 1025              		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1026              	.LCFI5:
 1027              		.loc 1 511 0
 1028              		mov	r3, r3, asl #16
 1029              	.LVL79:
 1030 07c0 0228A0E1 		.loc 1 512 0
 1031              		cmp	r2, #0
 1032 07c4 F0452DE9 		cmpne	r1, #0
 1033              		mov	r7, r1
 1034              		.loc 1 511 0
 1035 07c8 0338A0E1 		mov	r6, r0
 1036              		mov	r5, r3, lsr #16
 1037              	.LVL80:
 1038 07cc 000052E3 		add	r8, sp, #28
 1039 07d0 00005113 		ldmia	r8, {r8, sl}	@ phole ldm
 1040 07d4 0170A0E1 		.loc 1 512 0
 1041              		mov	r4, r2, lsr #16
 1042 07d8 0060A0E1 	.LVL81:
 1043 07dc 2358A0E1 		beq	.L198
 1044              	.LVL82:
 1045 07e0 1C808DE2 		rsbs	r3, r8, #1
 1046 07e4 000598E8 		movcc	r3, #0
 1047              		cmp	r5, r4
 1048 07e8 2248A0E1 		orrcc	r3, r3, #1
 1049              		cmp	r3, #0
 1050 07ec 1A00000A 		beq	.L207
 1051              		b	.L198
 1052 07f0 013078E2 	.LVL83:
 1053 07f4 0030A033 	.L201:
 1054 07f8 040055E1 		.loc 1 521 0
 1055 07fc 01308333 		bl	sd_raw_read
 1056 0800 000053E3 	.LVL84:
 1057 0804 0E00000A 		cmp	r0, #0
 1058 0808 130000EA 		.loc 1 523 0
 1059              		mov	r1, r6
 1060              		mov	r2, sl
 1061              		mov	r0, r7
 1062 080c FEFFFFEB 		.loc 1 524 0
 1063              		add	r6, r6, r4
 1064 0810 000050E3 		.loc 1 521 0
 1065              		beq	.L198
 1066 0814 0610A0E1 	.LVL85:
 1067 0818 0A20A0E1 		.loc 1 523 0
 1068 081c 0700A0E1 		mov	lr, pc
 1069              		bx	r8
 1070 0820 046086E0 	.LVL86:
 1071              		cmp	r0, #0
 1072 0824 0C00000A 		beq	.L203
 1073              		.loc 1 526 0
 1074              		rsb	r3, r4, r5
 1075 0828 0FE0A0E1 		mov	r3, r3, asl #16
 1076 082c 18FF2FE1 		mov	r5, r3, lsr #16
 1077              	.LVL87:
 1078 0830 000050E3 	.L207:
 1079 0834 0A00000A 		.loc 1 516 0
 1080              		cmp	r5, r4
 1081 0838 053064E0 		.loc 1 521 0
 1082 083c 0338A0E1 		mov	r0, r6
 1083 0840 2358A0E1 		mov	r1, r7
 1084              		mov	r2, r4
 1085              		.loc 1 516 0
 1086              		bcs	.L201
 1087 0844 040055E1 	.LVL88:
 1088              		b	.L203
 1089 0848 0600A0E1 	.LVL89:
 1090 084c 0710A0E1 	.L198:
 1091 0850 0420A0E1 		mov	r0, #0
 1092              		b	.L205
 1093 0854 ECFFFF2A 	.LVL90:
 1094              	.L203:
 1095 0858 010000EA 		mov	r0, #1
 1096              	.LVL91:
 1097              	.L205:
 1098 085c 0000A0E3 		.loc 1 604 0
 1099 0860 000000EA 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 1100              		bx	lr
 1101              	.LFE9:
 1103              		.section	.rodata.str1.4,"aMS",%progbits,1
 1104              		.align	2
 1105              	.LC0:
 1106 0868 F045BDE8 		.ascii	"SD RAW NOT AVAILABLE\012\015\000"
 1107 086c 1EFF2FE1 		.align	2
 1108              	.LC1:
 1109              		.ascii	"\012\015response: %d\012\015\000"
 1110              		.align	2
 1111              	.LC2:
 1112              		.ascii	"i = 0x7fff\012\015\000"
 1113 0000 53442052 		.align	2
 1113      4157204E 
 1113      4F542041 
 1113      5641494C 
 1113      41424C45 
 1114 0017 00       	.LC3:
 1115              		.ascii	"BLOCK SIZE SET ERR \012\015\000"
 1116 0018 0A0D7265 		.align	2
 1116      73706F6E 
 1116      73653A20 
 1116      25640A0D 
 1116      00
 1117 0029 000000   	.LC4:
 1118              		.ascii	"sd_raw_read borks\012\015\000"
 1119 002c 69203D20 		.text
 1119      30783766 
 1119      66660A0D 
 1119      00
 1120 0039 000000   		.align	2
 1121              		.global	sd_raw_init
 1123 0052 0000     	sd_raw_init:
 1124              	.LFB2:
 1125 0054 73645F72 		.loc 1 159 0
 1125      61775F72 
 1125      65616420 
 1125      626F726B 
 1125      730A0D00 
 1126              		@ Function supports interworking.
 1127              		@ args = 0, pretend = 0, frame = 0
 1128              		@ frame_needed = 0, uses_anonymous_args = 0
 1129              		stmfd	sp!, {r4, r5, lr}
 1130              	.LCFI6:
 1131              		.loc 1 165 0
 1132              		ldr	r4, .L235
 1133              		ldr	r3, [r4, #8]
 1134              		orr	r3, r3, #128
 1135              		str	r3, [r4, #8]
 1136 0870 30402DE9 		.loc 1 166 0
 1137              		ldr	r2, .L235+4
 1138              		ldr	r3, [r2, #0]
 1139 0874 E0419FE5 		orr	r3, r3, #4096
 1140 0878 083094E5 		str	r3, [r2, #0]
 1141 087c 803083E3 		.loc 1 167 0
 1142 0880 083084E5 		ldr	r3, [r2, #0]
 1143              		orr	r3, r3, #1024
 1144 0884 D4219FE5 		str	r3, [r2, #0]
 1145 0888 003092E5 		.loc 1 168 0
 1146 088c 013A83E3 		ldr	r3, [r2, #0]
 1147 0890 003082E5 		orr	r3, r3, #256
 1148              		str	r3, [r2, #0]
 1149 0894 003092E5 		.loc 1 170 0
 1150 0898 013B83E3 		ldr	r3, [r4, #4]
 1151 089c 003082E5 		orr	r3, r3, #128
 1152              		str	r3, [r4, #4]
 1153 08a0 003092E5 		.loc 1 173 0
 1154 08a4 013C83E3 		sub	r2, r2, #49152
 1155 08a8 003082E5 		mov	r3, #150
 1156              		str	r3, [r2, #12]
 1157 08ac 043094E5 		.loc 1 174 0
 1158 08b0 803083E3 		mov	r3, #56
 1159 08b4 043084E5 		str	r3, [r2, #0]
 1160              		.loc 1 179 0
 1161 08b8 032942E2 		bl	sd_raw_available
 1162 08bc 9630A0E3 		subs	r5, r0, #0
 1163 08c0 0C3082E5 		bne	.L209
 1164              		.loc 1 181 0
 1165 08c4 3830A0E3 		ldr	r0, .L235+8
 1166 08c8 003082E5 		bl	rprintf
 1167              		b	.L233
 1168 08cc FEFFFFEB 	.L209:
 1169 08d0 005050E2 		.loc 1 184 0
 1170 08d4 0200001A 		ldr	r3, [r4, #8]
 1171              		orr	r3, r3, #128
 1172 08d8 84019FE5 		str	r3, [r4, #8]
 1173 08dc FEFFFFEB 		.loc 1 185 0
 1174 08e0 450000EA 		ldr	r3, [r4, #4]
 1175              		orr	r3, r3, #128
 1176              		str	r3, [r4, #4]
 1177 08e4 083094E5 		mov	r4, #0
 1178 08e8 803083E3 	.LVL92:
 1179 08ec 083084E5 	.L212:
 1180              		.loc 1 192 0
 1181 08f0 043094E5 		bl	sd_raw_rec_byte
 1182 08f4 803083E3 		.loc 1 189 0
 1183 08f8 043084E5 		add	r3, r4, #1
 1184 08fc 0040A0E3 		mov	r3, r3, asl #16
 1185              		mov	r4, r3, lsr #16
 1186              		cmp	r4, #10
 1187              		bne	.L212
 1188 0900 CDFDFFEB 		.loc 1 196 0
 1189              		ldr	r2, .L235
 1190 0904 013084E2 		ldr	r3, [r2, #12]
 1191 0908 0338A0E1 		orr	r3, r3, #128
 1192 090c 2348A0E1 		str	r3, [r2, #12]
 1193 0910 0A0054E3 		mov	r4, #0
 1194 0914 F9FFFF1A 	.LVL93:
 1195              	.L214:
 1196 0918 3C219FE5 		.loc 1 202 0
 1197 091c 0C3092E5 		mov	r0, #0
 1198 0920 803083E3 		mov	r1, r0
 1199 0924 0C3082E5 		bl	sd_raw_send_command_r1
 1200 0928 0040A0E3 		.loc 1 200 0
 1201              		add	r3, r4, #1
 1202              		.loc 1 203 0
 1203              		cmp	r0, #1
 1204 092c 0000A0E3 		.loc 1 200 0
 1205 0930 0010A0E1 		mov	r2, r3, asl #16
 1206 0934 CBFDFFEB 		.loc 1 203 0
 1207              		beq	.L215
 1208 0938 013084E2 		.loc 1 206 0
 1209              		ldr	r3, .L235+12
 1210 093c 010050E3 		cmp	r4, r3
 1211              		.loc 1 200 0
 1212 0940 0328A0E1 		mov	r4, r2, lsr #16
 1213              		.loc 1 206 0
 1214 0944 0400000A 		beq	.L229
 1215              		b	.L214
 1216 0948 18319FE5 	.L215:
 1217 094c 030054E1 		.loc 1 212 0
 1218              		mov	r4, #0
 1219 0950 2248A0E1 	.LVL94:
 1220              	.L219:
 1221 0954 2A00000A 		.loc 1 217 0
 1222 0958 F3FFFFEA 		mov	r1, #0
 1223              		mov	r0, #1
 1224              		bl	sd_raw_send_command_r1
 1225 095c 0040A0E3 		.loc 1 215 0
 1226              		add	r3, r4, #1
 1227              		.loc 1 218 0
 1228              		tst	r0, #1
 1229 0960 0010A0E3 		.loc 1 215 0
 1230 0964 0100A0E3 		mov	r2, r3, asl #16
 1231 0968 BEFDFFEB 		.loc 1 218 0
 1232              		beq	.L220
 1233 096c 013084E2 		.loc 1 221 0
 1234              		ldr	r3, .L235+16
 1235 0970 010010E3 		cmp	r4, r3
 1236              		.loc 1 215 0
 1237 0974 0328A0E1 		mov	r4, r2, lsr #16
 1238              		.loc 1 221 0
 1239 0978 0400000A 		beq	.L230
 1240              		b	.L219
 1241 097c E8309FE5 	.L220:
 1242 0980 030054E1 		.loc 1 230 0
 1243              		mov	r0, #16
 1244 0984 2248A0E1 		mov	r1, #512
 1245              		bl	sd_raw_send_command_r1
 1246 0988 2600000A 		cmp	r0, #0
 1247 098c F3FFFFEA 		.loc 1 232 0
 1248              		ldrne	r2, .L235
 1249              		ldrne	r3, [r2, #4]
 1250 0990 1000A0E3 		.loc 1 233 0
 1251 0994 021CA0E3 		ldrne	r0, .L235+20
 1252 0998 B2FDFFEB 		.loc 1 232 0
 1253 099c 000050E3 		orrne	r3, r3, #128
 1254              		bne	.L234
 1255 09a0 B4209F15 	.L224:
 1256 09a4 04309215 		.loc 1 238 0
 1257              		ldr	ip, .L235
 1258 09a8 C0009F15 		ldr	r3, [ip, #4]
 1259              		orr	r3, r3, #128
 1260 09ac 80308313 		str	r3, [ip, #4]
 1261 09b0 2000001A 		.loc 1 245 0
 1262              		ldr	r3, .L235+24
 1263              		mvn	ip, #0
 1264 09b4 A0C09FE5 		str	ip, [r3, #0]
 1265 09b8 04309CE5 		.loc 1 241 0
 1266 09bc 803083E3 		ldr	r3, .L235+28
 1267 09c0 04308CE5 		add	ip, ip, #61
 1268              		str	ip, [r3, #12]
 1269 09c4 A8309FE5 		.loc 1 247 0
 1270 09c8 00C0E0E3 		ldr	r3, .L235+32
 1271 09cc 00C083E5 		mov	r5, #1
 1272              		.loc 1 249 0
 1273 09d0 A0309FE5 		ldr	r1, .L235+36
 1274 09d4 3DC08CE2 		mov	r2, #512
 1275 09d8 0CC083E5 		.loc 1 247 0
 1276              		strb	r5, [r3, #0]
 1277 09dc 98309FE5 		.loc 1 249 0
 1278 09e0 0150A0E3 		bl	sd_raw_read
 1279              		subs	r4, r0, #0
 1280 09e4 94109FE5 	.LVL95:
 1281 09e8 022CA0E3 		beq	.L226
 1282              	.L233:
 1283 09ec 0050C3E5 		mov	r0, r5
 1284              		b	.L211
 1285 09f0 FEFFFFEB 	.LVL96:
 1286 09f4 004050E2 	.L229:
 1287              		.loc 1 208 0
 1288 09f8 1200000A 		mov	r1, r0
 1289              	.LVL97:
 1290 09fc 0500A0E1 		ldr	r0, .L235+40
 1291 0a00 130000EA 		bl	rprintf
 1292              	.LVL98:
 1293              		.loc 1 209 0
 1294              		ldr	r2, .L235
 1295 0a04 0010A0E1 		ldr	r3, [r2, #4]
 1296              		mov	r0, #0
 1297 0a08 74009FE5 		orr	r3, r3, #128
 1298 0a0c FEFFFFEB 		str	r3, [r2, #4]
 1299              		b	.L211
 1300              	.LVL99:
 1301 0a10 44209FE5 	.L230:
 1302 0a14 043092E5 		.loc 1 223 0
 1303 0a18 0000A0E3 		ldr	r2, .L235
 1304 0a1c 803083E3 		ldr	r3, [r2, #4]
 1305 0a20 043082E5 		.loc 1 224 0
 1306 0a24 0A0000EA 		ldr	r0, .L235+44
 1307              		.loc 1 223 0
 1308              		orr	r3, r3, #128
 1309              	.L234:
 1310 0a28 2C209FE5 		str	r3, [r2, #4]
 1311 0a2c 043092E5 		.loc 1 224 0
 1312              		bl	rprintf
 1313 0a30 50009FE5 		mov	r0, #0
 1314              		b	.L211
 1315 0a34 803083E3 	.LVL100:
 1316              	.L226:
 1317 0a38 043082E5 		.loc 1 251 0
 1318              		ldr	r0, .L235+48
 1319 0a3c FEFFFFEB 		bl	rprintf
 1320 0a40 0000A0E3 		mov	r0, r4
 1321 0a44 020000EA 	.LVL101:
 1322              	.L211:
 1323              		.loc 1 257 0
 1324              		ldmfd	sp!, {r4, r5, lr}
 1325 0a48 3C009FE5 		bx	lr
 1326 0a4c FEFFFFEB 	.L236:
 1327 0a50 0400A0E1 		.align	2
 1328              	.L235:
 1329              		.word	-536707072
 1330              		.word	-536690688
 1331 0a54 3040BDE8 		.word	.LC0
 1332 0a58 1EFF2FE1 		.word	511
 1333              		.word	32767
 1334              		.word	.LC3
 1335              		.word	raw_block_address
 1336 0a5c 008002E0 		.word	-536739840
 1337 0a60 00C002E0 		.word	raw_block_written
 1338 0a64 00000000 		.word	raw_block
 1339 0a68 FF010000 		.word	.LC1
 1340 0a6c FF7F0000 		.word	.LC2
 1341 0a70 3C000000 		.word	.LC4
 1342 0a74 00020000 	.LFE2:
 1344 0a7c 04020000 		.align	2
 1345 0a80 00000000 		.global	format_card
 1347 0a88 2C000000 	format_card:
 1348 0a8c 54000000 	.LFB14:
 1349              		.loc 1 883 0
 1350              		@ Function supports interworking.
 1351              		@ args = 0, pretend = 0, frame = 512
 1352              		@ frame_needed = 0, uses_anonymous_args = 0
 1353              	.LVL102:
 1354              		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1355              	.LCFI7:
 877:../lib/sd_raw.c ****  pass this fuction 0xAA to get it to work (safety check)
 878:../lib/sd_raw.c **** char format_card(char make_sure)
 879:../lib/sd_raw.c **** {
 880:../lib/sd_raw.c **** 	#define MBR_LOCATION	0x00
 881:../lib/sd_raw.c **** 	#define BR_LOCATION		(MBR_LOCATION+0x80000)
 882:../lib/sd_raw.c **** 	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
 883:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 1356              	loc 1 897 0
 1357              		bl	sd_raw_init
 1358              		.loc 1 900 0
 1359              		bl	sd_raw_sync
 1360              		.loc 1 901 0
 1361 0a90 F0472DE9 		mov	r2, r4
 1362              		mov	r1, sp
 1363 0a94 FF0000E2 		mov	r0, r6
 884:../lib/sd_raw.c **** 0x200 * 512))
 885:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 886:../lib/sd_raw.c **** 
 887:../lib/sd_raw.c **** 	//Safety check
 888:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 889:../lib/sd_raw.c **** 	
 890:../lib/sd_raw.c **** 	int i;
 1364              	aw_write
 1365 0a98 AA0050E3 		.loc 1 904 0
 1366              		bl	sd_raw_sync
 1367 0a9c 02DC4DE2 		.loc 1 905 0
 1368              		mov	r2, r4
 1369              		mov	r1, sp
 1370 0aa0 0000A013 		mov	r0, #524288
 1371              		bl	sd_raw_write
 1372 0aa4 6D00001A 		mov	r4, #786432
 1373 0aa8 0040A0E3 	.LVL105:
 1374              	.L243:
 1375              		.loc 1 910 0
 891:../lib/sd_raw.c **** 0x00F5 * 2 * 512))
 892:../lib/sd_raw.c **** 
 893:../lib/sd_raw.c **** 	//Safety check
 894:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 1376              	ync
 1377 0aac 0060A0E3 		.loc 1 911 0
 1378 0ab0 0D60C4E7 		mov	r0, r4
 1379 0ab4 014084E2 		mov	r1, sp
 1380 0ab8 020C54E3 		mov	r2, #512
 1381 0abc FAFFFF1A 		bl	sd_raw_write
 895:../lib/sd_raw.c **** 0 * 512) + (0x00F5 * 2 * 512))
 896:../lib/sd_raw.c **** 
 897:../lib/sd_raw.c **** 	//Safety check
 1382              	1 908 0
 1383 0ac0 FEFFFFEB 		ldr	r3, .L250
 898:../lib/sd_raw.c **** ine ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 899:../lib/sd_raw.c **** 
 900:../lib/sd_raw.c **** 	//Safety check
 1384              	loc 1 911 0
 1385 0ac4 FEFFFFEB 		add	r4, r4, #512
 901:../lib/sd_raw.c **** ine ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 1386              	loc 1 908 0
 1387 0ac8 0420A0E1 		cmp	r4, r3
 1388 0acc 0D10A0E1 		.loc 1 911 0
 1389 0ad0 0600A0E1 		mov	r9, sp
 1390 0ad4 FEFFFFEB 		.loc 1 908 0
 902:../lib/sd_raw.c **** 0x200 * 512))
 903:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 904:../lib/sd_raw.c **** 
 1391              	.L243
 1392 0ad8 FEFFFFEB 		.loc 1 920 0
 905:../lib/sd_raw.c **** 200 * 512))
 1393              	ov	r3, #6
 1394 0adc 0420A0E1 		strb	r3, [sp, #450]
 1395 0ae0 0D10A0E1 		.loc 1 921 0
 1396 0ae4 0207A0E3 		add	r3, r3, #25
 1397 0ae8 FEFFFFEB 		strb	r3, [sp, #451]
 1398 0aec 0347A0E3 		.loc 1 922 0
 1399              		mvn	r3, #31
 1400              		.loc 1 916 0
 906:../lib/sd_raw.c **** BR_LOCATION		(MBR_LOCATION+0x80000)
 907:../lib/sd_raw.c **** 	#define FAT_TABLE		(BR_LOCATION + (0x200 * 512))
 908:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 909:../lib/sd_raw.c **** 
 910:../lib/sd_raw.c **** 	//Safety check
 1401              	 #0
 1402 0af0 FEFFFFEB 		.loc 1 918 0
 911:../lib/sd_raw.c **** ine ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 1403              	ov	r2, #1
 1404 0af4 0400A0E1 		.loc 1 931 0
 1405 0af8 0D10A0E1 		mov	r5, #85
 1406 0afc 022CA0E3 		.loc 1 925 0
 1407 0b00 FEFFFFEB 		mov	r6, #4
 1408              		.loc 1 929 0
 1409 0b04 60319FE5 		mov	r7, #76
 1410              		.loc 1 930 0
 1411 0b08 024C84E2 		mov	r8, #15
 1412              		.loc 1 932 0
 1413 0b0c 030054E1 		mvn	sl, #85
 1414              		.loc 1 922 0
 1415 0b10 0D90A0E1 		strb	r3, [sp, #452]
 1416              		.loc 1 923 0
 1417 0b14 F5FFFF1A 		mvn	r3, #44
 912:../lib/sd_raw.c **** 0x200 * 512))
 913:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 914:../lib/sd_raw.c **** 
 915:../lib/sd_raw.c **** 	//Safety check
 916:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 917:../lib/sd_raw.c **** 	
 918:../lib/sd_raw.c **** 	int i;
 919:../lib/sd_raw.c **** 	unsigned char my_buff[512];
 920:../lib/sd_raw.c **** 	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
 1418              	#453]
 1419 0b18 0630A0E3 		.loc 1 919 0
 1420 0b1c C231CDE5 		strb	r2, [sp, #449]
 921:../lib/sd_raw.c **** ;
 1421              	oc 1 918 0
 1422 0b20 193083E2 		strb	r2, [sp, #448]
 1423 0b24 C331CDE5 		.loc 1 916 0
 922:../lib/sd_raw.c **** 0x00F5 * 2 * 512))
 1424              	rb	r4, [sp, #446]
 1425 0b28 1F30E0E3 		.loc 1 917 0
 1426              		strb	r4, [sp, #447]
 1427 0b2c 0040A0E3 		.loc 1 924 0
 1428              		strb	r4, [sp, #454]
 1429 0b30 0120A0E3 		.loc 1 925 0
 923:../lib/sd_raw.c **** 0x200 * 512))
 924:../lib/sd_raw.c **** 	#define ROOT_DIR		(BR_LOCATION + (0x0200 * 512) + (0x00F5 * 2 * 512))
 925:../lib/sd_raw.c **** 
 926:../lib/sd_raw.c **** 	//Safety check
 927:../lib/sd_raw.c **** 	if (make_sure != 0xAA) return 0;
 928:../lib/sd_raw.c **** 	
 929:../lib/sd_raw.c **** 	int i;
 930:../lib/sd_raw.c **** 	unsigned char my_buff[512];
 931:../lib/sd_raw.c **** 	for(i = 0 ; i < 512 ; i++) my_buff[i] = 0x00;
 1430              	r6, [sp, #455]
 1431 0b34 5550A0E3 		.loc 1 926 0
 1432              		strb	r4, [sp, #456]
 1433 0b38 0460A0E3 		.loc 1 927 0
 1434              		strb	r4, [sp, #457]
 1435 0b3c 4C70A0E3 		.loc 1 928 0
 1436              		strb	r4, [sp, #458]
 1437 0b40 0F80A0E3 		.loc 1 929 0
 932:../lib/sd_raw.c **** ;
 1438              	, [sp, #459]
 1439 0b44 55A0E0E3 		.loc 1 930 0
 1440              		strb	r8, [sp, #460]
 1441 0b48 C431CDE5 		.loc 1 931 0
 1442              		strb	r5, [sp, #510]
 1443 0b4c 2C30E0E3 		.loc 1 932 0
 1444 0b50 C531CDE5 		strb	sl, [sp, #511]
 1445              		.loc 1 934 0
 1446 0b54 C121CDE5 		bl	sd_raw_sync
 1447              		.loc 1 935 0
 1448 0b58 C021CDE5 		mov	r1, sp
 1449              		mov	r2, #512
 1450 0b5c BE41CDE5 		mov	r0, r4
 1451              		bl	sd_raw_write
 1452 0b60 BF41CDE5 		.loc 1 936 0
 1453              		bl	sd_raw_sync
 1454 0b64 C641CDE5 		.loc 1 940 0
 1455              		mvn	r3, #20
 1456 0b68 C761CDE5 		strb	r3, [sp, #0]
 1457              		.loc 1 941 0
 1458 0b6c C841CDE5 		add	r3, r3, #19
 1459              		strb	r3, [sp, #1]
 1460 0b70 C941CDE5 		.loc 1 942 0
 1461              		mvn	r3, #111
 1462 0b74 CA41CDE5 		strb	r3, [sp, #2]
 1463              		.loc 1 944 0
 1464 0b78 CB71CDE5 		add	r3, r3, #128
 1465              		strb	r3, [sp, #13]
 1466 0b7c CC81CDE5 		.loc 1 945 0
 1467              		add	r3, r3, #6
 1468 0b80 FE51CDE5 		strb	r3, [sp, #14]
 1469              		.loc 1 948 0
 1470 0b84 FFA1CDE5 		mvn	r3, #7
 933:../lib/sd_raw.c **** 0x00F5 * 2 * 512))
 934:../lib/sd_raw.c **** 
 1471              	
 1472 0b88 FEFFFFEB 		mvn	r3, #10
 935:../lib/sd_raw.c **** 200 * 512))
 1473              	strb	r3, [sp, #22]
 1474 0b8c 0D10A0E1 		.loc 1 955 0
 1475 0b90 022CA0E3 		add	r3, r3, #52
 1476 0b94 0400A0E1 		strb	r3, [sp, #38]
 1477 0b98 FEFFFFEB 		.loc 1 956 0
 936:../lib/sd_raw.c **** BR_LOCATION		(MBR_LOCATION+0x80000)
 1478              	r3, r3, #29
 1479 0b9c FEFFFFEB 		strb	r3, [sp, #54]
 937:../lib/sd_raw.c **** r make_sure)
 938:../lib/sd_raw.c **** {
 939:../lib/sd_raw.c **** 	#define MBR_LOCATION	0x00
 940:../lib/sd_raw.c **** 	#define BR_LOCATION		(MBR_LOCATION+0x80000)
 1480              	loc 1 957 0
 1481 0ba0 1430E0E3 		mov	r3, #65
 1482 0ba4 0030CDE5 		strb	r3, [sp, #55]
 941:../lib/sd_raw.c **** r make_sure)
 1483              	oc 1 958 0
 1484 0ba8 133083E2 		add	r3, r3, #19
 1485 0bac 0130CDE5 		strb	r3, [sp, #56]
 942:../lib/sd_raw.c ****  pass this fuction 0xAA to get it to work (safety check)
 1486              	oc 1 959 0
 1487 0bb0 6F30E0E3 		mov	r3, #49
 1488 0bb4 0230CDE5 		.loc 1 950 0
 943:../lib/sd_raw.c **** //Assumes *many* things
 944:../lib/sd_raw.c **** //You must pass this fuction 0xAA to get it to work (safety check)
 1489              	v	r2, #32
 1490 0bb8 803083E2 		.loc 1 943 0
 1491 0bbc 0D30CDE5 		mov	r1, #2
 945:../lib/sd_raw.c **** //Assumes *many* things
 1492              	oc 1 959 0
 1493 0bc0 063083E2 		strb	r3, [sp, #57]
 1494 0bc4 0E30CDE5 		.loc 1 960 0
 946:../lib/sd_raw.c ****  &= ~(0x1500);
 947:../lib/sd_raw.c **** }
 948:../lib/sd_raw.c **** 
 1495              	d	r3, r3, #5
 1496 0bc8 0730E0E3 		strb	r3, [sp, #58]
 1497 0bcc 1530CDE5 		.loc 1 947 0
 949:../lib/sd_raw.c **** rn 1;
 1498              	rb	r1, [sp, #18]
 1499 0bd0 0A30E0E3 		.loc 1 963 0
 1500 0bd4 1630CDE5 		strb	r2, [sp, #61]
 950:../lib/sd_raw.c **** >format = (b & 0x0c) >> 2;
 951:../lib/sd_raw.c ****                 break;
 952:../lib/sd_raw.c ****         }
 953:../lib/sd_raw.c ****     }
 954:../lib/sd_raw.c **** 
 955:../lib/sd_raw.c ****     unselect_card();
 1501              	oc 1 943 0
 1502 0bd8 343083E2 		strb	r1, [sp, #12]
 1503 0bdc 2630CDE5 		.loc 1 946 0
 956:../lib/sd_raw.c ****             info->format = (b & 0x0c) >> 2;
 1504              	rb	r1, [sp, #16]
 1505 0be0 1D3083E2 		.loc 1 950 0
 1506 0be4 3630CDE5 		strb	r2, [sp, #24]
 957:../lib/sd_raw.c ****  0x10)
 1507              	oc 1 951 0
 1508 0be8 4130A0E3 		strb	r2, [sp, #26]
 1509 0bec 3730CDE5 		.loc 1 961 0
 958:../lib/sd_raw.c ****  1;
 1510              	rb	r2, [sp, #59]
 1511 0bf0 133083E2 		.loc 1 962 0
 1512 0bf4 3830CDE5 		strb	r2, [sp, #60]
 959:../lib/sd_raw.c **** 
 1513              	oc 1 952 0
 1514 0bf8 3130A0E3 		strb	r6, [sp, #29]
 1515              		.loc 1 953 0
 1516 0bfc 2020A0E3 		strb	r7, [sp, #33]
 1517              		.loc 1 954 0
 1518 0c00 0210A0E3 		strb	r8, [sp, #34]
 1519              		.loc 1 965 0
 1520 0c04 3930CDE5 		strb	sl, [sp, #511]
 960:../lib/sd_raw.c **** lt |= b >> 7;
 1521              	964 0
 1522 0c08 053083E2 		strb	r5, [sp, #510]
 1523 0c0c 3A30CDE5 		.loc 1 967 0
 1524              		bl	sd_raw_sync
 1525 0c10 1210CDE5 		.loc 1 968 0
 961:../lib/sd_raw.c **** csd_c_size_mult = (b & 0x03) << 1;
 962:../lib/sd_raw.c ****                 break;
 963:../lib/sd_raw.c ****             case 10:
 1526              	r1, sp
 1527 0c14 3D20CDE5 		mov	r2, #512
 1528              		mov	r0, #524288
 1529 0c18 0C10CDE5 		bl	sd_raw_write
 1530              		.loc 1 969 0
 1531 0c1c 1010CDE5 		bl	sd_raw_sync
 1532              		mov	r0, r5
 1533 0c20 1820CDE5 	.L240:
 1534              		.loc 1 972 0
 1535 0c24 1A20CDE5 		add	sp, sp, #512
 1536              		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1537 0c28 3B20CDE5 		bx	lr
 1538              	.L251:
 1539 0c2c 3C20CDE5 		.align	2
 1540              	.L250:
 1541 0c30 1D60CDE5 		.word	911872
 1542              	.LFE14:
 1544              		.bss
 1545 0c38 2280CDE5 	raw_block:
 964:../lib/sd_raw.c ****  break;
 965:../lib/sd_raw.c ****             case 9:
 1546              	2
 1547 0c3c FFA1CDE5 	raw_block_address:
 1548              		.space	4
 1549 0c40 FE51CDE5 	raw_block_written:
 966:../lib/sd_raw.c ****        case 8:
 967:../lib/sd_raw.c ****                 csd_c_size |= b >> 6;
 1550              	ace	1
 1551 0c44 FEFFFFEB 		.section	.debug_frame,"",%progbits
 968:../lib/sd_raw.c **** _c_size |= b;
 1552              	frame0:
 1553 0c48 0D10A0E1 		.4byte	.LECIE0-.LSCIE0
 1554 0c4c 022CA0E3 	.LSCIE0:
 1555 0c50 0207A0E3 		.4byte	0xffffffff
 1556 0c54 FEFFFFEB 		.byte	0x1
 969:../lib/sd_raw.c ****           csd_c_size = (unsigned short) (b & 0x03) << 8;
 1557              	ii	"\000"
 1558 0c58 FEFFFFEB 		.uleb128 0x1
 1559 0c5c 0500A0E1 		.sleb128 -4
 1560              		.byte	0xe
 970:../lib/sd_raw.c ****   csd_read_bl_len = b & 0x0f;
 971:../lib/sd_raw.c ****                 break;
 972:../lib/sd_raw.c ****             case 6:
 1561              	te	0xc
 1562 0c60 02DC8DE2 		.uleb128 0xd
 1563 0c64 F047BDE8 		.uleb128 0x0
 1564 0c68 1EFF2FE1 		.align	2
 1565              	.LECIE0:
 1566              	.LSFDE0:
 1567              		.4byte	.LEFDE0-.LASFDE0
 1568 0c6c 00EA0D00 	.LASFDE0:
 1569              		.4byte	.Lframe0
 1570              		.4byte	.LFB3
 1571              		.4byte	.LFE3-.LFB3
 1572              		.align	2
 1573 0000 00000000 	.LEFDE0:
 1573      00000000 
 1573      00000000 
 1573      00000000 
 1573      00000000 
 1574              	.LSFDE2:
 1575              		.4byte	.LEFDE2-.LASFDE2
 1576 0200 00000000 	.LASFDE2:
 1577              		.4byte	.Lframe0
 1578 0204 00       		.4byte	.LFB4
 1816              		.4byte	.LVL1-.Ltext0
DEFINED SYMBOLS
                            *ABS*:00000000 sd_raw.c
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:13     .text:00000000 sd_raw_available
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:22     .text:00000000 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:44     .text:00000030 $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:50     .text:00000034 sd_raw_locked
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:58     .text:00000034 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:67     .text:0000003c sd_raw_rec_byte
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:94     .text:00000064 $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:99     .text:00000068 sd_raw_send_command_r1
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:106    .text:00000068 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:220    .text:00000144 $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:226    .text:00000148 SDoff
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:234    .text:00000148 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:251    .text:0000016c $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:257    .text:00000170 sd_raw_get_info
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:264    .text:00000170 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:318    .text:000001f4 $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:336    .text:00000230 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:438    .text:000002fc $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:451    .text:00000324 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:564    .text:00000400 $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:570    .text:00000404 sd_raw_read
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:577    .text:00000404 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:729    .text:00000564 sd_raw_write
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:718    .text:0000054c $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1575   .bss:00000200 raw_block_address
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1577   .bss:00000204 raw_block_written
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1572   .bss:00000000 raw_block
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:736    .text:00000564 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:971    .text:00000758 $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:984    .text:00000778 sd_raw_sync
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:990    .text:00000778 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1015   .text:000007b4 $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1023   .text:000007c0 sd_raw_read_interval
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1030   .text:000007c0 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1130   .text:00000870 sd_raw_init
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1336   .text:00000a5c $d
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1354   .text:00000a90 format_card
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1361   .text:00000a90 $a
C:\Users\nancyhd\AppData\Local\Temp/ccqsaaaa.s:1568   .text:00000c6c $d

UNDEFINED SYMBOLS
memset
memcpy
rprintf
