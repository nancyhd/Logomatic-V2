   1              		.file	"usbhw_lpc.c"
   9              	.Ltext0:
  10              		.align	2
  12              	USBHwCmd:
  13              	.LFB3:
  14              		.file 1 "../LPCUSB/usbhw_lpc.c"
   1:../LPCUSB/usbhw_lpc.c **** /*
   2:../LPCUSB/usbhw_lpc.c **** 	LPCUSB, an USB device driver for LPC microcontrollers	
   3:../LPCUSB/usbhw_lpc.c **** 	Copyright (C) 2006 Bertrik Sikken (bertrik@sikken.nl)
   4:../LPCUSB/usbhw_lpc.c **** 
   5:../LPCUSB/usbhw_lpc.c **** 	Redistribution and use in source and binary forms, with or without
   6:../LPCUSB/usbhw_lpc.c **** 	modification, are permitted provided that the following conditions are met:
   7:../LPCUSB/usbhw_lpc.c **** 
   8:../LPCUSB/usbhw_lpc.c **** 	1. Redistributions of source code must retain the above copyright
   9:../LPCUSB/usbhw_lpc.c **** 	   notice, this list of conditions and the following disclaimer.
  10:../LPCUSB/usbhw_lpc.c **** 	2. Redistributions in binary form must reproduce the above copyright
  11:../LPCUSB/usbhw_lpc.c **** 	   notice, this list of conditions and the following disclaimer in the
  12:../LPCUSB/usbhw_lpc.c **** 	   documentation and/or other materials provided with the distribution.
  13:../LPCUSB/usbhw_lpc.c **** 	3. The name of the author may not be used to endorse or promote products
  14:../LPCUSB/usbhw_lpc.c **** 	   derived from this software without specific prior written permission.
  15:../LPCUSB/usbhw_lpc.c **** 
  16:../LPCUSB/usbhw_lpc.c **** 	THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  17:../LPCUSB/usbhw_lpc.c **** 	IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  18:../LPCUSB/usbhw_lpc.c **** 	OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  19:../LPCUSB/usbhw_lpc.c **** 	IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, 
  20:../LPCUSB/usbhw_lpc.c **** 	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  21:../LPCUSB/usbhw_lpc.c **** 	NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  22:../LPCUSB/usbhw_lpc.c **** 	DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  23:../LPCUSB/usbhw_lpc.c **** 	THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24:../LPCUSB/usbhw_lpc.c **** 	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  25:../LPCUSB/usbhw_lpc.c **** 	THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26:../LPCUSB/usbhw_lpc.c **** */
  27:../LPCUSB/usbhw_lpc.c **** 
  28:../LPCUSB/usbhw_lpc.c **** 
  29:../LPCUSB/usbhw_lpc.c **** /** @file
  30:../LPCUSB/usbhw_lpc.c **** 	USB hardware layer
  31:../LPCUSB/usbhw_lpc.c ****  */
  32:../LPCUSB/usbhw_lpc.c **** 
  33:../LPCUSB/usbhw_lpc.c **** #include "type.h"
  34:../LPCUSB/usbhw_lpc.c **** #include "usbdebug.h"
  35:../LPCUSB/usbhw_lpc.c **** #include "usbhw_lpc.h"
  36:../LPCUSB/usbhw_lpc.c **** #include "usbapi.h"
  37:../LPCUSB/usbhw_lpc.c **** 
  38:../LPCUSB/usbhw_lpc.c **** #include "rprintf.h"
  39:../LPCUSB/usbhw_lpc.c **** 
  40:../LPCUSB/usbhw_lpc.c **** 
  41:../LPCUSB/usbhw_lpc.c **** #ifdef DEBUG
  42:../LPCUSB/usbhw_lpc.c **** // comment out the following line if you don't want to use debug LEDs
  43:../LPCUSB/usbhw_lpc.c **** //#define DEBUG_LED
  44:../LPCUSB/usbhw_lpc.c **** #endif
  45:../LPCUSB/usbhw_lpc.c **** 
  46:../LPCUSB/usbhw_lpc.c **** #ifdef DEBUG_LED
  47:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_ON(x)		IOCLR0 = (1 << x);
  48:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)	IOSET0 = (1 << x);
  49:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)	PINSEL0 &= ~(0x3 << (2*x)); IODIR0 |= (1 << x); DEBUG_LED_OFF(x);
  50:../LPCUSB/usbhw_lpc.c **** #else
  51:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_INIT(x)	/**< LED initialisation macro */
  52:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_ON(x)		/**< turn LED on */
  53:../LPCUSB/usbhw_lpc.c **** #define DEBUG_LED_OFF(x)	/**< turn LED off */
  54:../LPCUSB/usbhw_lpc.c **** #endif
  55:../LPCUSB/usbhw_lpc.c **** 
  56:../LPCUSB/usbhw_lpc.c **** /** Installed device interrupt handler */
  57:../LPCUSB/usbhw_lpc.c **** static TFnDevIntHandler *_pfnDevIntHandler = NULL;
  58:../LPCUSB/usbhw_lpc.c **** /** Installed endpoint interrupt handlers */
  59:../LPCUSB/usbhw_lpc.c **** static TFnEPIntHandler	*_apfnEPIntHandlers[16];
  60:../LPCUSB/usbhw_lpc.c **** /** Installed frame interrupt handlers */
  61:../LPCUSB/usbhw_lpc.c **** static TFnFrameHandler	*_pfnFrameHandler = NULL;
  62:../LPCUSB/usbhw_lpc.c **** 
  63:../LPCUSB/usbhw_lpc.c **** /** convert from endpoint address to endpoint index */
  64:../LPCUSB/usbhw_lpc.c **** #define EP2IDX(bEP)	((((bEP)&0xF)<<1)|(((bEP)&0x80)>>7))
  65:../LPCUSB/usbhw_lpc.c **** /** convert from endpoint index to endpoint address */
  66:../LPCUSB/usbhw_lpc.c **** #define IDX2EP(idx)	((((idx)<<7)&0x80)|(((idx)>>1)&0xF))
  67:../LPCUSB/usbhw_lpc.c **** 
  68:../LPCUSB/usbhw_lpc.c **** 
  69:../LPCUSB/usbhw_lpc.c **** 
  70:../LPCUSB/usbhw_lpc.c **** /**
  71:../LPCUSB/usbhw_lpc.c **** 	Local function to wait for a device interrupt (and clear it)
  72:../LPCUSB/usbhw_lpc.c **** 		
  73:../LPCUSB/usbhw_lpc.c **** 	@param [in]	dwIntr		Bitmask of interrupts to wait for	
  74:../LPCUSB/usbhw_lpc.c ****  */
  75:../LPCUSB/usbhw_lpc.c **** static void Wait4DevInt(U32 dwIntr)
  76:../LPCUSB/usbhw_lpc.c **** {
  77:../LPCUSB/usbhw_lpc.c **** 	// wait for specific interrupt
  78:../LPCUSB/usbhw_lpc.c **** 	while ((USBDevIntSt & dwIntr) != dwIntr);
  79:../LPCUSB/usbhw_lpc.c **** 	// clear the interrupt bits
  80:../LPCUSB/usbhw_lpc.c **** 	USBDevIntClr = dwIntr;
  81:../LPCUSB/usbhw_lpc.c **** }
  82:../LPCUSB/usbhw_lpc.c **** 
  83:../LPCUSB/usbhw_lpc.c **** 
  84:../LPCUSB/usbhw_lpc.c **** /**
  85:../LPCUSB/usbhw_lpc.c **** 	Local function to send a command to the USB protocol engine
  86:../LPCUSB/usbhw_lpc.c **** 		
  87:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bCmd		Command to send
  88:../LPCUSB/usbhw_lpc.c ****  */
  89:../LPCUSB/usbhw_lpc.c **** static void USBHwCmd(U8 bCmd)
  90:../LPCUSB/usbhw_lpc.c **** {
  15              	@ Function supports interworking.
  16              		@ args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		mov	r0, r0, asl #16
  21 0000 0008A0E1 		.loc 1 92 0
  91:../LPCUSB/usbhw_lpc.c **** e = 0x00000500 | (bCmd << 16);
  92:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(CCEMTY);
  22              	, .L7
  23 0004 2C209FE5 		.loc 1 94 0
  93:../LPCUSB/usbhw_lpc.c **** 
  94:../LPCUSB/usbhw_lpc.c **** 
  24              	nd	r0, r0, #16711680
  25 0008 FF0800E2 	.LVL1:
  26              		orr	r0, r0, #1280
  27 000c 050C80E3 		.loc 1 92 0
  28              		mov	r3, #48
  29 0010 3030A0E3 		str	r3, [r2, #8]
  30 0014 083082E5 		.loc 1 94 0
  31              		str	r0, [r2, #16]
  32 0018 100082E5 		.loc 1 90 0
  33              		@ lr needed for prologue
  34              	.L2:
  35              	.LBB10:
  36              	.LBB11:
  37              		.loc 1 78 0
  38              		ldr	r2, .L7
  39 001c 14209FE5 		ldr	r3, [r2, #0]
  40 0020 003092E5 		and	r3, r3, #16
  41 0024 103003E2 		cmp	r3, #16
  42 0028 100053E3 		bne	.L2
  43 002c FAFFFF1A 		.loc 1 80 0
  44              		str	r3, [r2, #8]
  45 0030 083082E5 	.LBE11:
  46              	.LBE10:
  47              		.loc 1 96 0
  95:../LPCUSB/usbhw_lpc.c **** **
  96:../LPCUSB/usbhw_lpc.c **** 	Local function to send a command + data to the USB protocol engine
  48              	7:
  49 0034 1EFF2FE1 		.word	-536281088
  50              	.LFE3:
  52              		.align	2
  54              	USBHwCmdWrite:
  55              	.LFB4:
  56              		.loc 1 106 0
  57              		@ Function supports interworking.
  58              		@ args = 0, pretend = 0, frame = 0
  59              		@ frame_needed = 0, uses_anonymous_args = 0
  97:../LPCUSB/usbhw_lpc.c **** 
  98:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bCmd		Command to send
  99:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bData		Data to send
 100:../LPCUSB/usbhw_lpc.c ****  */
 101:../LPCUSB/usbhw_lpc.c **** static void USBHwCmdWrite(U8 bCmd, U16 bData)
 102:../LPCUSB/usbhw_lpc.c **** {
 103:../LPCUSB/usbhw_lpc.c **** 	// write command code
 104:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(bCmd);
 105:../LPCUSB/usbhw_lpc.c **** 
 106:../LPCUSB/usbhw_lpc.c **** 	// write command data
  60              	d	sp!, {r4, lr}
  61              	.LCFI0:
  62              		.loc 1 106 0
  63              		mov	r4, r1, asl #16
  64              		and	r0, r0, #255
  65 003c 10402DE9 		mov	r4, r4, lsr #16
  66              		.loc 1 108 0
  67              		bl	USBHwCmd
  68 0040 0148A0E1 	.LVL3:
  69 0044 FF0000E2 		.loc 1 111 0
  70 0048 2448A0E1 		mov	r4, r4, asl #16
 107:../LPCUSB/usbhw_lpc.c **** de = 0x00000100 | (bData << 16);
 108:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(CCEMTY);
  71              		r3, .L15
  72 004c EBFFFFEB 		orr	r4, r4, #256
  73              		str	r4, [r3, #16]
 109:../LPCUSB/usbhw_lpc.c **** 
 110:../LPCUSB/usbhw_lpc.c **** 
 111:../LPCUSB/usbhw_lpc.c **** /**
  74              	0:
  75 0050 0448A0E1 	.LBB12:
  76              	.LBB13:
  77 0054 24309FE5 		.loc 1 78 0
  78 0058 014C84E3 		ldr	r2, .L15
  79 005c 104083E5 		ldr	r3, [r2, #0]
  80              		and	r3, r3, #16
  81              		cmp	r3, #16
  82              		bne	.L10
  83              		.loc 1 80 0
  84 0060 18209FE5 		str	r3, [r2, #8]
  85 0064 003092E5 	.LBE13:
  86 0068 103003E2 	.LBE12:
  87 006c 100053E3 		.loc 1 113 0
  88 0070 FAFFFF1A 		ldmfd	sp!, {r4, lr}
  89              		bx	lr
  90 0074 083082E5 	.L16:
  91              		.align	2
  92              	.L15:
 112:../LPCUSB/usbhw_lpc.c **** ocal function to send a command to the USB protocol engine and read data
 113:../LPCUSB/usbhw_lpc.c **** 		
  93              	LFE4:
  95 007c 1EFF2FE1 		.align	2
  97              	USBHwCmdRead:
  98              	.LFB5:
  99 0080 000009E0 		.loc 1 124 0
 100              		@ Function supports interworking.
 101              		@ args = 0, pretend = 0, frame = 0
 102              		@ frame_needed = 0, uses_anonymous_args = 0
 103              	.LVL5:
 104              		stmfd	sp!, {r4, lr}
 105              	.LCFI1:
 114:../LPCUSB/usbhw_lpc.c **** param [in]	bCmd		Command to send
 115:../LPCUSB/usbhw_lpc.c **** 
 116:../LPCUSB/usbhw_lpc.c **** 	@return the data
 117:../LPCUSB/usbhw_lpc.c ****  */
 118:../LPCUSB/usbhw_lpc.c **** static U8 USBHwCmdRead(U8 bCmd)
 119:../LPCUSB/usbhw_lpc.c **** {
 120:../LPCUSB/usbhw_lpc.c **** 	// write command code
 121:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(bCmd);
 122:../LPCUSB/usbhw_lpc.c **** 	
 123:../LPCUSB/usbhw_lpc.c **** 	// get data
 124:../LPCUSB/usbhw_lpc.c **** 	USBCmdCode = 0x00000200 | (bCmd << 16);
 106              	
 107              		and	r4, r0, #255
 108              		.loc 1 126 0
 109              		mov	r0, r4
 110              	.LVL6:
 111 0084 10402DE9 		bl	USBHwCmd
 112              		.loc 1 129 0
 113              		mov	r4, r4, asl #16
 114 0088 FF4000E2 	.LVL7:
 125:../LPCUSB/usbhw_lpc.c **** t(CDFULL);
 126:../LPCUSB/usbhw_lpc.c **** 	return USBCmdData;
 115              	 .L23
 116 008c 0400A0E1 		orr	r4, r4, #512
 117              		str	r4, [r3, #16]
 118 0090 DAFFFFEB 	.L18:
 127:../LPCUSB/usbhw_lpc.c **** 
 128:../LPCUSB/usbhw_lpc.c **** 
 129:../LPCUSB/usbhw_lpc.c **** /**
 119              	14:
 120 0094 0448A0E1 	.LBB15:
 121              		.loc 1 78 0
 122 0098 2C309FE5 		ldr	r2, .L23
 123 009c 024C84E3 		ldr	r3, [r2, #0]
 124 00a0 104083E5 		and	r3, r3, #32
 125              		cmp	r3, #32
 126              		bne	.L18
 127              		.loc 1 80 0
 128              		str	r3, [r2, #8]
 129 00a4 20209FE5 	.LBE15:
 130 00a8 003092E5 	.LBE14:
 131 00ac 203003E2 		.loc 1 131 0
 132 00b0 200053E3 		ldr	r0, [r2, #20]
 133 00b4 FAFFFF1A 		and	r0, r0, #255
 134              		.loc 1 132 0
 135 00b8 083082E5 		ldmfd	sp!, {r4, lr}
 136              		bx	lr
 137              	.L24:
 130:../LPCUSB/usbhw_lpc.c **** Realizes' an endpoint, meaning that buffer space is reserved for
 131:../LPCUSB/usbhw_lpc.c **** 	it. An endpoint needs to be realised before it can be used.
 138              	ord	-536281088
 139 00bc 140092E5 	.LFE5:
 132:../LPCUSB/usbhw_lpc.c **** 
 141              	lign	2
 142 00c4 1040BDE8 		.global	USBHwEPConfig
 144              	USBHwEPConfig:
 145              	.LFB8:
 146              		.loc 1 174 0
 147 00cc 000009E0 		@ Function supports interworking.
 148              		@ args = 0, pretend = 0, frame = 0
 149              		@ frame_needed = 0, uses_anonymous_args = 0
 150              		@ link register save eliminated.
 151              	.LVL8:
 152              	.LBB22:
 153              	.LBB23:
 154              		.loc 1 148 0
 133:../LPCUSB/usbhw_lpc.c **** 	From experiments, it appears that a USB reset causes USBReEP to
 134:../LPCUSB/usbhw_lpc.c **** 	re-initialise to 3 (= just the control endpoints).
 135:../LPCUSB/usbhw_lpc.c **** 	However, a USB bus reset does not disturb the USBMaxPSize settings.
 136:../LPCUSB/usbhw_lpc.c **** 		
 137:../LPCUSB/usbhw_lpc.c **** 	@param [in]	idx			Endpoint index
 138:../LPCUSB/usbhw_lpc.c **** 	@param [in] wMaxPSize	Maximum packet size for this endpoint
 139:../LPCUSB/usbhw_lpc.c ****  */
 140:../LPCUSB/usbhw_lpc.c **** static void USBHwEPRealize(int idx, U16 wMaxPSize)
 141:../LPCUSB/usbhw_lpc.c **** {
 142:../LPCUSB/usbhw_lpc.c **** 	USBReEP |= (1 << idx);
 143:../LPCUSB/usbhw_lpc.c **** 	USBEpInd = idx;
 144:../LPCUSB/usbhw_lpc.c **** 	USBMaxPSize = wMaxPSize;
 145:../LPCUSB/usbhw_lpc.c **** 	Wait4DevInt(EP_RLZED);
 146:../LPCUSB/usbhw_lpc.c **** }
 147:../LPCUSB/usbhw_lpc.c **** 
 148:../LPCUSB/usbhw_lpc.c **** 
 149:../LPCUSB/usbhw_lpc.c **** /**
 150:../LPCUSB/usbhw_lpc.c **** 	Enables or disables an endpoint
 151:../LPCUSB/usbhw_lpc.c **** 		
 152:../LPCUSB/usbhw_lpc.c **** 	@param [in]	idx		Endpoint index
 153:../LPCUSB/usbhw_lpc.c **** 	@param [in]	fEnable	TRUE to enable, FALSE to disable
 154:../LPCUSB/usbhw_lpc.c ****  */
 155:../LPCUSB/usbhw_lpc.c **** static void USBHwEPEnable(int idx, BOOL fEnable)
 156:../LPCUSB/usbhw_lpc.c **** {
 157:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
 158:../LPCUSB/usbhw_lpc.c **** }
 159:../LPCUSB/usbhw_lpc.c **** 
 160:../LPCUSB/usbhw_lpc.c **** 
 161:../LPCUSB/usbhw_lpc.c **** /**
 162:../LPCUSB/usbhw_lpc.c **** 	Configures an endpoint and enables it
 163:../LPCUSB/usbhw_lpc.c **** 		
 164:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP				Endpoint number
 165:../LPCUSB/usbhw_lpc.c **** 	@param [in]	wMaxPacketSize	Maximum packet size for this EP
 166:../LPCUSB/usbhw_lpc.c ****  */
 167:../LPCUSB/usbhw_lpc.c **** void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
 168:../LPCUSB/usbhw_lpc.c **** {
 169:../LPCUSB/usbhw_lpc.c **** 	int idx;
 170:../LPCUSB/usbhw_lpc.c **** 	
 171:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 172:../LPCUSB/usbhw_lpc.c **** 	
 173:../LPCUSB/usbhw_lpc.c **** 	// realise EP
 174:../LPCUSB/usbhw_lpc.c **** 	USBHwEPRealize(idx, wMaxPacketSize);
 155              	.LBE23:
 156              	.LBE22:
 157              		.loc 1 177 0
 158              		and	r3, r0, #128
 159              	.LBB24:
 160              	.LBB25:
 161              		.loc 1 148 0
 162              		ldr	r2, [ip, #68]
 163              	.LBE25:
 164 00d0 50C09FE5 	.LBE24:
 165              		.loc 1 177 0
 166              		mov	r3, r3, asr #7
 175:../LPCUSB/usbhw_lpc.c **** }
 176:../LPCUSB/usbhw_lpc.c **** 
 177:../LPCUSB/usbhw_lpc.c **** 
 167              	 #15
 168 00d4 803000E2 	.LVL9:
 169              		orr	r0, r3, r0, asl #1
 170              	.LVL10:
 171              	.LBB26:
 172 00d8 44209CE5 	.LBB27:
 173              		.loc 1 148 0
 174              		mov	r3, #1
 175              		orr	r2, r2, r3, asl r0
 176 00dc C333A0E1 		.loc 1 150 0
 177 00e0 0F0000E2 		mov	r1, r1, asl #16
 178              	.LVL11:
 179 00e4 800083E1 		mov	r1, r1, lsr #16
 180              		.loc 1 148 0
 181              		str	r2, [ip, #68]
 182              		.loc 1 149 0
 183              		str	r0, [ip, #72]
 184 00e8 0130A0E3 		.loc 1 150 0
 185 00ec 132082E1 		str	r1, [ip, #76]
 186              	.LBE27:
 187 00f0 0118A0E1 	.LBE26:
 188              		.loc 1 174 0
 189 00f4 2118A0E1 		@ lr needed for prologue
 190              	.L26:
 191 00f8 44208CE5 	.LBB28:
 192              	.LBB29:
 193 00fc 48008CE5 	.LBB30:
 194              	.LBB31:
 195 0100 4C108CE5 		.loc 1 78 0
 196              		ldr	r2, .L31
 197              		ldr	r3, [r2, #0]
 198              		and	r3, r3, #256
 199              		cmp	r3, #256
 200              		bne	.L26
 201              	.LBE31:
 202              	.LBE30:
 203              	.LBE29:
 204              	.LBE28:
 205              	.LBB32:
 206 0104 1C209FE5 	.LBB33:
 207 0108 003092E5 		.loc 1 163 0
 208 010c 013C03E2 		orr	r0, r0, #64
 209 0110 010C53E3 	.LVL12:
 210 0114 FAFFFF1A 		mov	r1, #0
 211              	.LBE33:
 212              	.LBE32:
 213              	.LBB34:
 214              	.LBB35:
 215              	.LBB36:
 216              	.LBB37:
 217              		.loc 1 80 0
 218 0118 400080E3 		str	r3, [r2, #8]
 219              	.LBE37:
 220 011c 0010A0E3 	.LBE36:
 221              	.LBE35:
 222              	.LBE34:
 223              		.loc 1 184 0
 224              	.LBB38:
 225              	.LBB39:
 226              		.loc 1 163 0
 227              		b	USBHwCmdWrite
 228 0120 083082E5 	.L32:
 229              		.align	2
 230              	.L31:
 231              		.word	-536281088
 232              	.LBE39:
 178:../LPCUSB/usbhw_lpc.c **** 
 179:../LPCUSB/usbhw_lpc.c **** 	Registers an endpoint event callback
 180:../LPCUSB/usbhw_lpc.c **** 		
 181:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP				Endpoint number
 182:../LPCUSB/usbhw_lpc.c **** 	@param [in]	pfnHandler		Callback function
 183:../LPCUSB/usbhw_lpc.c ****  */
 184:../LPCUSB/usbhw_lpc.c **** void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
 233              	lobal	USBHwRegisterEPIntHandler
 235              	USBHwRegisterEPIntHandler:
 236              	.LFB9:
 237 0124 C4FFFFEA 		.loc 1 194 0
 238              		@ Function supports interworking.
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241 0128 000009E0 	.LVL13:
 242              		str	lr, [sp, #-4]!
 243              	.LCFI2:
 244              		.loc 1 205 0
 245              		ldr	lr, .L35
 246              		.loc 1 197 0
 247              		and	r3, r0, #128
 248              		.loc 1 205 0
 249              		ldr	ip, [lr, #52]
 250              		.loc 1 197 0
 185:../LPCUSB/usbhw_lpc.c ****  idx;
 186:../LPCUSB/usbhw_lpc.c **** 	
 187:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 188:../LPCUSB/usbhw_lpc.c **** 
 189:../LPCUSB/usbhw_lpc.c **** 	ASSERT(idx<32);
 190:../LPCUSB/usbhw_lpc.c **** 
 191:../LPCUSB/usbhw_lpc.c **** 	/* add handler to list of EP handlers */
 192:../LPCUSB/usbhw_lpc.c **** 	_apfnEPIntHandlers[idx / 2] = pfnHandler;
 193:../LPCUSB/usbhw_lpc.c **** 	
 194:../LPCUSB/usbhw_lpc.c **** 	/* enable EP interrupt */
 251              	LVL14:
 252              		mov	r3, r3, asr #7
 253              		.loc 1 202 0
 254              		orr	r3, r3, r0, asl #1
 255              	.LVL15:
 256 012c 04E02DE5 		.loc 1 205 0
 257              		mov	r2, #1
 195:../LPCUSB/usbhw_lpc.c **** n |= (1 << idx);
 196:../LPCUSB/usbhw_lpc.c **** 	USBDevIntEn |= EP_SLOW;
 197:../LPCUSB/usbhw_lpc.c **** 	
 198:../LPCUSB/usbhw_lpc.c **** 	DBG("Registered handler for EP 0x%x\n", bEP);
 199:../LPCUSB/usbhw_lpc.c **** }
 200:../LPCUSB/usbhw_lpc.c **** 
 201:../LPCUSB/usbhw_lpc.c **** 
 202:../LPCUSB/usbhw_lpc.c **** /**
 203:../LPCUSB/usbhw_lpc.c **** 	Registers an device status callback
 204:../LPCUSB/usbhw_lpc.c **** 		
 205:../LPCUSB/usbhw_lpc.c **** 	@param [in]	pfnHandler	Callback function
 258              	, ip, r2, asl r3
 259 0130 38E09FE5 		str	ip, [lr, #52]
 260              		.loc 1 206 0
 261 0134 803000E2 		ldr	r3, [lr, #4]
 262              	.LVL16:
 263 0138 34C09EE5 		.loc 1 202 0
 264              		ldr	r2, .L35+4
 265 013c 0F0000E2 		.loc 1 206 0
 266              		orr	r3, r3, #4
 267 0140 C333A0E1 		.loc 1 202 0
 268              		str	r1, [r2, r0, asl #2]
 269 0144 803083E1 		.loc 1 206 0
 270              		str	r3, [lr, #4]
 271              		.loc 1 209 0
 272 0148 0120A0E3 		ldr	lr, [sp], #4
 273 014c 12C38CE1 		bx	lr
 274 0150 34C08EE5 	.L36:
 206:../LPCUSB/usbhw_lpc.c **** BHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
 275              	.word	-536281088
 276 0154 04309EE5 		.word	_apfnEPIntHandlers
 277              	.LFE9:
 279 0158 14209FE5 		.align	2
 280              		.global	USBHwRegisterDevIntHandler
 282              	USBHwRegisterDevIntHandler:
 283 0160 001182E7 	.LFB10:
 284              		.loc 1 218 0
 285 0164 04308EE5 		@ Function supports interworking.
 207:../LPCUSB/usbhw_lpc.c **** 
 208:../LPCUSB/usbhw_lpc.c **** 	_pfnDevIntHandler = pfnHandler;
 209:../LPCUSB/usbhw_lpc.c **** 	
 286              	, pretend = 0, frame = 0
 287 0168 04E09DE4 		@ frame_needed = 0, uses_anonymous_args = 0
 288 016c 1EFF2FE1 		@ link register save eliminated.
 289              	.LVL17:
 290              		.loc 1 222 0
 291              		ldr	r3, .L39
 292 0170 000009E0 		ldr	r2, [r3, #4]
 293 0174 08000000 		.loc 1 219 0
 294              		ldr	r1, .L39+4
 295              		.loc 1 222 0
 296              		orr	r2, r2, #8
 297              		.loc 1 218 0
 298              		@ lr needed for prologue
 299              		.loc 1 219 0
 300              		str	r0, [r1, #0]
 210:../LPCUSB/usbhw_lpc.c **** / enable device interrupt
 211:../LPCUSB/usbhw_lpc.c **** 	USBDevIntEn |= DEV_STAT;
 212:../LPCUSB/usbhw_lpc.c **** 
 213:../LPCUSB/usbhw_lpc.c **** 	DBG("Registered handler for device status\n");
 214:../LPCUSB/usbhw_lpc.c **** }
 215:../LPCUSB/usbhw_lpc.c **** 
 216:../LPCUSB/usbhw_lpc.c **** 
 217:../LPCUSB/usbhw_lpc.c **** /**
 218:../LPCUSB/usbhw_lpc.c **** 	Registers the frame callback
 301              	str	r2, [r3, #4]
 302              		.loc 1 225 0
 303              		bx	lr
 304              	.L40:
 305              		.align	2
 306              	.L39:
 219:../LPCUSB/usbhw_lpc.c **** m [in]	pfnHandler	Callback function
 220:../LPCUSB/usbhw_lpc.c ****  */
 221:../LPCUSB/usbhw_lpc.c **** void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
 222:../LPCUSB/usbhw_lpc.c **** {
 307              		-536281088
 308 0178 14309FE5 		.word	_pfnDevIntHandler
 309 017c 042093E5 	.LFE10:
 311 0180 10109FE5 		.align	2
 312              		.global	USBHwRegisterFrameHandler
 314              	USBHwRegisterFrameHandler:
 315              	.LFB11:
 316              		.loc 1 234 0
 317 0188 000081E5 		@ Function supports interworking.
 318              		@ args = 0, pretend = 0, frame = 0
 319 018c 042083E5 		@ frame_needed = 0, uses_anonymous_args = 0
 223:../LPCUSB/usbhw_lpc.c **** nFrameHandler = pfnHandler;
 224:../LPCUSB/usbhw_lpc.c **** 	
 225:../LPCUSB/usbhw_lpc.c **** 	// enable device interrupt
 320              	ter save eliminated.
 321 0190 1EFF2FE1 	.LVL18:
 322              		.loc 1 238 0
 323              		ldr	r3, .L43
 324              		ldr	r2, [r3, #4]
 325 0194 000009E0 		.loc 1 235 0
 326 0198 04000000 		ldr	r1, .L43+4
 327              		.loc 1 238 0
 328              		orr	r2, r2, #1
 329              		.loc 1 234 0
 330              		@ lr needed for prologue
 331              		.loc 1 235 0
 332              		str	r0, [r1, #0]
 333              		.loc 1 238 0
 226:../LPCUSB/usbhw_lpc.c **** BDevIntEn |= FRAME;
 227:../LPCUSB/usbhw_lpc.c **** 
 228:../LPCUSB/usbhw_lpc.c **** 	DBG("Registered handler for frame\n");
 229:../LPCUSB/usbhw_lpc.c **** }
 230:../LPCUSB/usbhw_lpc.c **** 
 231:../LPCUSB/usbhw_lpc.c **** 
 232:../LPCUSB/usbhw_lpc.c **** /**
 233:../LPCUSB/usbhw_lpc.c **** 	Sets the USB address.
 234:../LPCUSB/usbhw_lpc.c **** 		
 334              	#4]
 335              		.loc 1 241 0
 336              		bx	lr
 337              	.L44:
 338              		.align	2
 339              	.L43:
 235:../LPCUSB/usbhw_lpc.c **** in]	bAddr		Device address to set
 236:../LPCUSB/usbhw_lpc.c ****  */
 237:../LPCUSB/usbhw_lpc.c **** void USBHwSetAddress(U8 bAddr)
 238:../LPCUSB/usbhw_lpc.c **** {
 340              		-536281088
 341 019c 14309FE5 		.word	_pfnFrameHandler
 342 01a0 042093E5 	.LFE11:
 344 01a4 10109FE5 		.align	2
 345              		.global	USBHwSetAddress
 347              	USBHwSetAddress:
 348              	.LFB12:
 349              		.loc 1 250 0
 350 01ac 000081E5 		@ Function supports interworking.
 351              		@ args = 0, pretend = 0, frame = 0
 352 01b0 042083E5 		@ frame_needed = 0, uses_anonymous_args = 0
 239:../LPCUSB/usbhw_lpc.c **** HwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
 240:../LPCUSB/usbhw_lpc.c **** }
 241:../LPCUSB/usbhw_lpc.c **** 
 353              	ter save eliminated.
 354 01b4 1EFF2FE1 	.LVL19:
 355              		and	r1, r0, #255
 356              		.loc 1 251 0
 357              		orr	r1, r1, #128
 358 01b8 000009E0 		mov	r0, #208
 359 01bc 00000000 	.LVL20:
 360              		.loc 1 250 0
 361              		@ lr needed for prologue
 362              		.loc 1 252 0
 363              		.loc 1 251 0
 364              		b	USBHwCmdWrite
 365              	.LFE12:
 242:../LPCUSB/usbhw_lpc.c **** *
 243:../LPCUSB/usbhw_lpc.c **** 	Connects or disconnects from the USB bus
 244:../LPCUSB/usbhw_lpc.c **** 		
 245:../LPCUSB/usbhw_lpc.c **** 	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 246:../LPCUSB/usbhw_lpc.c ****  */
 247:../LPCUSB/usbhw_lpc.c **** void USBHwConnect(BOOL fConnect)
 248:../LPCUSB/usbhw_lpc.c **** {
 249:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
 250:../LPCUSB/usbhw_lpc.c **** 
 367              	obal	USBHwConnect
 369              	USBHwConnect:
 370              	.LFB13:
 371              		.loc 1 261 0
 372              		@ Function supports interworking.
 373 01c0 FF1000E2 		@ args = 0, pretend = 0, frame = 0
 251:../LPCUSB/usbhw_lpc.c **** Enables interrupt on NAK condition
 374              	e_needed = 0, uses_anonymous_args = 0
 375 01c4 801081E3 		@ link register save eliminated.
 376 01c8 D000A0E3 	.LVL21:
 377              		.loc 1 262 0
 378              		subs	r1, r0, #0
 379              		movne	r1, #1
 252:../LPCUSB/usbhw_lpc.c **** 	
 380              	0, #254
 381              	.LVL22:
 382 01cc 9AFFFFEA 		.loc 1 261 0
 383              		@ lr needed for prologue
 384              		.loc 1 264 0
 385              		.loc 1 262 0
 386              		b	USBHwCmdWrite
 387              	.LFE13:
 389              		.align	2
 253:../LPCUSB/usbhw_lpc.c **** For IN endpoints a NAK is generated when the host wants to read data
 254:../LPCUSB/usbhw_lpc.c **** 	from the device, but none is available in the endpoint buffer.
 255:../LPCUSB/usbhw_lpc.c **** 	For OUT endpoints a NAK is generated when the host wants to write data
 256:../LPCUSB/usbhw_lpc.c **** 	to the device, but the endpoint buffer is still full.
 257:../LPCUSB/usbhw_lpc.c **** 	
 258:../LPCUSB/usbhw_lpc.c **** 	The endpoint interrupt handlers can distinguish regular (ACK) interrupts
 259:../LPCUSB/usbhw_lpc.c **** 	from NAK interrupt by checking the bits in their bEPStatus argument.
 260:../LPCUSB/usbhw_lpc.c **** 	
 261:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 390              	SBHwNakIntEnable
 392              	USBHwNakIntEnable:
 393              	.LFB14:
 394              		.loc 1 281 0
 395              		@ Function supports interworking.
 262:../LPCUSB/usbhw_lpc.c **** USBHwNakIntEnable(U8 bIntBits)
 396              	s = 0, pretend = 0, frame = 0
 397 01d0 001050E2 		@ frame_needed = 0, uses_anonymous_args = 0
 398 01d4 0110A013 		@ link register save eliminated.
 399 01d8 FE00A0E3 	.LVL23:
 400              		and	r1, r0, #255
 401              		.loc 1 282 0
 402              		mov	r0, #243
 263:../LPCUSB/usbhw_lpc.c **** 
 264:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
 403              	
 404              		.loc 1 281 0
 405 01dc 96FFFFEA 		@ lr needed for prologue
 406              		.loc 1 283 0
 407              		.loc 1 282 0
 408              		b	USBHwCmdWrite
 409              	.LVL25:
 410              	.LFE14:
 412              		.align	2
 265:../LPCUSB/usbhw_lpc.c **** 
 266:../LPCUSB/usbhw_lpc.c **** 
 267:../LPCUSB/usbhw_lpc.c **** 
 268:../LPCUSB/usbhw_lpc.c **** /**
 269:../LPCUSB/usbhw_lpc.c **** 	Gets the status from a specific endpoint.
 270:../LPCUSB/usbhw_lpc.c **** 		
 271:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP		Endpoint number
 272:../LPCUSB/usbhw_lpc.c **** 	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 273:../LPCUSB/usbhw_lpc.c ****  */
 274:../LPCUSB/usbhw_lpc.c **** U8	USBHwEPGetStatus(U8 bEP)
 275:../LPCUSB/usbhw_lpc.c **** {
 276:../LPCUSB/usbhw_lpc.c **** 	int idx = EP2IDX(bEP);
 277:../LPCUSB/usbhw_lpc.c **** 
 278:../LPCUSB/usbhw_lpc.c **** 	return USBHwCmdRead(CMD_EP_SELECT | idx);
 279:../LPCUSB/usbhw_lpc.c **** }
 280:../LPCUSB/usbhw_lpc.c **** 
 281:../LPCUSB/usbhw_lpc.c **** 
 413              	USBHwEPGetStatus
 415              	USBHwEPGetStatus:
 416              	.LFB15:
 417              		.loc 1 293 0
 418              		@ Function supports interworking.
 419 01e0 FF1000E2 		@ args = 0, pretend = 0, frame = 0
 282:../LPCUSB/usbhw_lpc.c **** alled property of an endpoint
 420              	e_needed = 0, uses_anonymous_args = 0
 421 01e4 F300A0E3 	.LVL26:
 422              		mov	r3, r0
 423              		.loc 1 296 0
 424              		and	r0, r0, #128
 283:../LPCUSB/usbhw_lpc.c **** 	
 425              	7:
 426              		and	r3, r3, #15
 427 01e8 93FFFFEA 	.LVL28:
 428              		mov	r0, r0, asr #7
 429              		.loc 1 293 0
 430              		str	lr, [sp, #-4]!
 431              	.LCFI3:
 432              		.loc 1 296 0
 433              		orr	r0, r0, r3, asl #1
 434              		bl	USBHwCmdRead
 435              		.loc 1 297 0
 284:../LPCUSB/usbhw_lpc.c **** @param [in]	bEP		Endpoint number
 285:../LPCUSB/usbhw_lpc.c **** 	@param [in]	fStall	TRUE to stall, FALSE to unstall
 286:../LPCUSB/usbhw_lpc.c ****  */
 287:../LPCUSB/usbhw_lpc.c **** void USBHwEPStall(U8 bEP, BOOL fStall)
 288:../LPCUSB/usbhw_lpc.c **** {
 289:../LPCUSB/usbhw_lpc.c **** 	int idx = EP2IDX(bEP);
 290:../LPCUSB/usbhw_lpc.c **** 
 291:../LPCUSB/usbhw_lpc.c **** 	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
 292:../LPCUSB/usbhw_lpc.c **** }
 293:../LPCUSB/usbhw_lpc.c **** 
 436              	p], #4
 437              		bx	lr
 438              	.LFE15:
 440              		.align	2
 441 01ec 0030A0E1 		.global	USBHwEPStall
 294:../LPCUSB/usbhw_lpc.c **** es data to an endpoint buffer
 295:../LPCUSB/usbhw_lpc.c **** 		
 296:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP		Endpoint number
 442              		USBHwEPStall, %function
 443 01f0 800000E2 	USBHwEPStall:
 444              	.LFB16:
 445 01f4 0F3003E2 		.loc 1 307 0
 446              		@ Function supports interworking.
 447 01f8 C003A0E1 		@ args = 0, pretend = 0, frame = 0
 448              		@ frame_needed = 0, uses_anonymous_args = 0
 449 01fc 04E02DE5 		@ link register save eliminated.
 450              	.LVL29:
 451              		.loc 1 310 0
 452 0200 830080E1 		and	r3, r0, #128
 453 0204 9EFFFFEB 		mov	r3, r3, asr #7
 297:../LPCUSB/usbhw_lpc.c **** aram [in]	pbBuf	Endpoint data
 454              	 #15
 455 0208 04E09DE4 	.LVL30:
 456 020c 1EFF2FE1 		orr	r3, r3, r0, asl #1
 457              		subs	r1, r1, #0
 458              		movne	r1, #1
 459              	.LVL31:
 460              		orr	r0, r3, #64
 461              		.loc 1 307 0
 462              		@ lr needed for prologue
 463              		.loc 1 311 0
 298:../LPCUSB/usbhw_lpc.c **** @param [in]	iLen	Number of bytes to write
 299:../LPCUSB/usbhw_lpc.c **** 			
 300:../LPCUSB/usbhw_lpc.c **** 	@return TRUE if the data was successfully written or <0 in case of error.
 301:../LPCUSB/usbhw_lpc.c **** */
 302:../LPCUSB/usbhw_lpc.c **** int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
 303:../LPCUSB/usbhw_lpc.c **** {
 304:../LPCUSB/usbhw_lpc.c **** 	int idx;
 305:../LPCUSB/usbhw_lpc.c **** 	
 306:../LPCUSB/usbhw_lpc.c **** 	idx = EP2IDX(bEP);
 307:../LPCUSB/usbhw_lpc.c **** 	
 464              	0 0
 465              		b	USBHwCmdWrite
 466              	.LFE16:
 468              		.align	2
 469              		.global	USBHwEPWrite
 308:../LPCUSB/usbhw_lpc.c **** ite enable for specific endpoint
 309:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
 310:../LPCUSB/usbhw_lpc.c **** 	
 470              		USBHwEPWrite, %function
 471 0210 803000E2 	USBHwEPWrite:
 472 0214 C333A0E1 	.LFB17:
 473 0218 0F0000E2 		.loc 1 324 0
 474              		@ Function supports interworking.
 475 021c 803083E1 		@ args = 0, pretend = 0, frame = 0
 476 0220 001051E2 		@ frame_needed = 0, uses_anonymous_args = 0
 477 0224 0110A013 	.LVL32:
 478              		stmfd	sp!, {r4, r5, lr}
 479 0228 400083E3 	.LCFI4:
 480              		.loc 1 327 0
 481              		and	r4, r0, #15
 311:../LPCUSB/usbhw_lpc.c ****  set packet length
 482              	0
 483              		ldr	ip, .L60
 484 022c 82FFFFEA 		mov	r3, r4, asl #2
 485              		orr	r3, r3, #2
 486              		.loc 1 324 0
 487              		mov	r5, r2
 488              		.loc 1 333 0
 489              		mov	lr, r1
 490              		.loc 1 324 0
 491              		and	r0, r0, #255
 312:../LPCUSB/usbhw_lpc.c **** USBTxPLen = iLen;
 313:../LPCUSB/usbhw_lpc.c **** 	
 314:../LPCUSB/usbhw_lpc.c **** 	// write data
 315:../LPCUSB/usbhw_lpc.c **** 	while (USBCtrl & WR_EN) {
 316:../LPCUSB/usbhw_lpc.c **** 		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
 317:../LPCUSB/usbhw_lpc.c **** 		pbBuf += 4;
 318:../LPCUSB/usbhw_lpc.c **** 	}
 319:../LPCUSB/usbhw_lpc.c **** 
 320:../LPCUSB/usbhw_lpc.c **** 	// select endpoint and validate buffer
 321:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_SELECT | idx);
 322:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
 323:../LPCUSB/usbhw_lpc.c **** 	
 324:../LPCUSB/usbhw_lpc.c **** 	return iLen;
 492              	loc 1 330 0
 493              		str	r3, [ip, #40]
 494              		.loc 1 333 0
 495              		str	r2, [ip, #36]
 496              		b	.L56
 497 0230 30402DE9 	.L57:
 498              		.loc 1 337 0
 325:../LPCUSB/usbhw_lpc.c **** s data from an endpoint buffer
 326:../LPCUSB/usbhw_lpc.c **** 		
 327:../LPCUSB/usbhw_lpc.c **** 	@param [in]	bEP		Endpoint number
 499              	3, [lr, #-2]	@ zero_extendqisi2
 500 0234 0F4000E2 		ldrb	r2, [lr, #-1]	@ zero_extendqisi2
 328:../LPCUSB/usbhw_lpc.c **** aram [in]	pbBuf	Endpoint data
 329:../LPCUSB/usbhw_lpc.c **** 	@param [in]	iMaxLen	Maximum number of bytes to read
 330:../LPCUSB/usbhw_lpc.c **** 			
 501              	VL34:
 502 0238 74C09FE5 		ldrb	r1, [lr, #-4]	@ zero_extendqisi2
 503 023c 0431A0E1 	.LVL35:
 504 0240 023083E3 		mov	r3, r3, asl #16
 505              		orr	r3, r3, r2, asl #24
 506 0244 0250A0E1 		ldrb	r2, [lr, #-3]	@ zero_extendqisi2
 331:../LPCUSB/usbhw_lpc.c **** eturn the number of bytes available in the EP (possibly more than iMaxLen),
 332:../LPCUSB/usbhw_lpc.c **** 	or <0 in case of error.
 333:../LPCUSB/usbhw_lpc.c ****  */
 507              	3, r3, r1
 508 0248 01E0A0E1 		orr	r3, r3, r2, asl #8
 509              		str	r3, [ip, #28]
 510 024c FF0000E2 	.LVL36:
 511              	.L56:
 512              		.loc 1 336 0
 513 0250 28308CE5 		ldr	ip, .L60
 514              		ldr	r3, [ip, #40]
 515 0254 24208CE5 		tst	r3, #2
 516 0258 080000EA 		add	lr, lr, #4
 517              		bne	.L57
 334:../LPCUSB/usbhw_lpc.c ****  USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
 335:../LPCUSB/usbhw_lpc.c **** {
 336:../LPCUSB/usbhw_lpc.c **** 	int i, idx;
 337:../LPCUSB/usbhw_lpc.c **** 	U32	dwData, dwLen;
 518              	oc 1 342 0
 519 025c 02305EE5 		mov	r0, r0, lsr #7
 520 0260 01205EE5 		orr	r0, r0, r4, asl #1
 521              		bl	USBHwCmd
 522 0264 04105EE5 	.LVL38:
 523              		.loc 1 343 0
 524 0268 0338A0E1 		mov	r0, #250
 525 026c 023C83E1 		bl	USBHwCmd
 526 0270 03205EE5 		.loc 1 346 0
 527 0274 013083E1 		mov	r0, r5
 528 0278 023483E1 		ldmfd	sp!, {r4, r5, lr}
 529 027c 1C308CE5 		bx	lr
 530              	.L61:
 531              		.align	2
 532              	.L60:
 533 0280 2CC09FE5 		.word	-536281088
 534 0284 28309CE5 	.LFE17:
 536 028c 04E08EE2 		.align	2
 537 0290 F1FFFF1A 		.global	USBHwEPRead
 338:../LPCUSB/usbhw_lpc.c **** dx = EP2IDX(bEP);
 339:../LPCUSB/usbhw_lpc.c **** 	
 340:../LPCUSB/usbhw_lpc.c **** 	// set read enable bit for specific endpoint
 341:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
 342:../LPCUSB/usbhw_lpc.c **** 	
 539              		.loc 1 360 0
 540 0294 A003A0E1 		@ Function supports interworking.
 541 0298 840080E1 		@ args = 0, pretend = 0, frame = 0
 542 029c 57FFFFEB 		@ frame_needed = 0, uses_anonymous_args = 0
 543              	.LVL39:
 343:../LPCUSB/usbhw_lpc.c **** ait for PKT_RDY
 544              	d	sp!, {r4, lr}
 545 02a0 FA00A0E3 	.LCFI5:
 546 02a4 55FFFFEB 		.loc 1 364 0
 344:../LPCUSB/usbhw_lpc.c **** do {
 345:../LPCUSB/usbhw_lpc.c **** 		dwLen = USBRxPLen;
 346:../LPCUSB/usbhw_lpc.c **** 	} while ((dwLen & PKT_RDY) == 0);
 547              	d	lr, r0, #15
 548 02a8 0500A0E1 		.loc 1 367 0
 549 02ac 3040BDE8 		mov	r3, lr, asl #2
 550 02b0 1EFF2FE1 		ldr	ip, .L78
 551              		orr	r3, r3, #1
 552              		str	r3, [ip, #40]
 553              		.loc 1 360 0
 554 02b4 000009E0 		and	r0, r0, #255
 555              	.LVL40:
 556              	.L63:
 557              		.loc 1 371 0
 558              		ldr	r3, .L78
 559              		ldr	r3, [r3, #32]
 560              	.LVL41:
 561              		.loc 1 372 0
 347:../LPCUSB/usbhw_lpc.c **** // packet valid?
 348:../LPCUSB/usbhw_lpc.c **** 	if ((dwLen & DV) == 0) {
 349:../LPCUSB/usbhw_lpc.c **** 		return -1;
 350:../LPCUSB/usbhw_lpc.c **** 	}
 351:../LPCUSB/usbhw_lpc.c **** 	
 352:../LPCUSB/usbhw_lpc.c **** 	// get length
 353:../LPCUSB/usbhw_lpc.c **** 	dwLen &= PKT_LNGTH_MASK;
 354:../LPCUSB/usbhw_lpc.c **** 	
 355:../LPCUSB/usbhw_lpc.c **** 	// get data
 356:../LPCUSB/usbhw_lpc.c **** 	dwData = 0;
 357:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 358:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 359:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 360:../LPCUSB/usbhw_lpc.c **** 		}
 562              		beq	.L63
 563              		.loc 1 375 0
 564              		tst	r3, #1024
 565              		mvneq	r4, #0
 566              	.LVL42:
 567 02b8 10402DE9 		beq	.L67
 568              		.loc 1 380 0
 361:../LPCUSB/usbhw_lpc.c **** = NULL) && (i < iMaxLen)) {
 362:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 363:../LPCUSB/usbhw_lpc.c **** 		}
 364:../LPCUSB/usbhw_lpc.c **** 		dwData >>= 8;
 569              	, r3, asl #22
 570 02bc 0FE000E2 	.LVL43:
 365:../LPCUSB/usbhw_lpc.c **** or (i = 0; i < dwLen; i++) {
 366:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 367:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 571              	ov	r4, #0
 572 02c0 0E31A0E1 		mov	ip, ip, lsr #22
 573 02c4 8CC09FE5 		mov	r3, r4
 574 02c8 013083E3 	.LVL44:
 575 02cc 28308CE5 		b	.L68
 576              	.L69:
 577 02d0 FF0000E2 		.loc 1 385 0
 578              		tst	r4, #3
 579              		.loc 1 386 0
 368:../LPCUSB/usbhw_lpc.c **** 
 369:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 370:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 371:../LPCUSB/usbhw_lpc.c **** 		}
 580              	, .L78
 581 02d4 7C309FE5 	.LVL45:
 582 02d8 203093E5 		ldreq	r3, [r3, #24]
 583              	.LVL46:
 372:../LPCUSB/usbhw_lpc.c **** a
 584              	c 1 388 0
 585 02dc 020B13E3 		cmp	r1, #0
 586 02e0 FBFFFF0A 		cmpne	r4, r2
 373:../LPCUSB/usbhw_lpc.c **** dwData = 0;
 374:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 375:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 587              	oc 1 389 0
 588 02e4 010B13E3 		strltb	r3, [r4, r1]
 589 02e8 0040E003 		.loc 1 391 0
 590              		mov	r3, r3, lsr #8
 591 02ec 1600000A 		.loc 1 384 0
 376:../LPCUSB/usbhw_lpc.c **** dwData = USBRxData;
 377:../LPCUSB/usbhw_lpc.c **** 		}
 378:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 379:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 380:../LPCUSB/usbhw_lpc.c **** 		}
 592              	r4, r4, #1
 593 02f0 03CBA0E1 	.L68:
 594              		cmp	r4, ip
 595 02f4 0040A0E3 		bne	.L69
 596 02f8 2CCBA0E1 		.loc 1 395 0
 597 02fc 0430A0E1 		ldr	r3, .L78
 598              	.LVL47:
 599 0300 070000EA 		mov	r2, #0
 600              	.LVL48:
 381:../LPCUSB/usbhw_lpc.c **** a
 382:../LPCUSB/usbhw_lpc.c **** 	dwData = 0;
 383:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 384:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 385:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 601              	98 0
 602 0304 030014E3 		mov	r0, r0, lsr #7
 386:../LPCUSB/usbhw_lpc.c **** 	if ((pbBuf != NULL) && (i < iMaxLen)) {
 603              	rr	r0, r0, lr, asl #1
 604 0308 48309F05 		.loc 1 395 0
 605              		str	r2, [r3, #40]
 606 030c 18309305 		.loc 1 398 0
 607              		bl	USBHwCmd
 387:../LPCUSB/usbhw_lpc.c **** en &= PKT_LNGTH_MASK;
 388:../LPCUSB/usbhw_lpc.c **** 	
 608              	9:
 609 0310 000051E3 		.loc 1 399 0
 610 0314 02005411 		mov	r0, #242
 389:../LPCUSB/usbhw_lpc.c **** / get data
 611              		USBHwCmd
 612 0318 0130C4B7 	.LVL50:
 390:../LPCUSB/usbhw_lpc.c **** dwData = 0;
 391:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 613              	67:
 614 031c 2334A0E1 		.loc 1 402 0
 615              		mov	r0, r4
 616 0320 014084E2 		ldmfd	sp!, {r4, lr}
 617              		bx	lr
 618 0324 0C0054E1 	.L79:
 619 0328 F5FFFF1A 		.align	2
 392:../LPCUSB/usbhw_lpc.c **** if ((i % 4) == 0) {
 393:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 394:../LPCUSB/usbhw_lpc.c **** 		}
 395:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 620              	.word	-536281088
 621 032c 24309FE5 	.LFE18:
 623 0330 0020A0E3 		.align	2
 624              		.global	USBHwConfigDevice
 396:../LPCUSB/usbhw_lpc.c **** en &= PKT_LNGTH_MASK;
 397:../LPCUSB/usbhw_lpc.c **** 	
 398:../LPCUSB/usbhw_lpc.c **** 	// get data
 625              	e	USBHwConfigDevice, %function
 626 0334 A003A0E1 	USBHwConfigDevice:
 627 0338 8E0080E1 	.LFB19:
 628              		.loc 1 414 0
 629 033c 282083E5 		@ Function supports interworking.
 630              		@ args = 0, pretend = 0, frame = 0
 631 0340 2EFFFFEB 		@ frame_needed = 0, uses_anonymous_args = 0
 632              		@ link register save eliminated.
 399:../LPCUSB/usbhw_lpc.c **** Data = 0;
 633              		.loc 1 416 0
 634 0344 F200A0E3 		subs	r1, r0, #0
 635 0348 2CFFFFEB 		movne	r1, #1
 636              		mov	r0, #216
 637              	.LVL52:
 400:../LPCUSB/usbhw_lpc.c **** for (i = 0; i < dwLen; i++) {
 401:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 402:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 638              	 1 414 0
 639 034c 0400A0E1 		@ lr needed for prologue
 640 0350 1040BDE8 		.loc 1 417 0
 641 0354 1EFF2FE1 		.loc 1 416 0
 642              		b	USBHwCmdWrite
 643              	.LFE19:
 645 0358 000009E0 		.align	2
 646              		.global	USBHwISR
 648              	USBHwISR:
 649              	.LFB20:
 650              		.loc 1 428 0
 651              		@ Function supports interworking.
 652              		@ args = 0, pretend = 0, frame = 0
 403:../LPCUSB/usbhw_lpc.c **** 
 404:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 405:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 406:../LPCUSB/usbhw_lpc.c **** 		}
 407:../LPCUSB/usbhw_lpc.c **** 		dwData >>= 8;
 408:../LPCUSB/usbhw_lpc.c **** 	}
 409:../LPCUSB/usbhw_lpc.c **** 
 410:../LPCUSB/usbhw_lpc.c **** 	// make sure RD_EN is clear
 411:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 412:../LPCUSB/usbhw_lpc.c **** 
 413:../LPCUSB/usbhw_lpc.c **** 	// select endpoint and clear buffer
 414:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_SELECT | idx);
 653              	 = 0, uses_anonymous_args = 0
 654              		.loc 1 439 0
 655              		ldr	r2, .L102
 656              		.loc 1 428 0
 657              		stmfd	sp!, {r4, r5, lr}
 658              	.LCFI6:
 415:../LPCUSB/usbhw_lpc.c **** bBuf[i] = dwData & 0xFF;
 416:../LPCUSB/usbhw_lpc.c **** 		}
 659              	1 439 0
 660 035c 001050E2 		ldr	r5, [r2, #0]
 661 0360 0110A013 	.LVL53:
 662 0364 D800A0E3 		.loc 1 442 0
 663              		tst	r5, #1
 664              		beq	.L83
 665              		.loc 1 446 0
 417:../LPCUSB/usbhw_lpc.c **** a
 666              	, .L102+4
 667              		ldr	r4, [r3, #0]
 668 0368 33FFFFEA 		.loc 1 444 0
 669              		mov	r3, #1
 670              		.loc 1 446 0
 671              		cmp	r4, #0
 672              		.loc 1 444 0
 673              		str	r3, [r2, #8]
 674              		.loc 1 446 0
 675              		beq	.L83
 418:../LPCUSB/usbhw_lpc.c **** dwData = 0;
 419:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 420:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 421:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 422:../LPCUSB/usbhw_lpc.c **** 		}
 423:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 424:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 425:../LPCUSB/usbhw_lpc.c **** 		}
 426:../LPCUSB/usbhw_lpc.c **** 		dwData >>= 8;
 427:../LPCUSB/usbhw_lpc.c **** 	}
 428:../LPCUSB/usbhw_lpc.c **** 
 676              	7 0
 677              		mov	r0, #245
 678              		bl	USBHwCmdRead
 679              		.loc 1 448 0
 429:../LPCUSB/usbhw_lpc.c **** re RD_EN is clear
 430:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 431:../LPCUSB/usbhw_lpc.c **** 
 432:../LPCUSB/usbhw_lpc.c **** 	// select endpoint and clear buffer
 433:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_SELECT | idx);
 434:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_CLEAR_BUFFER);
 435:../LPCUSB/usbhw_lpc.c **** 	
 436:../LPCUSB/usbhw_lpc.c **** 	return dwLen;
 437:../LPCUSB/usbhw_lpc.c **** }
 438:../LPCUSB/usbhw_lpc.c **** 
 439:../LPCUSB/usbhw_lpc.c **** 
 680              		r0, r0, asl #16
 681 036c 10219FE5 		mov	r0, r0, lsr #16
 682              		mov	lr, pc
 683 0370 30402DE9 		bx	r4
 684              	.L83:
 685              		.loc 1 453 0
 686 0374 005092E5 		tst	r5, #8
 687              		beq	.L86
 440:../LPCUSB/usbhw_lpc.c **** ure RD_EN is clear
 441:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 442:../LPCUSB/usbhw_lpc.c **** 
 688              	458 0
 689 0378 010015E3 		ldr	r3, .L102
 690 037c 0B00000A 		mov	r2, #8
 443:../LPCUSB/usbhw_lpc.c **** 	dwData = USBRxData;
 444:../LPCUSB/usbhw_lpc.c **** 		}
 445:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 446:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 691              	oc 1 459 0
 692 0380 00319FE5 		mov	r0, #254
 693 0384 004093E5 		.loc 1 458 0
 694              		str	r2, [r3, #8]
 695 0388 0130A0E3 		.loc 1 459 0
 696              		bl	USBHwCmdRead
 697 038c 000054E3 		.loc 1 460 0
 698              		tst	r0, #26
 699 0390 083082E5 		beq	.L86
 700              		.loc 1 466 0
 701 0394 0500000A 		ldr	r3, .L102+8
 447:../LPCUSB/usbhw_lpc.c **** t data
 702              	3, #0]
 703 0398 F500A0E3 		cmp	r3, #0
 704 039c 38FFFFEB 		.loc 1 468 0
 448:../LPCUSB/usbhw_lpc.c **** dwData = 0;
 705              	dne	r0, r0, #21
 706 03a0 0008A0E1 		movne	lr, pc
 707 03a4 2008A0E1 		bxne	r3
 708 03a8 0FE0A0E1 	.L86:
 709 03ac 14FF2FE1 		.loc 1 475 0
 710              		tst	r5, #4
 449:../LPCUSB/usbhw_lpc.c **** for (i = 0; i < dwLen; i++) {
 450:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 451:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 452:../LPCUSB/usbhw_lpc.c **** 		}
 453:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 711              	L98
 712 03b0 080015E3 		.loc 1 477 0
 713 03b4 0C00000A 		ldr	r3, .L102
 454:../LPCUSB/usbhw_lpc.c **** Buf[i] = dwData & 0xFF;
 455:../LPCUSB/usbhw_lpc.c **** 		}
 456:../LPCUSB/usbhw_lpc.c **** 		dwData >>= 8;
 457:../LPCUSB/usbhw_lpc.c **** 	}
 458:../LPCUSB/usbhw_lpc.c **** 
 714              	v	r2, #4
 715 03b8 C4309FE5 		str	r2, [r3, #8]
 716 03bc 0820A0E3 		mov	r4, #0
 459:../LPCUSB/usbhw_lpc.c **** = 0; i < dwLen; i++) {
 717              	L54:
 718 03c0 FE00A0E3 	.LVL55:
 719              	.L92:
 720 03c4 082083E5 		.loc 1 480 0
 721              		mov	r3, #1
 722 03c8 2DFFFFEB 		mov	r2, r3, asl r4
 460:../LPCUSB/usbhw_lpc.c **** 	if ((i % 4) == 0) {
 723              	1 481 0
 724 03cc 1A0010E3 		ldr	r1, .L102
 725 03d0 0500000A 		ldr	r3, [r1, #48]
 461:../LPCUSB/usbhw_lpc.c **** t valid?
 462:../LPCUSB/usbhw_lpc.c **** 	if ((dwLen & DV) == 0) {
 463:../LPCUSB/usbhw_lpc.c **** 		return -1;
 464:../LPCUSB/usbhw_lpc.c **** 	}
 465:../LPCUSB/usbhw_lpc.c **** 	
 466:../LPCUSB/usbhw_lpc.c **** 	// get length
 726              	t	r3, r2
 727 03d4 B0309FE5 		beq	.L93
 728 03d8 003093E5 		.loc 1 483 0
 729 03dc 000053E3 		str	r2, [r1, #56]
 467:../LPCUSB/usbhw_lpc.c ****  &= PKT_LNGTH_MASK;
 468:../LPCUSB/usbhw_lpc.c **** 	
 730              	:
 731 03e0 15000012 	.LBB42:
 732 03e4 0FE0A011 	.LBB43:
 733 03e8 13FF2F11 		.loc 1 78 0
 734              		ldr	r1, .L102
 469:../LPCUSB/usbhw_lpc.c **** / get data
 470:../LPCUSB/usbhw_lpc.c **** 	dwData = 0;
 471:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 472:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 473:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 474:../LPCUSB/usbhw_lpc.c **** 		}
 475:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 735              	r3, [r1, #0]
 736 03ec 040015E3 		and	r0, r3, #32
 737 03f0 2100000A 		cmp	r0, #32
 476:../LPCUSB/usbhw_lpc.c **** f[i] = dwData & 0xFF;
 477:../LPCUSB/usbhw_lpc.c **** 		}
 738              	e	.L95
 739 03f4 88309FE5 	.LBE43:
 740 03f8 0420A0E3 	.LBE42:
 741 03fc 082083E5 		.loc 1 493 0
 742 0400 0040A0E3 		add	r3, r4, r4, lsr #31
 743              		ldr	r2, .L102+12
 744              	.LVL56:
 745              		mov	r3, r3, asr #1
 478:../LPCUSB/usbhw_lpc.c **** a
 479:../LPCUSB/usbhw_lpc.c **** 	dwData = 0;
 480:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 746              	 [r2, r3, asl #2]
 747 0404 0130A0E3 	.LBB44:
 748 0408 1324A0E1 	.LBB45:
 481:../LPCUSB/usbhw_lpc.c **** f ((i % 4) == 0) {
 749              	oc 1 80 0
 750 040c 70109FE5 		str	r0, [r1, #8]
 751 0410 303091E5 	.LBE45:
 752 0414 020013E1 	.LBE44:
 753 0418 1400000A 		.loc 1 493 0
 482:../LPCUSB/usbhw_lpc.c **** t valid?
 483:../LPCUSB/usbhw_lpc.c **** 	if ((dwLen & DV) == 0) {
 754              	r3, #0
 755 041c 382081E5 		.loc 1 485 0
 756              		ldr	r1, [r1, #20]
 757              		.loc 1 493 0
 758              		beq	.L93
 759              		.loc 1 495 0
 760 0420 5C109FE5 		mov	r0, r4, asr #1
 761 0424 003091E5 		and	r0, r0, #15
 762 0428 200003E2 		orr	r0, r0, r4, asl #7
 763 042c 200050E3 		and	r0, r0, #143
 764 0430 FAFFFF1A 		and	r1, r1, #31
 765              		mov	lr, pc
 766              		bx	r3
 484:../LPCUSB/usbhw_lpc.c **** return -1;
 485:../LPCUSB/usbhw_lpc.c **** 	}
 486:../LPCUSB/usbhw_lpc.c **** 	
 487:../LPCUSB/usbhw_lpc.c **** 	// get length
 488:../LPCUSB/usbhw_lpc.c **** 	dwLen &= PKT_LNGTH_MASK;
 489:../LPCUSB/usbhw_lpc.c **** 	
 490:../LPCUSB/usbhw_lpc.c **** 	// get data
 491:../LPCUSB/usbhw_lpc.c **** 	dwData = 0;
 492:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 493:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 767              	
 768 0434 A43F84E0 		.loc 1 479 0
 769 0438 50209FE5 		add	r4, r4, #1
 770              		cmp	r4, #32
 771 043c C330A0E1 		bne	.L92
 772 0440 033192E7 	.L98:
 773              		.loc 1 503 0
 774              		ldmfd	sp!, {r4, r5, lr}
 775              		bx	lr
 776 0444 080081E5 	.L103:
 777              		.align	2
 778              	.L102:
 779              		.word	-536281088
 780 0448 000053E3 		.word	_pfnFrameHandler
 781              		.word	_pfnDevIntHandler
 782 044c 141091E5 		.word	_apfnEPIntHandlers
 783              	.LFE20:
 494:../LPCUSB/usbhw_lpc.c **** = USBRxData;
 495:../LPCUSB/usbhw_lpc.c **** 		}
 785              	l	USBHwInit
 787 0458 0F0000E2 	USBHwInit:
 788 045c 840380E1 	.LFB21:
 789 0460 8F0000E2 		.loc 1 521 0
 790 0464 1F1001E2 		@ Function supports interworking.
 791 0468 0FE0A0E1 		@ args = 0, pretend = 0, frame = 0
 792 046c 13FF2FE1 		@ frame_needed = 0, uses_anonymous_args = 0
 793              		.loc 1 523 0
 794              		ldr	r2, .L110
 795              		ldr	r3, [r2, #4]
 796 0470 014084E2 		bic	r3, r3, #49152
 797 0474 200054E3 		orr	r3, r3, #16384
 798 0478 E1FFFF1A 		str	r3, [r2, #4]
 799              		.loc 1 525 0
 496:../LPCUSB/usbhw_lpc.c ****  0) {
 497:../LPCUSB/usbhw_lpc.c **** 		return -1;
 498:../LPCUSB/usbhw_lpc.c **** 	}
 499:../LPCUSB/usbhw_lpc.c **** 	
 500:../LPCUSB/usbhw_lpc.c **** 	// get length
 501:../LPCUSB/usbhw_lpc.c **** 	dwLen &= PKT_LNGTH_MASK;
 502:../LPCUSB/usbhw_lpc.c **** 	
 503:../LPCUSB/usbhw_lpc.c **** 	// get data
 800              	4]
 801 047c 3040BDE8 		bic	r3, r3, #-1073741824
 802 0480 1EFF2FE1 		orr	r3, r3, #-2147483648
 803              		str	r3, [r2, #4]
 804              		.loc 1 528 0
 805              		add	r2, r2, #1900544
 806 0484 000009E0 		ldr	r3, [r2, #196]
 807 0488 00000000 		orr	r3, r3, #-2147483648
 808 048c 04000000 		str	r3, [r2, #196]
 809 0490 08000000 		.loc 1 531 0
 810              		mov	r3, #1
 811              		str	r3, [r2, #160]
 812              		.loc 1 521 0
 813              		str	lr, [sp, #-4]!
 814              	.LCFI7:
 815              		.loc 1 532 0
 816              		add	r3, r3, #34
 504:../LPCUSB/usbhw_lpc.c **** = 0;
 505:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 506:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 507:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 508:../LPCUSB/usbhw_lpc.c **** 		}
 509:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 510:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 511:../LPCUSB/usbhw_lpc.c **** 		}
 512:../LPCUSB/usbhw_lpc.c **** 		dwData >>= 8;
 513:../LPCUSB/usbhw_lpc.c **** 	}
 514:../LPCUSB/usbhw_lpc.c **** 
 515:../LPCUSB/usbhw_lpc.c **** 	// make sure RD_EN is clear
 516:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 517:../LPCUSB/usbhw_lpc.c **** 
 518:../LPCUSB/usbhw_lpc.c **** 	// select endpoint and clear buffer
 519:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_SELECT | idx);
 520:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_CLEAR_BUFFER);
 521:../LPCUSB/usbhw_lpc.c **** 	
 817              	4]
 818              		.loc 1 533 0
 819              		add	r3, r3, #135
 820              		str	r3, [r2, #172]
 522:../LPCUSB/usbhw_lpc.c **** 
 523:../LPCUSB/usbhw_lpc.c **** /**
 821              	c 1 534 0
 822 0494 B0209FE5 		mov	r3, #85
 823 0498 043092E5 		str	r3, [r2, #172]
 824 049c 0339C3E3 	.L105:
 825 04a0 013983E3 		.loc 1 535 0
 826 04a4 043082E5 		ldr	lr, .L110+4
 524:../LPCUSB/usbhw_lpc.c **** D_EN is clear
 525:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 827              	3, [lr, #168]
 828 04a8 043092E5 		tst	r3, #1024
 829 04ac 0331C3E3 		beq	.L105
 830 04b0 023183E3 		.loc 1 537 0
 831 04b4 043082E5 		mov	r3, #3
 526:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 527:../LPCUSB/usbhw_lpc.c **** 		}
 528:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 832              	r3, [lr, #160]
 833 04b8 1D2882E2 		.loc 1 542 0
 834 04bc C43092E5 		ldr	r2, .L110+8
 835 04c0 023183E3 		.loc 1 538 0
 836 04c4 C43082E5 		add	r3, r3, #167
 529:../LPCUSB/usbhw_lpc.c **** en &= PKT_LNGTH_MASK;
 530:../LPCUSB/usbhw_lpc.c **** 	
 531:../LPCUSB/usbhw_lpc.c **** 	// get data
 837              	r3, [lr, #172]
 838 04c8 0130A0E3 		.loc 1 542 0
 839 04cc A03082E5 		mov	r1, #0
 840              		.loc 1 543 0
 841 04d0 04E02DE5 		mvn	ip, #0
 842              		.loc 1 539 0
 532:../LPCUSB/usbhw_lpc.c **** Data = 0;
 843              	3, #85
 844 04d4 223083E2 		str	r3, [lr, #172]
 845 04d8 A43082E5 		.loc 1 551 0
 533:../LPCUSB/usbhw_lpc.c **** for (i = 0; i < dwLen; i++) {
 846              	v	r0, r1
 847 04dc 873083E2 		.loc 1 542 0
 848 04e0 AC3082E5 		str	r1, [r2, #4]
 534:../LPCUSB/usbhw_lpc.c **** 	if ((i % 4) == 0) {
 849              	oc 1 543 0
 850 04e4 5530A0E3 		str	ip, [r2, #8]
 851 04e8 AC3082E5 		.loc 1 544 0
 852              		str	r1, [r2, #44]
 535:../LPCUSB/usbhw_lpc.c **** t valid?
 853              	c 1 546 0
 854 04ec 5CE09FE5 		str	r1, [r2, #52]
 855 04f0 A8309EE5 		.loc 1 547 0
 856 04f4 010B13E3 		str	ip, [r2, #56]
 857 04f8 FBFFFF0A 		.loc 1 548 0
 536:../LPCUSB/usbhw_lpc.c **** if ((dwLen & DV) == 0) {
 537:../LPCUSB/usbhw_lpc.c **** 		return -1;
 858              	r1, [r2, #64]
 859 04fc 0330A0E3 		.loc 1 551 0
 860 0500 A0308EE5 		bl	USBHwNakIntEnable
 538:../LPCUSB/usbhw_lpc.c **** 
 539:../LPCUSB/usbhw_lpc.c **** 	
 540:../LPCUSB/usbhw_lpc.c **** 	// get length
 541:../LPCUSB/usbhw_lpc.c **** 	dwLen &= PKT_LNGTH_MASK;
 542:../LPCUSB/usbhw_lpc.c **** 	
 861              	oc 1 559 0
 862 0504 48209FE5 		mov	r0, #1
 863              		ldr	lr, [sp], #4
 864 0508 A73083E2 		bx	lr
 865 050c AC308EE5 	.L111:
 866              		.align	2
 867 0510 0010A0E3 	.L110:
 543:../LPCUSB/usbhw_lpc.c **** get data
 868              	-536690688
 869 0514 00C0E0E3 		.word	-534790144
 870              		.word	-536281088
 871 0518 5530A0E3 	.LFE21:
 544:../LPCUSB/usbhw_lpc.c **** dwData = 0;
 545:../LPCUSB/usbhw_lpc.c **** 	for (i = 0; i < dwLen; i++) {
 546:../LPCUSB/usbhw_lpc.c **** 		if ((i % 4) == 0) {
 547:../LPCUSB/usbhw_lpc.c **** 			dwData = USBRxData;
 548:../LPCUSB/usbhw_lpc.c **** 		}
 549:../LPCUSB/usbhw_lpc.c **** 		if ((pbBuf != NULL) && (i < iMaxLen)) {
 550:../LPCUSB/usbhw_lpc.c **** 			pbBuf[i] = dwData & 0xFF;
 551:../LPCUSB/usbhw_lpc.c **** 		}
 873              	
 874 0520 0100A0E1 		.align	2
 875              	_pfnFrameHandler:
 876 0524 041082E5 		.space	4
 877              		.align	2
 878 0528 08C082E5 	_pfnDevIntHandler:
 879              		.space	4
 880 052c 2C1082E5 		.align	2
 881              	_apfnEPIntHandlers:
 882 0530 341082E5 		.space	64
 883              		.section	.debug_frame,"",%progbits
 884 0534 38C082E5 	.Lframe0:
 885              		.4byte	.LECIE0-.LSCIE0
 886 0538 401082E5 	.LSCIE0:
 887              		.4byte	0xffffffff
 888 053c FEFFFFEB 		.byte	0x1
 552:../LPCUSB/usbhw_lpc.c ****  >>= 8;
 553:../LPCUSB/usbhw_lpc.c **** 	}
 554:../LPCUSB/usbhw_lpc.c **** 
 555:../LPCUSB/usbhw_lpc.c **** 	// make sure RD_EN is clear
 556:../LPCUSB/usbhw_lpc.c **** 	USBCtrl = 0;
 557:../LPCUSB/usbhw_lpc.c **** 
 558:../LPCUSB/usbhw_lpc.c **** 	// select endpoint and clear buffer
 559:../LPCUSB/usbhw_lpc.c **** 	USBHwCmd(CMD_EP_SELECT | idx);
 889              		.uleb128 0x1
 890 0540 0100A0E3 		.sleb128 -4
 891 0544 04E09DE4 		.byte	0xe
 892 0548 1EFF2FE1 		.byte	0xc
 893              		.uleb128 0xd
 894              		.uleb128 0x0
 895              		.align	2
 896 054c 00C002E0 	.LECIE0:
 897 0550 00C01FE0 	.LSFDE0:
 898 0554 000009E0 		.4byte	.LEFDE0-.LASFDE0
 899              	.LASFDE0:
 900              		.4byte	.Lframe0
 901              		.4byte	.LFB3
 902              		.4byte	.LFE3-.LFB3
 903              		.align	2
 904 0000 00000000 	.LEFDE0:
 905              	.LSFDE2:
 906              		.4byte	.LEFDE2-.LASFDE2
 907 0004 00000000 	.LASFDE2:
 908              		.4byte	.Lframe0
 909              		.4byte	.LFB4
 910 0008 00000000 		.4byte	.LFE4-.LFB4
 910      00000000 
 910      00000000 
 910      00000000 
 910      00000000 
 1127              	.LLST4:
DEFINED SYMBOLS
                            *ABS*:00000000 usbhw_lpc.c
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:12     .text:00000000 USBHwCmd
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:21     .text:00000000 $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:53     .text:00000038 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:58     .text:0000003c USBHwCmdWrite
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:65     .text:0000003c $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:99     .text:00000080 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:104    .text:00000084 USBHwCmdRead
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:111    .text:00000084 $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:147    .text:000000cc $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:153    .text:000000d0 USBHwEPConfig
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:164    .text:000000d0 $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:241    .text:00000128 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:249    .text:0000012c USBHwRegisterEPIntHandler
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:256    .text:0000012c $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:292    .text:00000170 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:909    .bss:00000008 _apfnEPIntHandlers
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:299    .text:00000178 USBHwRegisterDevIntHandler
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:308    .text:00000178 $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:325    .text:00000194 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:906    .bss:00000004 _pfnDevIntHandler
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:332    .text:0000019c USBHwRegisterFrameHandler
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:341    .text:0000019c $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:358    .text:000001b8 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:903    .bss:00000000 _pfnFrameHandler
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:365    .text:000001c0 USBHwSetAddress
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:373    .text:000001c0 $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:388    .text:000001d0 USBHwConnect
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:411    .text:000001e0 USBHwNakIntEnable
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:434    .text:000001ec USBHwEPGetStatus
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:462    .text:00000210 USBHwEPStall
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:490    .text:00000230 USBHwEPWrite
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:554    .text:000002b4 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:560    .text:000002b8 USBHwEPRead
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:567    .text:000002b8 $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:645    .text:00000358 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:651    .text:0000035c USBHwConfigDevice
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:660    .text:0000035c $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:674    .text:0000036c USBHwISR
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:806    .text:00000484 $d
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:815    .text:00000494 USBHwInit
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:822    .text:00000494 $a
C:\Users\nancyhd\AppData\Local\Temp/ccCMaaaa.s:896    .text:0000054c $d

NO UNDEFINED SYMBOLS
